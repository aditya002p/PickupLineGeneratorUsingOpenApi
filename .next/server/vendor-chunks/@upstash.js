"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@upstash";
exports.ids = ["vendor-chunks/@upstash"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@upstash/core-analytics/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@upstash/core-analytics/dist/index.js ***!
  \************************************************************/
/***/ ((module) => {

eval("var g=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var w=Object.prototype.hasOwnProperty;var y=(l,e)=>{for(var t in e)g(l,t,{get:e[t],enumerable:!0})},A=(l,e,t,n)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of _(e))!w.call(l,s)&&s!==t&&g(l,s,{get:()=>e[s],enumerable:!(n=k(e,s))||n.enumerable});return l};var S=l=>A(g({},\"__esModule\",{value:!0}),l);var x={};y(x,{Analytics:()=>b});module.exports=S(x);var p=`\nlocal key = KEYS[1]\nlocal field = ARGV[1]\n\nlocal data = redis.call(\"ZRANGE\", key, 0, -1, \"WITHSCORES\")\nlocal count = {}\n\nfor i = 1, #data, 2 do\n  local json_str = data[i]\n  local score = tonumber(data[i + 1])\n  local obj = cjson.decode(json_str)\n\n  local fieldValue = obj[field]\n\n  if count[fieldValue] == nil then\n    count[fieldValue] = score\n  else\n    count[fieldValue] = count[fieldValue] + score\n  end\nend\n\nlocal result = {}\nfor k, v in pairs(count) do\n  table.insert(result, {k, v})\nend\n\nreturn result\n`,f=`\nlocal prefix = KEYS[1]\nlocal first_timestamp = tonumber(ARGV[1])\nlocal increment = tonumber(ARGV[2])\nlocal num_timestamps = tonumber(ARGV[3])\nlocal num_elements = tonumber(ARGV[4])\n\nlocal keys = {}\nfor i = 1, num_timestamps do\n  local timestamp = first_timestamp - (i - 1) * increment\n  table.insert(keys, prefix .. \":\" .. timestamp)\nend\n\n-- get the union of the groups\nlocal zunion_params = {\"ZUNION\", num_timestamps, unpack(keys)}\ntable.insert(zunion_params, \"WITHSCORES\")\nlocal result = redis.call(unpack(zunion_params))\n\n-- select num_elements many items\nlocal true_group = {}\nlocal false_group = {}\nlocal denied_group = {}\nlocal true_count = 0\nlocal false_count = 0\nlocal denied_count = 0\nlocal i = #result - 1\n\n-- iterate over the results\nwhile (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i do\n  local score = tonumber(result[i + 1])\n  if score > 0 then\n    local element = result[i]\n    if string.find(element, \"success\\\\\":true\") and true_count < num_elements then\n      table.insert(true_group, {score, element})\n      true_count = true_count + 1\n    elseif string.find(element, \"success\\\\\":false\") and false_count < num_elements then\n      table.insert(false_group, {score, element})\n      false_count = false_count + 1\n    elseif string.find(element, \"success\\\\\":\\\\\"denied\") and denied_count < num_elements then\n      table.insert(denied_group, {score, element})\n      denied_count = denied_count + 1\n    end\n  end\n  i = i - 2\nend\n\nreturn {true_group, false_group, denied_group}\n`,h=`\nlocal prefix = KEYS[1]\nlocal first_timestamp = tonumber(ARGV[1])\nlocal increment = tonumber(ARGV[2])\nlocal num_timestamps = tonumber(ARGV[3])\n\nlocal keys = {}\nfor i = 1, num_timestamps do\n  local timestamp = first_timestamp - (i - 1) * increment\n  table.insert(keys, prefix .. \":\" .. timestamp)\nend\n\n-- get the union of the groups\nlocal zunion_params = {\"ZUNION\", num_timestamps, unpack(keys)}\ntable.insert(zunion_params, \"WITHSCORES\")\nlocal result = redis.call(unpack(zunion_params))\n\nreturn result\n`;var b=class{redis;prefix;bucketSize;constructor(e){this.redis=e.redis,this.prefix=e.prefix??\"@upstash/analytics\",this.bucketSize=this.parseWindow(e.window)}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if(typeof e==\"number\"){if(e<=0)throw new Error(`Invalid window: ${e}`);return e}let t=/^(\\d+)([smhd])$/;if(!t.test(e))throw new Error(`Invalid window: ${e}`);let[,n,s]=e.match(t),i=parseInt(n);switch(s){case\"s\":return i*1e3;case\"m\":return i*1e3*60;case\"h\":return i*1e3*60*60;case\"d\":return i*1e3*60*60*24;default:throw new Error(`Invalid window unit: ${s}`)}}getBucket(e){let t=e??Date.now();return Math.floor(t/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async n=>{let s=this.getBucket(n.time),i=[this.prefix,e,s].join(\":\");await this.redis.zincrby(i,1,JSON.stringify({...n,time:void 0}))}))}formatBucketAggregate(e,t,n){let s={};return e.forEach(([i,r])=>{t==\"success\"&&(i=i===1?\"true\":i===null?\"false\":i),s[t]=s[t]||{},s[t][(i??\"null\").toString()]=r}),{time:n,...s}}async aggregateBucket(e,t,n){this.validateTableName(e);let s=this.getBucket(n),i=[this.prefix,e,s].join(\":\"),r=await this.redis.eval(p,[i],[t]);return this.formatBucketAggregate(r,t,s)}async aggregateBuckets(e,t,n,s){this.validateTableName(e);let i=this.getBucket(s),r=[];for(let o=0;o<n;o+=1)r.push(this.aggregateBucket(e,t,i)),i=i-this.bucketSize;return Promise.all(r)}async aggregateBucketsWithPipeline(e,t,n,s,i){this.validateTableName(e),i=i??48;let r=this.getBucket(s),o=[],c=this.redis.pipeline(),u=[];for(let a=1;a<=n;a+=1){let d=[this.prefix,e,r].join(\":\");c.eval(p,[d],[t]),o.push(r),r=r-this.bucketSize,(a%i==0||a==n)&&(u.push(c.exec()),c=this.redis.pipeline())}return(await Promise.all(u)).flat().map((a,d)=>this.formatBucketAggregate(a,t,o[d]))}async getAllowedBlocked(e,t,n){this.validateTableName(e);let s=[this.prefix,e].join(\":\"),i=this.getBucket(n),r=await this.redis.eval(h,[s],[i,this.bucketSize,t]),o={};for(let c=0;c<r.length;c+=2){let u=r[c],m=u.identifier,a=+r[c+1];o[m]||(o[m]={success:0,blocked:0}),o[m][u.success?\"success\":\"blocked\"]=a}return o}async getMostAllowedBlocked(e,t,n,s){this.validateTableName(e);let i=[this.prefix,e].join(\":\"),r=this.getBucket(s),[o,c,u]=await this.redis.eval(f,[i],[r,this.bucketSize,t,n]);return{allowed:this.toDicts(o),ratelimited:this.toDicts(c),denied:this.toDicts(u)}}toDicts(e){let t=[];for(let n=0;n<e.length;n+=1){let s=+e[n][0],i=e[n][1];t.push({identifier:i.identifier,count:s})}return t}};0&&(0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9jb3JlLWFuYWx5dGljcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDRCQUE0QixzQ0FBc0MsaUNBQWlDLHNDQUFzQyxjQUFjLHNCQUFzQix1QkFBdUIsRUFBRSxlQUFlLDZGQUE2RixrREFBa0QsRUFBRSxVQUFVLGVBQWUsZUFBZSxTQUFTLEtBQUssU0FBUyxLQUFLLGdCQUFnQixFQUFFLG9CQUFvQjtBQUM3ZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRSxZQUFZLE1BQU0sT0FBTyxXQUFXLGVBQWUseUdBQXlHLHFCQUFxQixzRUFBc0UsRUFBRSwyRUFBMkUsZUFBZSx1QkFBdUIsMkNBQTJDLEVBQUUsR0FBRyxTQUFTLHdCQUF3QixpREFBaUQsRUFBRSxHQUFHLG1DQUFtQyxVQUFVLHFCQUFxQix3QkFBd0IsMkJBQTJCLDhCQUE4QixnREFBZ0QsRUFBRSxJQUFJLGFBQWEsb0JBQW9CLHFEQUFxRCxxQkFBcUIsNERBQTRELDJEQUEyRCw2Q0FBNkMsaUJBQWlCLEdBQUcsR0FBRyw2QkFBNkIsU0FBUywyQkFBMkIsK0RBQStELGdDQUFnQyxHQUFHLGFBQWEsNkJBQTZCLDBCQUEwQix5RkFBeUYseUNBQXlDLGdDQUFnQywwQkFBMEIsNkJBQTZCLFlBQVksSUFBSSw2REFBNkQsc0JBQXNCLDhDQUE4QyxrQ0FBa0MsMERBQTBELFlBQVksS0FBSyxNQUFNLGtDQUFrQywyR0FBMkcscUZBQXFGLCtCQUErQiwwQkFBMEIsOEdBQThHLFlBQVksV0FBVyxNQUFNLG9DQUFvQyxhQUFhLG9CQUFvQix3Q0FBd0MsU0FBUyxxQ0FBcUMsMEJBQTBCLGlIQUFpSCxPQUFPLDRFQUE0RSxXQUFXLFNBQVMsWUFBWSxXQUFXLE1BQU0seUJBQXlCLFFBQVEsZ0NBQWdDLEVBQUUsV0FBVyxJQUFJLENBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGlja3VwX2xpbmVfZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0B1cHN0YXNoL2NvcmUtYW5hbHl0aWNzL2Rpc3QvaW5kZXguanM/MWY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjt2YXIgZz1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIGs9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgXz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgdz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciB5PShsLGUpPT57Zm9yKHZhciB0IGluIGUpZyhsLHQse2dldDplW3RdLGVudW1lcmFibGU6ITB9KX0sQT0obCxlLHQsbik9PntpZihlJiZ0eXBlb2YgZT09XCJvYmplY3RcInx8dHlwZW9mIGU9PVwiZnVuY3Rpb25cIilmb3IobGV0IHMgb2YgXyhlKSkhdy5jYWxsKGwscykmJnMhPT10JiZnKGwscyx7Z2V0OigpPT5lW3NdLGVudW1lcmFibGU6IShuPWsoZSxzKSl8fG4uZW51bWVyYWJsZX0pO3JldHVybiBsfTt2YXIgUz1sPT5BKGcoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbCk7dmFyIHg9e307eSh4LHtBbmFseXRpY3M6KCk9PmJ9KTttb2R1bGUuZXhwb3J0cz1TKHgpO3ZhciBwPWBcbmxvY2FsIGtleSA9IEtFWVNbMV1cbmxvY2FsIGZpZWxkID0gQVJHVlsxXVxuXG5sb2NhbCBkYXRhID0gcmVkaXMuY2FsbChcIlpSQU5HRVwiLCBrZXksIDAsIC0xLCBcIldJVEhTQ09SRVNcIilcbmxvY2FsIGNvdW50ID0ge31cblxuZm9yIGkgPSAxLCAjZGF0YSwgMiBkb1xuICBsb2NhbCBqc29uX3N0ciA9IGRhdGFbaV1cbiAgbG9jYWwgc2NvcmUgPSB0b251bWJlcihkYXRhW2kgKyAxXSlcbiAgbG9jYWwgb2JqID0gY2pzb24uZGVjb2RlKGpzb25fc3RyKVxuXG4gIGxvY2FsIGZpZWxkVmFsdWUgPSBvYmpbZmllbGRdXG5cbiAgaWYgY291bnRbZmllbGRWYWx1ZV0gPT0gbmlsIHRoZW5cbiAgICBjb3VudFtmaWVsZFZhbHVlXSA9IHNjb3JlXG4gIGVsc2VcbiAgICBjb3VudFtmaWVsZFZhbHVlXSA9IGNvdW50W2ZpZWxkVmFsdWVdICsgc2NvcmVcbiAgZW5kXG5lbmRcblxubG9jYWwgcmVzdWx0ID0ge31cbmZvciBrLCB2IGluIHBhaXJzKGNvdW50KSBkb1xuICB0YWJsZS5pbnNlcnQocmVzdWx0LCB7aywgdn0pXG5lbmRcblxucmV0dXJuIHJlc3VsdFxuYCxmPWBcbmxvY2FsIHByZWZpeCA9IEtFWVNbMV1cbmxvY2FsIGZpcnN0X3RpbWVzdGFtcCA9IHRvbnVtYmVyKEFSR1ZbMV0pXG5sb2NhbCBpbmNyZW1lbnQgPSB0b251bWJlcihBUkdWWzJdKVxubG9jYWwgbnVtX3RpbWVzdGFtcHMgPSB0b251bWJlcihBUkdWWzNdKVxubG9jYWwgbnVtX2VsZW1lbnRzID0gdG9udW1iZXIoQVJHVls0XSlcblxubG9jYWwga2V5cyA9IHt9XG5mb3IgaSA9IDEsIG51bV90aW1lc3RhbXBzIGRvXG4gIGxvY2FsIHRpbWVzdGFtcCA9IGZpcnN0X3RpbWVzdGFtcCAtIChpIC0gMSkgKiBpbmNyZW1lbnRcbiAgdGFibGUuaW5zZXJ0KGtleXMsIHByZWZpeCAuLiBcIjpcIiAuLiB0aW1lc3RhbXApXG5lbmRcblxuLS0gZ2V0IHRoZSB1bmlvbiBvZiB0aGUgZ3JvdXBzXG5sb2NhbCB6dW5pb25fcGFyYW1zID0ge1wiWlVOSU9OXCIsIG51bV90aW1lc3RhbXBzLCB1bnBhY2soa2V5cyl9XG50YWJsZS5pbnNlcnQoenVuaW9uX3BhcmFtcywgXCJXSVRIU0NPUkVTXCIpXG5sb2NhbCByZXN1bHQgPSByZWRpcy5jYWxsKHVucGFjayh6dW5pb25fcGFyYW1zKSlcblxuLS0gc2VsZWN0IG51bV9lbGVtZW50cyBtYW55IGl0ZW1zXG5sb2NhbCB0cnVlX2dyb3VwID0ge31cbmxvY2FsIGZhbHNlX2dyb3VwID0ge31cbmxvY2FsIGRlbmllZF9ncm91cCA9IHt9XG5sb2NhbCB0cnVlX2NvdW50ID0gMFxubG9jYWwgZmFsc2VfY291bnQgPSAwXG5sb2NhbCBkZW5pZWRfY291bnQgPSAwXG5sb2NhbCBpID0gI3Jlc3VsdCAtIDFcblxuLS0gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzXG53aGlsZSAodHJ1ZV9jb3VudCArIGZhbHNlX2NvdW50ICsgZGVuaWVkX2NvdW50KSA8IChudW1fZWxlbWVudHMgKiAzKSBhbmQgMSA8PSBpIGRvXG4gIGxvY2FsIHNjb3JlID0gdG9udW1iZXIocmVzdWx0W2kgKyAxXSlcbiAgaWYgc2NvcmUgPiAwIHRoZW5cbiAgICBsb2NhbCBlbGVtZW50ID0gcmVzdWx0W2ldXG4gICAgaWYgc3RyaW5nLmZpbmQoZWxlbWVudCwgXCJzdWNjZXNzXFxcXFwiOnRydWVcIikgYW5kIHRydWVfY291bnQgPCBudW1fZWxlbWVudHMgdGhlblxuICAgICAgdGFibGUuaW5zZXJ0KHRydWVfZ3JvdXAsIHtzY29yZSwgZWxlbWVudH0pXG4gICAgICB0cnVlX2NvdW50ID0gdHJ1ZV9jb3VudCArIDFcbiAgICBlbHNlaWYgc3RyaW5nLmZpbmQoZWxlbWVudCwgXCJzdWNjZXNzXFxcXFwiOmZhbHNlXCIpIGFuZCBmYWxzZV9jb3VudCA8IG51bV9lbGVtZW50cyB0aGVuXG4gICAgICB0YWJsZS5pbnNlcnQoZmFsc2VfZ3JvdXAsIHtzY29yZSwgZWxlbWVudH0pXG4gICAgICBmYWxzZV9jb3VudCA9IGZhbHNlX2NvdW50ICsgMVxuICAgIGVsc2VpZiBzdHJpbmcuZmluZChlbGVtZW50LCBcInN1Y2Nlc3NcXFxcXCI6XFxcXFwiZGVuaWVkXCIpIGFuZCBkZW5pZWRfY291bnQgPCBudW1fZWxlbWVudHMgdGhlblxuICAgICAgdGFibGUuaW5zZXJ0KGRlbmllZF9ncm91cCwge3Njb3JlLCBlbGVtZW50fSlcbiAgICAgIGRlbmllZF9jb3VudCA9IGRlbmllZF9jb3VudCArIDFcbiAgICBlbmRcbiAgZW5kXG4gIGkgPSBpIC0gMlxuZW5kXG5cbnJldHVybiB7dHJ1ZV9ncm91cCwgZmFsc2VfZ3JvdXAsIGRlbmllZF9ncm91cH1cbmAsaD1gXG5sb2NhbCBwcmVmaXggPSBLRVlTWzFdXG5sb2NhbCBmaXJzdF90aW1lc3RhbXAgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgaW5jcmVtZW50ID0gdG9udW1iZXIoQVJHVlsyXSlcbmxvY2FsIG51bV90aW1lc3RhbXBzID0gdG9udW1iZXIoQVJHVlszXSlcblxubG9jYWwga2V5cyA9IHt9XG5mb3IgaSA9IDEsIG51bV90aW1lc3RhbXBzIGRvXG4gIGxvY2FsIHRpbWVzdGFtcCA9IGZpcnN0X3RpbWVzdGFtcCAtIChpIC0gMSkgKiBpbmNyZW1lbnRcbiAgdGFibGUuaW5zZXJ0KGtleXMsIHByZWZpeCAuLiBcIjpcIiAuLiB0aW1lc3RhbXApXG5lbmRcblxuLS0gZ2V0IHRoZSB1bmlvbiBvZiB0aGUgZ3JvdXBzXG5sb2NhbCB6dW5pb25fcGFyYW1zID0ge1wiWlVOSU9OXCIsIG51bV90aW1lc3RhbXBzLCB1bnBhY2soa2V5cyl9XG50YWJsZS5pbnNlcnQoenVuaW9uX3BhcmFtcywgXCJXSVRIU0NPUkVTXCIpXG5sb2NhbCByZXN1bHQgPSByZWRpcy5jYWxsKHVucGFjayh6dW5pb25fcGFyYW1zKSlcblxucmV0dXJuIHJlc3VsdFxuYDt2YXIgYj1jbGFzc3tyZWRpcztwcmVmaXg7YnVja2V0U2l6ZTtjb25zdHJ1Y3RvcihlKXt0aGlzLnJlZGlzPWUucmVkaXMsdGhpcy5wcmVmaXg9ZS5wcmVmaXg/P1wiQHVwc3Rhc2gvYW5hbHl0aWNzXCIsdGhpcy5idWNrZXRTaXplPXRoaXMucGFyc2VXaW5kb3coZS53aW5kb3cpfXZhbGlkYXRlVGFibGVOYW1lKGUpe2lmKCEvXlthLXpBLVowLTlfLV0rJC8udGVzdChlKSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFibGUgbmFtZTogJHtlfS4gVGFibGUgbmFtZXMgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzLmApfXBhcnNlV2luZG93KGUpe2lmKHR5cGVvZiBlPT1cIm51bWJlclwiKXtpZihlPD0wKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aW5kb3c6ICR7ZX1gKTtyZXR1cm4gZX1sZXQgdD0vXihcXGQrKShbc21oZF0pJC87aWYoIXQudGVzdChlKSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2luZG93OiAke2V9YCk7bGV0WyxuLHNdPWUubWF0Y2godCksaT1wYXJzZUludChuKTtzd2l0Y2gocyl7Y2FzZVwic1wiOnJldHVybiBpKjFlMztjYXNlXCJtXCI6cmV0dXJuIGkqMWUzKjYwO2Nhc2VcImhcIjpyZXR1cm4gaSoxZTMqNjAqNjA7Y2FzZVwiZFwiOnJldHVybiBpKjFlMyo2MCo2MCoyNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aW5kb3cgdW5pdDogJHtzfWApfX1nZXRCdWNrZXQoZSl7bGV0IHQ9ZT8/RGF0ZS5ub3coKTtyZXR1cm4gTWF0aC5mbG9vcih0L3RoaXMuYnVja2V0U2l6ZSkqdGhpcy5idWNrZXRTaXplfWFzeW5jIGluZ2VzdChlLC4uLnQpe3RoaXMudmFsaWRhdGVUYWJsZU5hbWUoZSksYXdhaXQgUHJvbWlzZS5hbGwodC5tYXAoYXN5bmMgbj0+e2xldCBzPXRoaXMuZ2V0QnVja2V0KG4udGltZSksaT1bdGhpcy5wcmVmaXgsZSxzXS5qb2luKFwiOlwiKTthd2FpdCB0aGlzLnJlZGlzLnppbmNyYnkoaSwxLEpTT04uc3RyaW5naWZ5KHsuLi5uLHRpbWU6dm9pZCAwfSkpfSkpfWZvcm1hdEJ1Y2tldEFnZ3JlZ2F0ZShlLHQsbil7bGV0IHM9e307cmV0dXJuIGUuZm9yRWFjaCgoW2kscl0pPT57dD09XCJzdWNjZXNzXCImJihpPWk9PT0xP1widHJ1ZVwiOmk9PT1udWxsP1wiZmFsc2VcIjppKSxzW3RdPXNbdF18fHt9LHNbdF1bKGk/P1wibnVsbFwiKS50b1N0cmluZygpXT1yfSkse3RpbWU6biwuLi5zfX1hc3luYyBhZ2dyZWdhdGVCdWNrZXQoZSx0LG4pe3RoaXMudmFsaWRhdGVUYWJsZU5hbWUoZSk7bGV0IHM9dGhpcy5nZXRCdWNrZXQobiksaT1bdGhpcy5wcmVmaXgsZSxzXS5qb2luKFwiOlwiKSxyPWF3YWl0IHRoaXMucmVkaXMuZXZhbChwLFtpXSxbdF0pO3JldHVybiB0aGlzLmZvcm1hdEJ1Y2tldEFnZ3JlZ2F0ZShyLHQscyl9YXN5bmMgYWdncmVnYXRlQnVja2V0cyhlLHQsbixzKXt0aGlzLnZhbGlkYXRlVGFibGVOYW1lKGUpO2xldCBpPXRoaXMuZ2V0QnVja2V0KHMpLHI9W107Zm9yKGxldCBvPTA7bzxuO28rPTEpci5wdXNoKHRoaXMuYWdncmVnYXRlQnVja2V0KGUsdCxpKSksaT1pLXRoaXMuYnVja2V0U2l6ZTtyZXR1cm4gUHJvbWlzZS5hbGwocil9YXN5bmMgYWdncmVnYXRlQnVja2V0c1dpdGhQaXBlbGluZShlLHQsbixzLGkpe3RoaXMudmFsaWRhdGVUYWJsZU5hbWUoZSksaT1pPz80ODtsZXQgcj10aGlzLmdldEJ1Y2tldChzKSxvPVtdLGM9dGhpcy5yZWRpcy5waXBlbGluZSgpLHU9W107Zm9yKGxldCBhPTE7YTw9bjthKz0xKXtsZXQgZD1bdGhpcy5wcmVmaXgsZSxyXS5qb2luKFwiOlwiKTtjLmV2YWwocCxbZF0sW3RdKSxvLnB1c2gocikscj1yLXRoaXMuYnVja2V0U2l6ZSwoYSVpPT0wfHxhPT1uKSYmKHUucHVzaChjLmV4ZWMoKSksYz10aGlzLnJlZGlzLnBpcGVsaW5lKCkpfXJldHVybihhd2FpdCBQcm9taXNlLmFsbCh1KSkuZmxhdCgpLm1hcCgoYSxkKT0+dGhpcy5mb3JtYXRCdWNrZXRBZ2dyZWdhdGUoYSx0LG9bZF0pKX1hc3luYyBnZXRBbGxvd2VkQmxvY2tlZChlLHQsbil7dGhpcy52YWxpZGF0ZVRhYmxlTmFtZShlKTtsZXQgcz1bdGhpcy5wcmVmaXgsZV0uam9pbihcIjpcIiksaT10aGlzLmdldEJ1Y2tldChuKSxyPWF3YWl0IHRoaXMucmVkaXMuZXZhbChoLFtzXSxbaSx0aGlzLmJ1Y2tldFNpemUsdF0pLG89e307Zm9yKGxldCBjPTA7YzxyLmxlbmd0aDtjKz0yKXtsZXQgdT1yW2NdLG09dS5pZGVudGlmaWVyLGE9K3JbYysxXTtvW21dfHwob1ttXT17c3VjY2VzczowLGJsb2NrZWQ6MH0pLG9bbV1bdS5zdWNjZXNzP1wic3VjY2Vzc1wiOlwiYmxvY2tlZFwiXT1hfXJldHVybiBvfWFzeW5jIGdldE1vc3RBbGxvd2VkQmxvY2tlZChlLHQsbixzKXt0aGlzLnZhbGlkYXRlVGFibGVOYW1lKGUpO2xldCBpPVt0aGlzLnByZWZpeCxlXS5qb2luKFwiOlwiKSxyPXRoaXMuZ2V0QnVja2V0KHMpLFtvLGMsdV09YXdhaXQgdGhpcy5yZWRpcy5ldmFsKGYsW2ldLFtyLHRoaXMuYnVja2V0U2l6ZSx0LG5dKTtyZXR1cm57YWxsb3dlZDp0aGlzLnRvRGljdHMobykscmF0ZWxpbWl0ZWQ6dGhpcy50b0RpY3RzKGMpLGRlbmllZDp0aGlzLnRvRGljdHModSl9fXRvRGljdHMoZSl7bGV0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKz0xKXtsZXQgcz0rZVtuXVswXSxpPWVbbl1bMV07dC5wdXNoKHtpZGVudGlmaWVyOmkuaWRlbnRpZmllcixjb3VudDpzfSl9cmV0dXJuIHR9fTswJiYobW9kdWxlLmV4cG9ydHM9e0FuYWx5dGljc30pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@upstash/core-analytics/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@upstash/ratelimit/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@upstash/ratelimit/dist/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Analytics: () => Analytics,\n  IpDenyList: () => ip_deny_list_exports,\n  MultiRegionRatelimit: () => MultiRegionRatelimit,\n  Ratelimit: () => RegionRatelimit\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/analytics.ts\nvar import_core_analytics = __webpack_require__(/*! @upstash/core-analytics */ \"(action-browser)/./node_modules/@upstash/core-analytics/dist/index.js\");\nvar Analytics = class {\n  analytics;\n  table = \"events\";\n  constructor(config) {\n    this.analytics = new import_core_analytics.Analytics({\n      // @ts-expect-error we need to fix the types in core-analytics, it should only require the methods it needs, not the whole sdk\n      redis: config.redis,\n      window: \"1h\",\n      prefix: config.prefix ?? \"@upstash/ratelimit\",\n      retention: \"90d\"\n    });\n  }\n  /**\n   * Try to extract the geo information from the request\n   *\n   * This handles Vercel's `req.geo` and  and Cloudflare's `request.cf` properties\n   * @param req\n   * @returns\n   */\n  extractGeo(req) {\n    if (typeof req.geo !== \"undefined\") {\n      return req.geo;\n    }\n    if (typeof req.cf !== \"undefined\") {\n      return req.cf;\n    }\n    return {};\n  }\n  async record(event) {\n    await this.analytics.ingest(this.table, event);\n  }\n  async series(filter, cutoff) {\n    const timestampCount = Math.min(\n      (this.analytics.getBucket(Date.now()) - this.analytics.getBucket(cutoff)) / (60 * 60 * 1e3),\n      256\n    );\n    return this.analytics.aggregateBucketsWithPipeline(this.table, filter, timestampCount);\n  }\n  async getUsage(cutoff = 0) {\n    const timestampCount = Math.min(\n      (this.analytics.getBucket(Date.now()) - this.analytics.getBucket(cutoff)) / (60 * 60 * 1e3),\n      256\n    );\n    const records = await this.analytics.getAllowedBlocked(this.table, timestampCount);\n    return records;\n  }\n  async getUsageOverTime(timestampCount, groupby) {\n    const result = await this.analytics.aggregateBucketsWithPipeline(this.table, groupby, timestampCount);\n    return result;\n  }\n  async getMostAllowedBlocked(timestampCount, getTop) {\n    getTop = getTop ?? 5;\n    return this.analytics.getMostAllowedBlocked(this.table, timestampCount, getTop);\n  }\n};\n\n// src/cache.ts\nvar Cache = class {\n  /**\n   * Stores identifier -> reset (in milliseconds)\n   */\n  cache;\n  constructor(cache) {\n    this.cache = cache;\n  }\n  isBlocked(identifier) {\n    if (!this.cache.has(identifier)) {\n      return { blocked: false, reset: 0 };\n    }\n    const reset = this.cache.get(identifier);\n    if (reset < Date.now()) {\n      this.cache.delete(identifier);\n      return { blocked: false, reset: 0 };\n    }\n    return { blocked: true, reset };\n  }\n  blockUntil(identifier, reset) {\n    this.cache.set(identifier, reset);\n  }\n  set(key, value) {\n    this.cache.set(key, value);\n  }\n  get(key) {\n    return this.cache.get(key) || null;\n  }\n  incr(key) {\n    let value = this.cache.get(key) ?? 0;\n    value += 1;\n    this.cache.set(key, value);\n    return value;\n  }\n  pop(key) {\n    this.cache.delete(key);\n  }\n  empty() {\n    this.cache.clear();\n  }\n  size() {\n    return this.cache.size;\n  }\n};\n\n// src/duration.ts\nfunction ms(d) {\n  const match = d.match(/^(\\d+)\\s?(ms|s|m|h|d)$/);\n  if (!match) {\n    throw new Error(`Unable to parse window size: ${d}`);\n  }\n  const time = Number.parseInt(match[1]);\n  const unit = match[2];\n  switch (unit) {\n    case \"ms\":\n      return time;\n    case \"s\":\n      return time * 1e3;\n    case \"m\":\n      return time * 1e3 * 60;\n    case \"h\":\n      return time * 1e3 * 60 * 60;\n    case \"d\":\n      return time * 1e3 * 60 * 60 * 24;\n    default:\n      throw new Error(`Unable to parse window size: ${d}`);\n  }\n}\n\n// src/hash.ts\nvar setHash = async (ctx, script, kind) => {\n  const regionContexts = \"redis\" in ctx ? [ctx] : ctx.regionContexts;\n  const hashSample = regionContexts[0].scriptHashes[kind];\n  if (!hashSample) {\n    await Promise.all(regionContexts.map(async (context) => {\n      context.scriptHashes[kind] = await context.redis.scriptLoad(script);\n    }));\n  }\n  ;\n};\nvar safeEval = async (ctx, script, kind, keys, args) => {\n  if (!ctx.cacheScripts) {\n    return await ctx.redis.eval(script, keys, args);\n  }\n  ;\n  await setHash(ctx, script, kind);\n  try {\n    return await ctx.redis.evalsha(ctx.scriptHashes[kind], keys, args);\n  } catch (error) {\n    if (`${error}`.includes(\"NOSCRIPT\")) {\n      console.log(\"Script with the expected hash was not found in redis db. It is probably flushed. Will load another scipt before continuing.\");\n      ctx.scriptHashes[kind] = void 0;\n      await setHash(ctx, script, kind);\n      console.log(\"  New script successfully loaded.\");\n      return await ctx.redis.evalsha(ctx.scriptHashes[kind], keys, args);\n    }\n    throw error;\n  }\n};\n\n// src/lua-scripts/multi.ts\nvar fixedWindowLimitScript = `\n\tlocal key           = KEYS[1]\n\tlocal id            = ARGV[1]\n\tlocal window        = ARGV[2]\n\tlocal incrementBy   = tonumber(ARGV[3])\n\n\tredis.call(\"HSET\", key, id, incrementBy)\n\tlocal fields = redis.call(\"HGETALL\", key)\n\tif #fields == 2 and tonumber(fields[2])==incrementBy then\n\t-- The first time this key is set, and the value will be equal to incrementBy.\n\t-- So we only need the expire command once\n\t  redis.call(\"PEXPIRE\", key, window)\n\tend\n\n\treturn fields\n`;\nvar fixedWindowRemainingTokensScript = `\n      local key = KEYS[1]\n      local tokens = 0\n\n      local fields = redis.call(\"HGETALL\", key)\n\n      return fields\n    `;\nvar slidingWindowLimitScript = `\n\tlocal currentKey    = KEYS[1]           -- identifier including prefixes\n\tlocal previousKey   = KEYS[2]           -- key of the previous bucket\n\tlocal tokens        = tonumber(ARGV[1]) -- tokens per window\n\tlocal now           = ARGV[2]           -- current timestamp in milliseconds\n\tlocal window        = ARGV[3]           -- interval in milliseconds\n\tlocal requestId     = ARGV[4]           -- uuid for this request\n\tlocal incrementBy   = tonumber(ARGV[5]) -- custom rate, default is  1\n\n\tlocal currentFields = redis.call(\"HGETALL\", currentKey)\n\tlocal requestsInCurrentWindow = 0\n\tfor i = 2, #currentFields, 2 do\n\trequestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])\n\tend\n\n\tlocal previousFields = redis.call(\"HGETALL\", previousKey)\n\tlocal requestsInPreviousWindow = 0\n\tfor i = 2, #previousFields, 2 do\n\trequestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])\n\tend\n\n\tlocal percentageInCurrent = ( now % window) / window\n\tif requestsInPreviousWindow * (1 - percentageInCurrent ) + requestsInCurrentWindow >= tokens then\n\t  return {currentFields, previousFields, false}\n\tend\n\n\tredis.call(\"HSET\", currentKey, requestId, incrementBy)\n\n\tif requestsInCurrentWindow == 0 then \n\t  -- The first time this key is set, the value will be equal to incrementBy.\n\t  -- So we only need the expire command once\n\t  redis.call(\"PEXPIRE\", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second\n\tend\n\treturn {currentFields, previousFields, true}\n`;\nvar slidingWindowRemainingTokensScript = `\n\tlocal currentKey    = KEYS[1]           -- identifier including prefixes\n\tlocal previousKey   = KEYS[2]           -- key of the previous bucket\n\tlocal now         \t= ARGV[1]           -- current timestamp in milliseconds\n  \tlocal window      \t= ARGV[2]           -- interval in milliseconds\n\n\tlocal currentFields = redis.call(\"HGETALL\", currentKey)\n\tlocal requestsInCurrentWindow = 0\n\tfor i = 2, #currentFields, 2 do\n\trequestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])\n\tend\n\n\tlocal previousFields = redis.call(\"HGETALL\", previousKey)\n\tlocal requestsInPreviousWindow = 0\n\tfor i = 2, #previousFields, 2 do\n\trequestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])\n\tend\n\n\tlocal percentageInCurrent = ( now % window) / window\n  \trequestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)\n\t\n\treturn requestsInCurrentWindow + requestsInPreviousWindow\n`;\n\n// src/lua-scripts/reset.ts\nvar resetScript = `\n      local pattern = KEYS[1]\n\n      -- Initialize cursor to start from 0\n      local cursor = \"0\"\n\n      repeat\n          -- Scan for keys matching the pattern\n          local scan_result = redis.call('SCAN', cursor, 'MATCH', pattern)\n\n          -- Extract cursor for the next iteration\n          cursor = scan_result[1]\n\n          -- Extract keys from the scan result\n          local keys = scan_result[2]\n\n          for i=1, #keys do\n          redis.call('DEL', keys[i])\n          end\n\n      -- Continue scanning until cursor is 0 (end of keyspace)\n      until cursor == \"0\"\n    `;\n\n// src/types.ts\nvar DenyListExtension = \"denyList\";\nvar IpDenyListKey = \"ipDenyList\";\nvar IpDenyListStatusKey = \"ipDenyListStatus\";\n\n// src/deny-list/scripts.ts\nvar checkDenyListScript = `\n  -- Checks if values provideed in ARGV are present in the deny lists.\n  -- This is done using the allDenyListsKey below.\n\n  -- Additionally, checks the status of the ip deny list using the\n  -- ipDenyListStatusKey below. Here are the possible states of the\n  -- ipDenyListStatusKey key:\n  -- * status == -1: set to \"disabled\" with no TTL\n  -- * status == -2: not set, meaning that is was set before but expired\n  -- * status  >  0: set to \"valid\", with a TTL\n  --\n  -- In the case of status == -2, we set the status to \"pending\" with\n  -- 30 second ttl. During this time, the process which got status == -2\n  -- will update the ip deny list.\n\n  local allDenyListsKey     = KEYS[1]\n  local ipDenyListStatusKey = KEYS[2]\n\n  local results = redis.call('SMISMEMBER', allDenyListsKey, unpack(ARGV))\n  local status  = redis.call('TTL', ipDenyListStatusKey)\n  if status == -2 then\n    redis.call('SETEX', ipDenyListStatusKey, 30, \"pending\")\n  end\n\n  return { results, status }\n`;\n\n// src/deny-list/ip-deny-list.ts\nvar ip_deny_list_exports = {};\n__export(ip_deny_list_exports, {\n  ThresholdError: () => ThresholdError,\n  disableIpDenyList: () => disableIpDenyList,\n  updateIpDenyList: () => updateIpDenyList\n});\n\n// src/deny-list/time.ts\nvar MILLISECONDS_IN_HOUR = 60 * 60 * 1e3;\nvar MILLISECONDS_IN_DAY = 24 * MILLISECONDS_IN_HOUR;\nvar MILLISECONDS_TO_2AM = 2 * MILLISECONDS_IN_HOUR;\nvar getIpListTTL = (time) => {\n  const now = time || Date.now();\n  const timeSinceLast2AM = (now - MILLISECONDS_TO_2AM) % MILLISECONDS_IN_DAY;\n  return MILLISECONDS_IN_DAY - timeSinceLast2AM;\n};\n\n// src/deny-list/ip-deny-list.ts\nvar baseUrl = \"https://raw.githubusercontent.com/stamparm/ipsum/master/levels\";\nvar ThresholdError = class extends Error {\n  constructor(threshold) {\n    super(`Allowed threshold values are from 1 to 8, 1 and 8 included. Received: ${threshold}`);\n    this.name = \"ThresholdError\";\n  }\n};\nvar getIpDenyList = async (threshold) => {\n  if (typeof threshold !== \"number\" || threshold < 1 || threshold > 8) {\n    throw new ThresholdError(threshold);\n  }\n  try {\n    const response = await fetch(`${baseUrl}/${threshold}.txt`);\n    if (!response.ok) {\n      throw new Error(`Error fetching data: ${response.statusText}`);\n    }\n    const data = await response.text();\n    const lines = data.split(\"\\n\");\n    return lines.filter((value) => value.length > 0);\n  } catch (error) {\n    throw new Error(`Failed to fetch ip deny list: ${error}`);\n  }\n};\nvar updateIpDenyList = async (redis, prefix, threshold, ttl) => {\n  const allIps = await getIpDenyList(threshold);\n  const allDenyLists = [prefix, DenyListExtension, \"all\"].join(\":\");\n  const ipDenyList = [prefix, DenyListExtension, IpDenyListKey].join(\":\");\n  const statusKey = [prefix, IpDenyListStatusKey].join(\":\");\n  const transaction = redis.multi();\n  transaction.sdiffstore(allDenyLists, allDenyLists, ipDenyList);\n  transaction.del(ipDenyList);\n  transaction.sadd(ipDenyList, ...allIps);\n  transaction.sdiffstore(ipDenyList, ipDenyList, allDenyLists);\n  transaction.sunionstore(allDenyLists, allDenyLists, ipDenyList);\n  transaction.set(statusKey, \"valid\", { px: ttl ?? getIpListTTL() });\n  return await transaction.exec();\n};\nvar disableIpDenyList = async (redis, prefix) => {\n  const allDenyListsKey = [prefix, DenyListExtension, \"all\"].join(\":\");\n  const ipDenyListKey = [prefix, DenyListExtension, IpDenyListKey].join(\":\");\n  const statusKey = [prefix, IpDenyListStatusKey].join(\":\");\n  const transaction = redis.multi();\n  transaction.sdiffstore(allDenyListsKey, allDenyListsKey, ipDenyListKey);\n  transaction.del(ipDenyListKey);\n  transaction.set(statusKey, \"disabled\");\n  return await transaction.exec();\n};\n\n// src/deny-list/deny-list.ts\nvar denyListCache = new Cache(/* @__PURE__ */ new Map());\nvar checkDenyListCache = (members) => {\n  return members.find(\n    (member) => denyListCache.isBlocked(member).blocked\n  );\n};\nvar blockMember = (member) => {\n  if (denyListCache.size() > 1e3)\n    denyListCache.empty();\n  denyListCache.blockUntil(member, Date.now() + 6e4);\n};\nvar checkDenyList = async (redis, prefix, members) => {\n  const [deniedValues, ipDenyListStatus] = await redis.eval(\n    checkDenyListScript,\n    [\n      [prefix, DenyListExtension, \"all\"].join(\":\"),\n      [prefix, IpDenyListStatusKey].join(\":\")\n    ],\n    members\n  );\n  let deniedValue = void 0;\n  deniedValues.map((memberDenied, index) => {\n    if (memberDenied) {\n      blockMember(members[index]);\n      deniedValue = members[index];\n    }\n  });\n  return {\n    deniedValue,\n    invalidIpDenyList: ipDenyListStatus === -2\n  };\n};\nvar resolveLimitPayload = (redis, prefix, [ratelimitResponse, denyListResponse], threshold) => {\n  if (denyListResponse.deniedValue) {\n    ratelimitResponse.success = false;\n    ratelimitResponse.remaining = 0;\n    ratelimitResponse.reason = \"denyList\";\n    ratelimitResponse.deniedValue = denyListResponse.deniedValue;\n  }\n  if (denyListResponse.invalidIpDenyList) {\n    const updatePromise = updateIpDenyList(redis, prefix, threshold);\n    ratelimitResponse.pending = Promise.all([\n      ratelimitResponse.pending,\n      updatePromise\n    ]);\n  }\n  return ratelimitResponse;\n};\nvar defaultDeniedResponse = (deniedValue) => {\n  return {\n    success: false,\n    limit: 0,\n    remaining: 0,\n    reset: 0,\n    pending: Promise.resolve(),\n    reason: \"denyList\",\n    deniedValue\n  };\n};\n\n// src/ratelimit.ts\nvar Ratelimit = class {\n  limiter;\n  ctx;\n  prefix;\n  timeout;\n  primaryRedis;\n  analytics;\n  enableProtection;\n  denyListThreshold;\n  constructor(config) {\n    this.ctx = config.ctx;\n    this.limiter = config.limiter;\n    this.timeout = config.timeout ?? 5e3;\n    this.prefix = config.prefix ?? \"@upstash/ratelimit\";\n    this.enableProtection = config.enableProtection ?? false;\n    this.denyListThreshold = config.denyListThreshold ?? 6;\n    this.primaryRedis = \"redis\" in this.ctx ? this.ctx.redis : this.ctx.regionContexts[0].redis;\n    this.analytics = config.analytics ? new Analytics({\n      redis: this.primaryRedis,\n      prefix: this.prefix\n    }) : void 0;\n    if (config.ephemeralCache instanceof Map) {\n      this.ctx.cache = new Cache(config.ephemeralCache);\n    } else if (typeof config.ephemeralCache === \"undefined\") {\n      this.ctx.cache = new Cache(/* @__PURE__ */ new Map());\n    }\n  }\n  /**\n   * Determine if a request should pass or be rejected based on the identifier and previously chosen ratelimit.\n   *\n   * Use this if you want to reject all requests that you can not handle right now.\n   *\n   * @example\n   * ```ts\n   *  const ratelimit = new Ratelimit({\n   *    redis: Redis.fromEnv(),\n   *    limiter: Ratelimit.slidingWindow(10, \"10 s\")\n   *  })\n   *\n   *  const { success } = await ratelimit.limit(id)\n   *  if (!success){\n   *    return \"Nope\"\n   *  }\n   *  return \"Yes\"\n   * ```\n   *\n   * @param req.rate - The rate at which tokens will be added or consumed from the token bucket. A higher rate allows for more requests to be processed. Defaults to 1 token per interval if not specified.\n   *\n   * Usage with `req.rate`\n   * @example\n   * ```ts\n   *  const ratelimit = new Ratelimit({\n   *    redis: Redis.fromEnv(),\n   *    limiter: Ratelimit.slidingWindow(100, \"10 s\")\n   *  })\n   *\n   *  const { success } = await ratelimit.limit(id, {rate: 10})\n   *  if (!success){\n   *    return \"Nope\"\n   *  }\n   *  return \"Yes\"\n   * ```\n   */\n  limit = async (identifier, req) => {\n    let timeoutId = null;\n    try {\n      const response = this.getRatelimitResponse(identifier, req);\n      const { responseArray, newTimeoutId } = this.applyTimeout(response);\n      timeoutId = newTimeoutId;\n      const timedResponse = await Promise.race(responseArray);\n      const finalResponse = this.submitAnalytics(timedResponse, identifier, req);\n      return finalResponse;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  };\n  /**\n   * Block until the request may pass or timeout is reached.\n   *\n   * This method returns a promise that resolves as soon as the request may be processed\n   * or after the timeout has been reached.\n   *\n   * Use this if you want to delay the request until it is ready to get processed.\n   *\n   * @example\n   * ```ts\n   *  const ratelimit = new Ratelimit({\n   *    redis: Redis.fromEnv(),\n   *    limiter: Ratelimit.slidingWindow(10, \"10 s\")\n   *  })\n   *\n   *  const { success } = await ratelimit.blockUntilReady(id, 60_000)\n   *  if (!success){\n   *    return \"Nope\"\n   *  }\n   *  return \"Yes\"\n   * ```\n   */\n  blockUntilReady = async (identifier, timeout) => {\n    if (timeout <= 0) {\n      throw new Error(\"timeout must be positive\");\n    }\n    let res;\n    const deadline = Date.now() + timeout;\n    while (true) {\n      res = await this.limit(identifier);\n      if (res.success) {\n        break;\n      }\n      if (res.reset === 0) {\n        throw new Error(\"This should not happen\");\n      }\n      const wait = Math.min(res.reset, deadline) - Date.now();\n      await new Promise((r) => setTimeout(r, wait));\n      if (Date.now() > deadline) {\n        break;\n      }\n    }\n    return res;\n  };\n  resetUsedTokens = async (identifier) => {\n    const pattern = [this.prefix, identifier].join(\":\");\n    await this.limiter().resetTokens(this.ctx, pattern);\n  };\n  getRemaining = async (identifier) => {\n    const pattern = [this.prefix, identifier].join(\":\");\n    return await this.limiter().getRemaining(this.ctx, pattern);\n  };\n  /**\n   * Checks if the identifier or the values in req are in the deny list cache.\n   * If so, returns the default denied response.\n   * \n   * Otherwise, calls redis to check the rate limit and deny list. Returns after\n   * resolving the result. Resolving is overriding the rate limit result if\n   * the some value is in deny list.\n   * \n   * @param identifier identifier to block\n   * @param req options with ip, user agent, country, rate and geo info\n   * @returns rate limit response\n   */\n  getRatelimitResponse = async (identifier, req) => {\n    const key = this.getKey(identifier);\n    const definedMembers = this.getDefinedMembers(identifier, req);\n    const deniedValue = checkDenyListCache(definedMembers);\n    let result;\n    if (deniedValue) {\n      result = [defaultDeniedResponse(deniedValue), { deniedValue, invalidIpDenyList: false }];\n    } else {\n      result = await Promise.all([\n        this.limiter().limit(this.ctx, key, req?.rate),\n        this.enableProtection ? checkDenyList(this.primaryRedis, this.prefix, definedMembers) : { deniedValue: void 0, invalidIpDenyList: false }\n      ]);\n    }\n    return resolveLimitPayload(this.primaryRedis, this.prefix, result, this.denyListThreshold);\n  };\n  /**\n   * Creates an array with the original response promise and a timeout promise\n   * if this.timeout > 0.\n   * \n   * @param response Ratelimit response promise\n   * @returns array with the response and timeout promise. also includes the timeout id\n   */\n  applyTimeout = (response) => {\n    let newTimeoutId = null;\n    const responseArray = [response];\n    if (this.timeout > 0) {\n      const timeoutResponse = new Promise((resolve) => {\n        newTimeoutId = setTimeout(() => {\n          resolve({\n            success: true,\n            limit: 0,\n            remaining: 0,\n            reset: 0,\n            pending: Promise.resolve(),\n            reason: \"timeout\"\n          });\n        }, this.timeout);\n      });\n      responseArray.push(timeoutResponse);\n    }\n    return {\n      responseArray,\n      newTimeoutId\n    };\n  };\n  /**\n   * submits analytics if this.analytics is set\n   * \n   * @param ratelimitResponse final rate limit response\n   * @param identifier identifier to submit\n   * @param req limit options\n   * @returns rate limit response after updating the .pending field\n   */\n  submitAnalytics = (ratelimitResponse, identifier, req) => {\n    if (this.analytics) {\n      try {\n        const geo = req ? this.analytics.extractGeo(req) : void 0;\n        const analyticsP = this.analytics.record({\n          identifier: ratelimitResponse.reason === \"denyList\" ? ratelimitResponse.deniedValue : identifier,\n          time: Date.now(),\n          success: ratelimitResponse.reason === \"denyList\" ? \"denied\" : ratelimitResponse.success,\n          ...geo\n        }).catch((err) => {\n          let errorMessage = \"Failed to record analytics\";\n          if (`${err}`.includes(\"WRONGTYPE\")) {\n            errorMessage = `\n    Failed to record analytics. See the information below:\n\n    This can occur when you uprade to Ratelimit version 1.1.2\n    or later from an earlier version.\n\n    This occurs simply because the way we store analytics data\n    has changed. To avoid getting this error, disable analytics\n    for *an hour*, then simply enable it back.\n\n    `;\n          }\n          console.warn(errorMessage, err);\n        });\n        ratelimitResponse.pending = Promise.all([ratelimitResponse.pending, analyticsP]);\n      } catch (err) {\n        console.warn(\"Failed to record analytics\", err);\n      }\n      ;\n    }\n    ;\n    return ratelimitResponse;\n  };\n  getKey = (identifier) => {\n    return [this.prefix, identifier].join(\":\");\n  };\n  /**\n   * returns a list of defined values from\n   * [identifier, req.ip, req.userAgent, req.country]\n   * \n   * @param identifier identifier\n   * @param req limit options\n   * @returns list of defined values\n   */\n  getDefinedMembers = (identifier, req) => {\n    const members = [identifier, req?.ip, req?.userAgent, req?.country];\n    return members.filter((item) => Boolean(item));\n  };\n};\n\n// src/multi.ts\nfunction randomId() {\n  let result = \"\";\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n  for (let i = 0; i < 16; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\nvar MultiRegionRatelimit = class extends Ratelimit {\n  /**\n   * Create a new Ratelimit instance by providing a `@upstash/redis` instance and the algorithn of your choice.\n   */\n  constructor(config) {\n    super({\n      prefix: config.prefix,\n      limiter: config.limiter,\n      timeout: config.timeout,\n      analytics: config.analytics,\n      ctx: {\n        regionContexts: config.redis.map((redis) => ({\n          redis,\n          scriptHashes: {},\n          cacheScripts: config.cacheScripts ?? true\n        })),\n        cache: config.ephemeralCache ? new Cache(config.ephemeralCache) : void 0\n      }\n    });\n  }\n  /**\n   * Each request inside a fixed time increases a counter.\n   * Once the counter reaches the maximum allowed number, all further requests are\n   * rejected.\n   *\n   * **Pro:**\n   *\n   * - Newer requests are not starved by old ones.\n   * - Low storage cost.\n   *\n   * **Con:**\n   *\n   * A burst of requests near the boundary of a window can result in a very\n   * high request rate because two windows will be filled with requests quickly.\n   *\n   * @param tokens - How many requests a user can make in each time window.\n   * @param window - A fixed timeframe\n   */\n  static fixedWindow(tokens, window) {\n    const windowDuration = ms(window);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        if (ctx.cache) {\n          const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);\n          if (blocked) {\n            return {\n              success: false,\n              limit: tokens,\n              remaining: 0,\n              reset: reset2,\n              pending: Promise.resolve(),\n              reason: \"cacheBlock\"\n            };\n          }\n        }\n        const requestId = randomId();\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const dbs = ctx.regionContexts.map((regionContext) => ({\n          redis: regionContext.redis,\n          request: safeEval(\n            regionContext,\n            fixedWindowLimitScript,\n            \"limitHash\",\n            [key],\n            [requestId, windowDuration, incrementBy]\n          )\n        }));\n        const firstResponse = await Promise.any(dbs.map((s) => s.request));\n        const usedTokens = firstResponse.reduce((accTokens, usedToken, index) => {\n          let parsedToken = 0;\n          if (index % 2) {\n            parsedToken = Number.parseInt(usedToken);\n          }\n          return accTokens + parsedToken;\n        }, 0);\n        const remaining = tokens - usedTokens;\n        async function sync() {\n          const individualIDs = await Promise.all(dbs.map((s) => s.request));\n          const allIDs = Array.from(\n            new Set(\n              individualIDs.flatMap((_) => _).reduce((acc, curr, index) => {\n                if (index % 2 === 0) {\n                  acc.push(curr);\n                }\n                return acc;\n              }, [])\n            ).values()\n          );\n          for (const db of dbs) {\n            const usedDbTokens = (await db.request).reduce(\n              (accTokens, usedToken, index) => {\n                let parsedToken = 0;\n                if (index % 2) {\n                  parsedToken = Number.parseInt(usedToken);\n                }\n                return accTokens + parsedToken;\n              },\n              0\n            );\n            const dbIds = (await db.request).reduce((ids, currentId, index) => {\n              if (index % 2 === 0) {\n                ids.push(currentId);\n              }\n              return ids;\n            }, []);\n            if (usedDbTokens >= tokens) {\n              continue;\n            }\n            const diff = allIDs.filter((id) => !dbIds.includes(id));\n            if (diff.length === 0) {\n              continue;\n            }\n            for (const requestId2 of diff) {\n              await db.redis.hset(key, { [requestId2]: incrementBy });\n            }\n          }\n        }\n        const success = remaining > 0;\n        const reset = (bucket + 1) * windowDuration;\n        if (ctx.cache && !success) {\n          ctx.cache.blockUntil(identifier, reset);\n        }\n        return {\n          success,\n          limit: tokens,\n          remaining,\n          reset,\n          pending: sync()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        const dbs = ctx.regionContexts.map((regionContext) => ({\n          redis: regionContext.redis,\n          request: safeEval(\n            regionContext,\n            fixedWindowRemainingTokensScript,\n            \"getRemainingHash\",\n            [key],\n            [null]\n          )\n        }));\n        const firstResponse = await Promise.any(dbs.map((s) => s.request));\n        const usedTokens = firstResponse.reduce((accTokens, usedToken, index) => {\n          let parsedToken = 0;\n          if (index % 2) {\n            parsedToken = Number.parseInt(usedToken);\n          }\n          return accTokens + parsedToken;\n        }, 0);\n        return Math.max(0, tokens - usedTokens);\n      },\n      async resetTokens(ctx, identifier) {\n        const pattern = [identifier, \"*\"].join(\":\");\n        if (ctx.cache) {\n          ctx.cache.pop(identifier);\n        }\n        await Promise.all(ctx.regionContexts.map((regionContext) => {\n          safeEval(\n            regionContext,\n            resetScript,\n            \"resetHash\",\n            [pattern],\n            [null]\n          );\n        }));\n      }\n    });\n  }\n  /**\n   * Combined approach of `slidingLogs` and `fixedWindow` with lower storage\n   * costs than `slidingLogs` and improved boundary behavior by calculating a\n   * weighted score between two windows.\n   *\n   * **Pro:**\n   *\n   * Good performance allows this to scale to very high loads.\n   *\n   * **Con:**\n   *\n   * Nothing major.\n   *\n   * @param tokens - How many requests a user can make in each time window.\n   * @param window - The duration in which the user can max X requests.\n   */\n  static slidingWindow(tokens, window) {\n    const windowSize = ms(window);\n    const windowDuration = ms(window);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        if (ctx.cache) {\n          const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);\n          if (blocked) {\n            return {\n              success: false,\n              limit: tokens,\n              remaining: 0,\n              reset: reset2,\n              pending: Promise.resolve(),\n              reason: \"cacheBlock\"\n            };\n          }\n        }\n        const requestId = randomId();\n        const now = Date.now();\n        const currentWindow = Math.floor(now / windowSize);\n        const currentKey = [identifier, currentWindow].join(\":\");\n        const previousWindow = currentWindow - 1;\n        const previousKey = [identifier, previousWindow].join(\":\");\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const dbs = ctx.regionContexts.map((regionContext) => ({\n          redis: regionContext.redis,\n          request: safeEval(\n            regionContext,\n            slidingWindowLimitScript,\n            \"limitHash\",\n            [currentKey, previousKey],\n            [tokens, now, windowDuration, requestId, incrementBy]\n            // lua seems to return `1` for true and `null` for false\n          )\n        }));\n        const percentageInCurrent = now % windowDuration / windowDuration;\n        const [current, previous, success] = await Promise.any(dbs.map((s) => s.request));\n        if (success) {\n          current.push(requestId, incrementBy.toString());\n        }\n        const previousUsedTokens = previous.reduce((accTokens, usedToken, index) => {\n          let parsedToken = 0;\n          if (index % 2) {\n            parsedToken = Number.parseInt(usedToken);\n          }\n          return accTokens + parsedToken;\n        }, 0);\n        const currentUsedTokens = current.reduce((accTokens, usedToken, index) => {\n          let parsedToken = 0;\n          if (index % 2) {\n            parsedToken = Number.parseInt(usedToken);\n          }\n          return accTokens + parsedToken;\n        }, 0);\n        const previousPartialUsed = Math.ceil(previousUsedTokens * (1 - percentageInCurrent));\n        const usedTokens = previousPartialUsed + currentUsedTokens;\n        const remaining = tokens - usedTokens;\n        async function sync() {\n          const res = await Promise.all(dbs.map((s) => s.request));\n          const allCurrentIds = Array.from(\n            new Set(\n              res.flatMap(([current2]) => current2).reduce((acc, curr, index) => {\n                if (index % 2 === 0) {\n                  acc.push(curr);\n                }\n                return acc;\n              }, [])\n            ).values()\n          );\n          for (const db of dbs) {\n            const [current2, _previous, _success] = await db.request;\n            const dbIds = current2.reduce((ids, currentId, index) => {\n              if (index % 2 === 0) {\n                ids.push(currentId);\n              }\n              return ids;\n            }, []);\n            const usedDbTokens = current2.reduce((accTokens, usedToken, index) => {\n              let parsedToken = 0;\n              if (index % 2) {\n                parsedToken = Number.parseInt(usedToken);\n              }\n              return accTokens + parsedToken;\n            }, 0);\n            if (usedDbTokens >= tokens) {\n              continue;\n            }\n            const diff = allCurrentIds.filter((id) => !dbIds.includes(id));\n            if (diff.length === 0) {\n              continue;\n            }\n            for (const requestId2 of diff) {\n              await db.redis.hset(currentKey, { [requestId2]: incrementBy });\n            }\n          }\n        }\n        const reset = (currentWindow + 1) * windowDuration;\n        if (ctx.cache && !success) {\n          ctx.cache.blockUntil(identifier, reset);\n        }\n        return {\n          success: Boolean(success),\n          limit: tokens,\n          remaining: Math.max(0, remaining),\n          reset,\n          pending: sync()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        const now = Date.now();\n        const currentWindow = Math.floor(now / windowSize);\n        const currentKey = [identifier, currentWindow].join(\":\");\n        const previousWindow = currentWindow - 1;\n        const previousKey = [identifier, previousWindow].join(\":\");\n        const dbs = ctx.regionContexts.map((regionContext) => ({\n          redis: regionContext.redis,\n          request: safeEval(\n            regionContext,\n            slidingWindowRemainingTokensScript,\n            \"getRemainingHash\",\n            [currentKey, previousKey],\n            [now, windowSize]\n            // lua seems to return `1` for true and `null` for false\n          )\n        }));\n        const usedTokens = await Promise.any(dbs.map((s) => s.request));\n        return Math.max(0, tokens - usedTokens);\n      },\n      async resetTokens(ctx, identifier) {\n        const pattern = [identifier, \"*\"].join(\":\");\n        if (ctx.cache) {\n          ctx.cache.pop(identifier);\n        }\n        await Promise.all(ctx.regionContexts.map((regionContext) => {\n          safeEval(\n            regionContext,\n            resetScript,\n            \"resetHash\",\n            [pattern],\n            [null]\n          );\n        }));\n      }\n    });\n  }\n};\n\n// src/lua-scripts/single.ts\nvar fixedWindowLimitScript2 = `\n  local key           = KEYS[1]\n  local window        = ARGV[1]\n  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1\n\n  local r = redis.call(\"INCRBY\", key, incrementBy)\n  if r == tonumber(incrementBy) then\n  -- The first time this key is set, the value will be equal to incrementBy.\n  -- So we only need the expire command once\n  redis.call(\"PEXPIRE\", key, window)\n  end\n\n  return r\n`;\nvar fixedWindowRemainingTokensScript2 = `\n      local key = KEYS[1]\n      local tokens = 0\n\n      local value = redis.call('GET', key)\n      if value then\n          tokens = value\n      end\n      return tokens\n    `;\nvar slidingWindowLimitScript2 = `\n  local currentKey  = KEYS[1]           -- identifier including prefixes\n  local previousKey = KEYS[2]           -- key of the previous bucket\n  local tokens      = tonumber(ARGV[1]) -- tokens per window\n  local now         = ARGV[2]           -- current timestamp in milliseconds\n  local window      = ARGV[3]           -- interval in milliseconds\n  local incrementBy = ARGV[4]           -- increment rate per request at a given value, default is 1\n\n  local requestsInCurrentWindow = redis.call(\"GET\", currentKey)\n  if requestsInCurrentWindow == false then\n    requestsInCurrentWindow = 0\n  end\n\n  local requestsInPreviousWindow = redis.call(\"GET\", previousKey)\n  if requestsInPreviousWindow == false then\n    requestsInPreviousWindow = 0\n  end\n  local percentageInCurrent = ( now % window ) / window\n  -- weighted requests to consider from the previous window\n  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)\n  if requestsInPreviousWindow + requestsInCurrentWindow >= tokens then\n    return -1\n  end\n\n  local newValue = redis.call(\"INCRBY\", currentKey, incrementBy)\n  if newValue == tonumber(incrementBy) then\n    -- The first time this key is set, the value will be equal to incrementBy.\n    -- So we only need the expire command once\n    redis.call(\"PEXPIRE\", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second\n  end\n  return tokens - ( newValue + requestsInPreviousWindow )\n`;\nvar slidingWindowRemainingTokensScript2 = `\n  local currentKey  = KEYS[1]           -- identifier including prefixes\n  local previousKey = KEYS[2]           -- key of the previous bucket\n  local now         = ARGV[1]           -- current timestamp in milliseconds\n  local window      = ARGV[2]           -- interval in milliseconds\n\n  local requestsInCurrentWindow = redis.call(\"GET\", currentKey)\n  if requestsInCurrentWindow == false then\n    requestsInCurrentWindow = 0\n  end\n\n  local requestsInPreviousWindow = redis.call(\"GET\", previousKey)\n  if requestsInPreviousWindow == false then\n    requestsInPreviousWindow = 0\n  end\n\n  local percentageInCurrent = ( now % window ) / window\n  -- weighted requests to consider from the previous window\n  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)\n\n  return requestsInPreviousWindow + requestsInCurrentWindow\n`;\nvar tokenBucketLimitScript = `\n  local key         = KEYS[1]           -- identifier including prefixes\n  local maxTokens   = tonumber(ARGV[1]) -- maximum number of tokens\n  local interval    = tonumber(ARGV[2]) -- size of the window in milliseconds\n  local refillRate  = tonumber(ARGV[3]) -- how many tokens are refilled after each interval\n  local now         = tonumber(ARGV[4]) -- current timestamp in milliseconds\n  local incrementBy = tonumber(ARGV[5]) -- how many tokens to consume, default is 1\n        \n  local bucket = redis.call(\"HMGET\", key, \"refilledAt\", \"tokens\")\n        \n  local refilledAt\n  local tokens\n\n  if bucket[1] == false then\n    refilledAt = now\n    tokens = maxTokens\n  else\n    refilledAt = tonumber(bucket[1])\n    tokens = tonumber(bucket[2])\n  end\n        \n  if now >= refilledAt + interval then\n    local numRefills = math.floor((now - refilledAt) / interval)\n    tokens = math.min(maxTokens, tokens + numRefills * refillRate)\n\n    refilledAt = refilledAt + numRefills * interval\n  end\n\n  if tokens == 0 then\n    return {-1, refilledAt + interval}\n  end\n\n  local remaining = tokens - incrementBy\n  local expireAt = math.ceil(((maxTokens - remaining) / refillRate)) * interval\n        \n  redis.call(\"HSET\", key, \"refilledAt\", refilledAt, \"tokens\", remaining)\n  redis.call(\"PEXPIRE\", key, expireAt)\n  return {remaining, refilledAt + interval}\n`;\nvar tokenBucketRemainingTokensScript = `\n  local key         = KEYS[1]\n  local maxTokens   = tonumber(ARGV[1])\n        \n  local bucket = redis.call(\"HMGET\", key, \"tokens\")\n\n  if bucket[1] == false then\n    return maxTokens\n  end\n        \n  return tonumber(bucket[1])\n`;\nvar cachedFixedWindowLimitScript = `\n  local key     = KEYS[1]\n  local window  = ARGV[1]\n  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1\n\n  local r = redis.call(\"INCRBY\", key, incrementBy)\n  if r == incrementBy then\n  -- The first time this key is set, the value will be equal to incrementBy.\n  -- So we only need the expire command once\n  redis.call(\"PEXPIRE\", key, window)\n  end\n      \n  return r\n`;\nvar cachedFixedWindowRemainingTokenScript = `\n  local key = KEYS[1]\n  local tokens = 0\n\n  local value = redis.call('GET', key)\n  if value then\n      tokens = value\n  end\n  return tokens\n`;\n\n// src/single.ts\nvar RegionRatelimit = class extends Ratelimit {\n  /**\n   * Create a new Ratelimit instance by providing a `@upstash/redis` instance and the algorithm of your choice.\n   */\n  constructor(config) {\n    super({\n      prefix: config.prefix,\n      limiter: config.limiter,\n      timeout: config.timeout,\n      analytics: config.analytics,\n      ctx: {\n        redis: config.redis,\n        scriptHashes: {},\n        cacheScripts: config.cacheScripts ?? true\n      },\n      ephemeralCache: config.ephemeralCache,\n      enableProtection: config.enableProtection,\n      denyListThreshold: config.denyListThreshold\n    });\n  }\n  /**\n   * Each request inside a fixed time increases a counter.\n   * Once the counter reaches the maximum allowed number, all further requests are\n   * rejected.\n   *\n   * **Pro:**\n   *\n   * - Newer requests are not starved by old ones.\n   * - Low storage cost.\n   *\n   * **Con:**\n   *\n   * A burst of requests near the boundary of a window can result in a very\n   * high request rate because two windows will be filled with requests quickly.\n   *\n   * @param tokens - How many requests a user can make in each time window.\n   * @param window - A fixed timeframe\n   */\n  static fixedWindow(tokens, window) {\n    const windowDuration = ms(window);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        if (ctx.cache) {\n          const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);\n          if (blocked) {\n            return {\n              success: false,\n              limit: tokens,\n              remaining: 0,\n              reset: reset2,\n              pending: Promise.resolve(),\n              reason: \"cacheBlock\"\n            };\n          }\n        }\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const usedTokensAfterUpdate = await safeEval(\n          ctx,\n          fixedWindowLimitScript2,\n          \"limitHash\",\n          [key],\n          [windowDuration, incrementBy]\n        );\n        const success = usedTokensAfterUpdate <= tokens;\n        const remainingTokens = Math.max(0, tokens - usedTokensAfterUpdate);\n        const reset = (bucket + 1) * windowDuration;\n        if (ctx.cache && !success) {\n          ctx.cache.blockUntil(identifier, reset);\n        }\n        return {\n          success,\n          limit: tokens,\n          remaining: remainingTokens,\n          reset,\n          pending: Promise.resolve()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        const usedTokens = await safeEval(\n          ctx,\n          fixedWindowRemainingTokensScript2,\n          \"getRemainingHash\",\n          [key],\n          [null]\n        );\n        return Math.max(0, tokens - usedTokens);\n      },\n      async resetTokens(ctx, identifier) {\n        const pattern = [identifier, \"*\"].join(\":\");\n        if (ctx.cache) {\n          ctx.cache.pop(identifier);\n        }\n        await safeEval(\n          ctx,\n          resetScript,\n          \"resetHash\",\n          [pattern],\n          [null]\n        );\n      }\n    });\n  }\n  /**\n   * Combined approach of `slidingLogs` and `fixedWindow` with lower storage\n   * costs than `slidingLogs` and improved boundary behavior by calculating a\n   * weighted score between two windows.\n   *\n   * **Pro:**\n   *\n   * Good performance allows this to scale to very high loads.\n   *\n   * **Con:**\n   *\n   * Nothing major.\n   *\n   * @param tokens - How many requests a user can make in each time window.\n   * @param window - The duration in which the user can max X requests.\n   */\n  static slidingWindow(tokens, window) {\n    const windowSize = ms(window);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        const now = Date.now();\n        const currentWindow = Math.floor(now / windowSize);\n        const currentKey = [identifier, currentWindow].join(\":\");\n        const previousWindow = currentWindow - 1;\n        const previousKey = [identifier, previousWindow].join(\":\");\n        if (ctx.cache) {\n          const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);\n          if (blocked) {\n            return {\n              success: false,\n              limit: tokens,\n              remaining: 0,\n              reset: reset2,\n              pending: Promise.resolve(),\n              reason: \"cacheBlock\"\n            };\n          }\n        }\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const remainingTokens = await safeEval(\n          ctx,\n          slidingWindowLimitScript2,\n          \"limitHash\",\n          [currentKey, previousKey],\n          [tokens, now, windowSize, incrementBy]\n        );\n        const success = remainingTokens >= 0;\n        const reset = (currentWindow + 1) * windowSize;\n        if (ctx.cache && !success) {\n          ctx.cache.blockUntil(identifier, reset);\n        }\n        return {\n          success,\n          limit: tokens,\n          remaining: Math.max(0, remainingTokens),\n          reset,\n          pending: Promise.resolve()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        const now = Date.now();\n        const currentWindow = Math.floor(now / windowSize);\n        const currentKey = [identifier, currentWindow].join(\":\");\n        const previousWindow = currentWindow - 1;\n        const previousKey = [identifier, previousWindow].join(\":\");\n        const usedTokens = await safeEval(\n          ctx,\n          slidingWindowRemainingTokensScript2,\n          \"getRemainingHash\",\n          [currentKey, previousKey],\n          [now, windowSize]\n        );\n        return Math.max(0, tokens - usedTokens);\n      },\n      async resetTokens(ctx, identifier) {\n        const pattern = [identifier, \"*\"].join(\":\");\n        if (ctx.cache) {\n          ctx.cache.pop(identifier);\n        }\n        await safeEval(\n          ctx,\n          resetScript,\n          \"resetHash\",\n          [pattern],\n          [null]\n        );\n      }\n    });\n  }\n  /**\n   * You have a bucket filled with `{maxTokens}` tokens that refills constantly\n   * at `{refillRate}` per `{interval}`.\n   * Every request will remove one token from the bucket and if there is no\n   * token to take, the request is rejected.\n   *\n   * **Pro:**\n   *\n   * - Bursts of requests are smoothed out and you can process them at a constant\n   * rate.\n   * - Allows to set a higher initial burst limit by setting `maxTokens` higher\n   * than `refillRate`\n   */\n  static tokenBucket(refillRate, interval, maxTokens) {\n    const intervalDuration = ms(interval);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        if (ctx.cache) {\n          const { blocked, reset: reset2 } = ctx.cache.isBlocked(identifier);\n          if (blocked) {\n            return {\n              success: false,\n              limit: maxTokens,\n              remaining: 0,\n              reset: reset2,\n              pending: Promise.resolve(),\n              reason: \"cacheBlock\"\n            };\n          }\n        }\n        const now = Date.now();\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const [remaining, reset] = await safeEval(\n          ctx,\n          tokenBucketLimitScript,\n          \"limitHash\",\n          [identifier],\n          [maxTokens, intervalDuration, refillRate, now, incrementBy]\n        );\n        const success = remaining >= 0;\n        if (ctx.cache && !success) {\n          ctx.cache.blockUntil(identifier, reset);\n        }\n        return {\n          success,\n          limit: maxTokens,\n          remaining,\n          reset,\n          pending: Promise.resolve()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        const remainingTokens = await safeEval(\n          ctx,\n          tokenBucketRemainingTokensScript,\n          \"getRemainingHash\",\n          [identifier],\n          [maxTokens]\n        );\n        return remainingTokens;\n      },\n      async resetTokens(ctx, identifier) {\n        const pattern = identifier;\n        if (ctx.cache) {\n          ctx.cache.pop(identifier);\n        }\n        await safeEval(\n          ctx,\n          resetScript,\n          \"resetHash\",\n          [pattern],\n          [null]\n        );\n      }\n    });\n  }\n  /**\n   * cachedFixedWindow first uses the local cache to decide if a request may pass and then updates\n   * it asynchronously.\n   * This is experimental and not yet recommended for production use.\n   *\n   * @experimental\n   *\n   * Each request inside a fixed time increases a counter.\n   * Once the counter reaches the maximum allowed number, all further requests are\n   * rejected.\n   *\n   * **Pro:**\n   *\n   * - Newer requests are not starved by old ones.\n   * - Low storage cost.\n   *\n   * **Con:**\n   *\n   * A burst of requests near the boundary of a window can result in a very\n   * high request rate because two windows will be filled with requests quickly.\n   *\n   * @param tokens - How many requests a user can make in each time window.\n   * @param window - A fixed timeframe\n   */\n  static cachedFixedWindow(tokens, window) {\n    const windowDuration = ms(window);\n    return () => ({\n      async limit(ctx, identifier, rate) {\n        if (!ctx.cache) {\n          throw new Error(\"This algorithm requires a cache\");\n        }\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        const reset = (bucket + 1) * windowDuration;\n        const incrementBy = rate ? Math.max(1, rate) : 1;\n        const hit = typeof ctx.cache.get(key) === \"number\";\n        if (hit) {\n          const cachedTokensAfterUpdate = ctx.cache.incr(key);\n          const success = cachedTokensAfterUpdate < tokens;\n          const pending = success ? safeEval(\n            ctx,\n            cachedFixedWindowLimitScript,\n            \"limitHash\",\n            [key],\n            [windowDuration, incrementBy]\n          ) : Promise.resolve();\n          return {\n            success,\n            limit: tokens,\n            remaining: tokens - cachedTokensAfterUpdate,\n            reset,\n            pending\n          };\n        }\n        const usedTokensAfterUpdate = await safeEval(\n          ctx,\n          cachedFixedWindowLimitScript,\n          \"limitHash\",\n          [key],\n          [windowDuration, incrementBy]\n        );\n        ctx.cache.set(key, usedTokensAfterUpdate);\n        const remaining = tokens - usedTokensAfterUpdate;\n        return {\n          success: remaining >= 0,\n          limit: tokens,\n          remaining,\n          reset,\n          pending: Promise.resolve()\n        };\n      },\n      async getRemaining(ctx, identifier) {\n        if (!ctx.cache) {\n          throw new Error(\"This algorithm requires a cache\");\n        }\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        const hit = typeof ctx.cache.get(key) === \"number\";\n        if (hit) {\n          const cachedUsedTokens = ctx.cache.get(key) ?? 0;\n          return Math.max(0, tokens - cachedUsedTokens);\n        }\n        const usedTokens = await safeEval(\n          ctx,\n          cachedFixedWindowRemainingTokenScript,\n          \"getRemainingHash\",\n          [key],\n          [null]\n        );\n        return Math.max(0, tokens - usedTokens);\n      },\n      async resetTokens(ctx, identifier) {\n        if (!ctx.cache) {\n          throw new Error(\"This algorithm requires a cache\");\n        }\n        const bucket = Math.floor(Date.now() / windowDuration);\n        const key = [identifier, bucket].join(\":\");\n        ctx.cache.pop(key);\n        const pattern = [identifier, \"*\"].join(\":\");\n        await safeEval(\n          ctx,\n          resetScript,\n          \"resetHash\",\n          [pattern],\n          [null]\n        );\n      }\n    });\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9yYXRlbGltaXQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLHNHQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0MsVUFBVSxXQUFXLFFBQVEsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FLTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGlja3VwX2xpbmVfZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0B1cHN0YXNoL3JhdGVsaW1pdC9kaXN0L2luZGV4LmpzP2Q4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgQW5hbHl0aWNzOiAoKSA9PiBBbmFseXRpY3MsXG4gIElwRGVueUxpc3Q6ICgpID0+IGlwX2RlbnlfbGlzdF9leHBvcnRzLFxuICBNdWx0aVJlZ2lvblJhdGVsaW1pdDogKCkgPT4gTXVsdGlSZWdpb25SYXRlbGltaXQsXG4gIFJhdGVsaW1pdDogKCkgPT4gUmVnaW9uUmF0ZWxpbWl0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2FuYWx5dGljcy50c1xudmFyIGltcG9ydF9jb3JlX2FuYWx5dGljcyA9IHJlcXVpcmUoXCJAdXBzdGFzaC9jb3JlLWFuYWx5dGljc1wiKTtcbnZhciBBbmFseXRpY3MgPSBjbGFzcyB7XG4gIGFuYWx5dGljcztcbiAgdGFibGUgPSBcImV2ZW50c1wiO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmFuYWx5dGljcyA9IG5ldyBpbXBvcnRfY29yZV9hbmFseXRpY3MuQW5hbHl0aWNzKHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igd2UgbmVlZCB0byBmaXggdGhlIHR5cGVzIGluIGNvcmUtYW5hbHl0aWNzLCBpdCBzaG91bGQgb25seSByZXF1aXJlIHRoZSBtZXRob2RzIGl0IG5lZWRzLCBub3QgdGhlIHdob2xlIHNka1xuICAgICAgcmVkaXM6IGNvbmZpZy5yZWRpcyxcbiAgICAgIHdpbmRvdzogXCIxaFwiLFxuICAgICAgcHJlZml4OiBjb25maWcucHJlZml4ID8/IFwiQHVwc3Rhc2gvcmF0ZWxpbWl0XCIsXG4gICAgICByZXRlbnRpb246IFwiOTBkXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ5IHRvIGV4dHJhY3QgdGhlIGdlbyBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZXF1ZXN0XG4gICAqXG4gICAqIFRoaXMgaGFuZGxlcyBWZXJjZWwncyBgcmVxLmdlb2AgYW5kICBhbmQgQ2xvdWRmbGFyZSdzIGByZXF1ZXN0LmNmYCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSByZXFcbiAgICogQHJldHVybnNcbiAgICovXG4gIGV4dHJhY3RHZW8ocmVxKSB7XG4gICAgaWYgKHR5cGVvZiByZXEuZ2VvICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gcmVxLmdlbztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXEuY2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiByZXEuY2Y7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuICBhc3luYyByZWNvcmQoZXZlbnQpIHtcbiAgICBhd2FpdCB0aGlzLmFuYWx5dGljcy5pbmdlc3QodGhpcy50YWJsZSwgZXZlbnQpO1xuICB9XG4gIGFzeW5jIHNlcmllcyhmaWx0ZXIsIGN1dG9mZikge1xuICAgIGNvbnN0IHRpbWVzdGFtcENvdW50ID0gTWF0aC5taW4oXG4gICAgICAodGhpcy5hbmFseXRpY3MuZ2V0QnVja2V0KERhdGUubm93KCkpIC0gdGhpcy5hbmFseXRpY3MuZ2V0QnVja2V0KGN1dG9mZikpIC8gKDYwICogNjAgKiAxZTMpLFxuICAgICAgMjU2XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuYWdncmVnYXRlQnVja2V0c1dpdGhQaXBlbGluZSh0aGlzLnRhYmxlLCBmaWx0ZXIsIHRpbWVzdGFtcENvdW50KTtcbiAgfVxuICBhc3luYyBnZXRVc2FnZShjdXRvZmYgPSAwKSB7XG4gICAgY29uc3QgdGltZXN0YW1wQ291bnQgPSBNYXRoLm1pbihcbiAgICAgICh0aGlzLmFuYWx5dGljcy5nZXRCdWNrZXQoRGF0ZS5ub3coKSkgLSB0aGlzLmFuYWx5dGljcy5nZXRCdWNrZXQoY3V0b2ZmKSkgLyAoNjAgKiA2MCAqIDFlMyksXG4gICAgICAyNTZcbiAgICApO1xuICAgIGNvbnN0IHJlY29yZHMgPSBhd2FpdCB0aGlzLmFuYWx5dGljcy5nZXRBbGxvd2VkQmxvY2tlZCh0aGlzLnRhYmxlLCB0aW1lc3RhbXBDb3VudCk7XG4gICAgcmV0dXJuIHJlY29yZHM7XG4gIH1cbiAgYXN5bmMgZ2V0VXNhZ2VPdmVyVGltZSh0aW1lc3RhbXBDb3VudCwgZ3JvdXBieSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYW5hbHl0aWNzLmFnZ3JlZ2F0ZUJ1Y2tldHNXaXRoUGlwZWxpbmUodGhpcy50YWJsZSwgZ3JvdXBieSwgdGltZXN0YW1wQ291bnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0TW9zdEFsbG93ZWRCbG9ja2VkKHRpbWVzdGFtcENvdW50LCBnZXRUb3ApIHtcbiAgICBnZXRUb3AgPSBnZXRUb3AgPz8gNTtcbiAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuZ2V0TW9zdEFsbG93ZWRCbG9ja2VkKHRoaXMudGFibGUsIHRpbWVzdGFtcENvdW50LCBnZXRUb3ApO1xuICB9XG59O1xuXG4vLyBzcmMvY2FjaGUudHNcbnZhciBDYWNoZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFN0b3JlcyBpZGVudGlmaWVyIC0+IHJlc2V0IChpbiBtaWxsaXNlY29uZHMpXG4gICAqL1xuICBjYWNoZTtcbiAgY29uc3RydWN0b3IoY2FjaGUpIHtcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gIH1cbiAgaXNCbG9ja2VkKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICByZXR1cm4geyBibG9ja2VkOiBmYWxzZSwgcmVzZXQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzZXQgPSB0aGlzLmNhY2hlLmdldChpZGVudGlmaWVyKTtcbiAgICBpZiAocmVzZXQgPCBEYXRlLm5vdygpKSB7XG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB7IGJsb2NrZWQ6IGZhbHNlLCByZXNldDogMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBibG9ja2VkOiB0cnVlLCByZXNldCB9O1xuICB9XG4gIGJsb2NrVW50aWwoaWRlbnRpZmllciwgcmVzZXQpIHtcbiAgICB0aGlzLmNhY2hlLnNldChpZGVudGlmaWVyLCByZXNldCk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuICBpbmNyKGtleSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuY2FjaGUuZ2V0KGtleSkgPz8gMDtcbiAgICB2YWx1ZSArPSAxO1xuICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBwb3Aoa2V5KSB7XG4gICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgfVxuICBlbXB0eSgpIHtcbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5zaXplO1xuICB9XG59O1xuXG4vLyBzcmMvZHVyYXRpb24udHNcbmZ1bmN0aW9uIG1zKGQpIHtcbiAgY29uc3QgbWF0Y2ggPSBkLm1hdGNoKC9eKFxcZCspXFxzPyhtc3xzfG18aHxkKSQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHdpbmRvdyBzaXplOiAke2R9YCk7XG4gIH1cbiAgY29uc3QgdGltZSA9IE51bWJlci5wYXJzZUludChtYXRjaFsxXSk7XG4gIGNvbnN0IHVuaXQgPSBtYXRjaFsyXTtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSBcIm1zXCI6XG4gICAgICByZXR1cm4gdGltZTtcbiAgICBjYXNlIFwic1wiOlxuICAgICAgcmV0dXJuIHRpbWUgKiAxZTM7XG4gICAgY2FzZSBcIm1cIjpcbiAgICAgIHJldHVybiB0aW1lICogMWUzICogNjA7XG4gICAgY2FzZSBcImhcIjpcbiAgICAgIHJldHVybiB0aW1lICogMWUzICogNjAgKiA2MDtcbiAgICBjYXNlIFwiZFwiOlxuICAgICAgcmV0dXJuIHRpbWUgKiAxZTMgKiA2MCAqIDYwICogMjQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHdpbmRvdyBzaXplOiAke2R9YCk7XG4gIH1cbn1cblxuLy8gc3JjL2hhc2gudHNcbnZhciBzZXRIYXNoID0gYXN5bmMgKGN0eCwgc2NyaXB0LCBraW5kKSA9PiB7XG4gIGNvbnN0IHJlZ2lvbkNvbnRleHRzID0gXCJyZWRpc1wiIGluIGN0eCA/IFtjdHhdIDogY3R4LnJlZ2lvbkNvbnRleHRzO1xuICBjb25zdCBoYXNoU2FtcGxlID0gcmVnaW9uQ29udGV4dHNbMF0uc2NyaXB0SGFzaGVzW2tpbmRdO1xuICBpZiAoIWhhc2hTYW1wbGUpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChyZWdpb25Db250ZXh0cy5tYXAoYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnRleHQuc2NyaXB0SGFzaGVzW2tpbmRdID0gYXdhaXQgY29udGV4dC5yZWRpcy5zY3JpcHRMb2FkKHNjcmlwdCk7XG4gICAgfSkpO1xuICB9XG4gIDtcbn07XG52YXIgc2FmZUV2YWwgPSBhc3luYyAoY3R4LCBzY3JpcHQsIGtpbmQsIGtleXMsIGFyZ3MpID0+IHtcbiAgaWYgKCFjdHguY2FjaGVTY3JpcHRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IGN0eC5yZWRpcy5ldmFsKHNjcmlwdCwga2V5cywgYXJncyk7XG4gIH1cbiAgO1xuICBhd2FpdCBzZXRIYXNoKGN0eCwgc2NyaXB0LCBraW5kKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgY3R4LnJlZGlzLmV2YWxzaGEoY3R4LnNjcmlwdEhhc2hlc1traW5kXSwga2V5cywgYXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGAke2Vycm9yfWAuaW5jbHVkZXMoXCJOT1NDUklQVFwiKSkge1xuICAgICAgY29uc29sZS5sb2coXCJTY3JpcHQgd2l0aCB0aGUgZXhwZWN0ZWQgaGFzaCB3YXMgbm90IGZvdW5kIGluIHJlZGlzIGRiLiBJdCBpcyBwcm9iYWJseSBmbHVzaGVkLiBXaWxsIGxvYWQgYW5vdGhlciBzY2lwdCBiZWZvcmUgY29udGludWluZy5cIik7XG4gICAgICBjdHguc2NyaXB0SGFzaGVzW2tpbmRdID0gdm9pZCAwO1xuICAgICAgYXdhaXQgc2V0SGFzaChjdHgsIHNjcmlwdCwga2luZCk7XG4gICAgICBjb25zb2xlLmxvZyhcIiAgTmV3IHNjcmlwdCBzdWNjZXNzZnVsbHkgbG9hZGVkLlwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBjdHgucmVkaXMuZXZhbHNoYShjdHguc2NyaXB0SGFzaGVzW2tpbmRdLCBrZXlzLCBhcmdzKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9sdWEtc2NyaXB0cy9tdWx0aS50c1xudmFyIGZpeGVkV2luZG93TGltaXRTY3JpcHQgPSBgXG5cdGxvY2FsIGtleSAgICAgICAgICAgPSBLRVlTWzFdXG5cdGxvY2FsIGlkICAgICAgICAgICAgPSBBUkdWWzFdXG5cdGxvY2FsIHdpbmRvdyAgICAgICAgPSBBUkdWWzJdXG5cdGxvY2FsIGluY3JlbWVudEJ5ICAgPSB0b251bWJlcihBUkdWWzNdKVxuXG5cdHJlZGlzLmNhbGwoXCJIU0VUXCIsIGtleSwgaWQsIGluY3JlbWVudEJ5KVxuXHRsb2NhbCBmaWVsZHMgPSByZWRpcy5jYWxsKFwiSEdFVEFMTFwiLCBrZXkpXG5cdGlmICNmaWVsZHMgPT0gMiBhbmQgdG9udW1iZXIoZmllbGRzWzJdKT09aW5jcmVtZW50QnkgdGhlblxuXHQtLSBUaGUgZmlyc3QgdGltZSB0aGlzIGtleSBpcyBzZXQsIGFuZCB0aGUgdmFsdWUgd2lsbCBiZSBlcXVhbCB0byBpbmNyZW1lbnRCeS5cblx0LS0gU28gd2Ugb25seSBuZWVkIHRoZSBleHBpcmUgY29tbWFuZCBvbmNlXG5cdCAgcmVkaXMuY2FsbChcIlBFWFBJUkVcIiwga2V5LCB3aW5kb3cpXG5cdGVuZFxuXG5cdHJldHVybiBmaWVsZHNcbmA7XG52YXIgZml4ZWRXaW5kb3dSZW1haW5pbmdUb2tlbnNTY3JpcHQgPSBgXG4gICAgICBsb2NhbCBrZXkgPSBLRVlTWzFdXG4gICAgICBsb2NhbCB0b2tlbnMgPSAwXG5cbiAgICAgIGxvY2FsIGZpZWxkcyA9IHJlZGlzLmNhbGwoXCJIR0VUQUxMXCIsIGtleSlcblxuICAgICAgcmV0dXJuIGZpZWxkc1xuICAgIGA7XG52YXIgc2xpZGluZ1dpbmRvd0xpbWl0U2NyaXB0ID0gYFxuXHRsb2NhbCBjdXJyZW50S2V5ICAgID0gS0VZU1sxXSAgICAgICAgICAgLS0gaWRlbnRpZmllciBpbmNsdWRpbmcgcHJlZml4ZXNcblx0bG9jYWwgcHJldmlvdXNLZXkgICA9IEtFWVNbMl0gICAgICAgICAgIC0tIGtleSBvZiB0aGUgcHJldmlvdXMgYnVja2V0XG5cdGxvY2FsIHRva2VucyAgICAgICAgPSB0b251bWJlcihBUkdWWzFdKSAtLSB0b2tlbnMgcGVyIHdpbmRvd1xuXHRsb2NhbCBub3cgICAgICAgICAgID0gQVJHVlsyXSAgICAgICAgICAgLS0gY3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG5cdGxvY2FsIHdpbmRvdyAgICAgICAgPSBBUkdWWzNdICAgICAgICAgICAtLSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcblx0bG9jYWwgcmVxdWVzdElkICAgICA9IEFSR1ZbNF0gICAgICAgICAgIC0tIHV1aWQgZm9yIHRoaXMgcmVxdWVzdFxuXHRsb2NhbCBpbmNyZW1lbnRCeSAgID0gdG9udW1iZXIoQVJHVls1XSkgLS0gY3VzdG9tIHJhdGUsIGRlZmF1bHQgaXMgIDFcblxuXHRsb2NhbCBjdXJyZW50RmllbGRzID0gcmVkaXMuY2FsbChcIkhHRVRBTExcIiwgY3VycmVudEtleSlcblx0bG9jYWwgcmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSAwXG5cdGZvciBpID0gMiwgI2N1cnJlbnRGaWVsZHMsIDIgZG9cblx0cmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyArIHRvbnVtYmVyKGN1cnJlbnRGaWVsZHNbaV0pXG5cdGVuZFxuXG5cdGxvY2FsIHByZXZpb3VzRmllbGRzID0gcmVkaXMuY2FsbChcIkhHRVRBTExcIiwgcHJldmlvdXNLZXkpXG5cdGxvY2FsIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyA9IDBcblx0Zm9yIGkgPSAyLCAjcHJldmlvdXNGaWVsZHMsIDIgZG9cblx0cmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gcmVxdWVzdHNJblByZXZpb3VzV2luZG93ICsgdG9udW1iZXIocHJldmlvdXNGaWVsZHNbaV0pXG5cdGVuZFxuXG5cdGxvY2FsIHBlcmNlbnRhZ2VJbkN1cnJlbnQgPSAoIG5vdyAlIHdpbmRvdykgLyB3aW5kb3dcblx0aWYgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ICogKDEgLSBwZXJjZW50YWdlSW5DdXJyZW50ICkgKyByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyA+PSB0b2tlbnMgdGhlblxuXHQgIHJldHVybiB7Y3VycmVudEZpZWxkcywgcHJldmlvdXNGaWVsZHMsIGZhbHNlfVxuXHRlbmRcblxuXHRyZWRpcy5jYWxsKFwiSFNFVFwiLCBjdXJyZW50S2V5LCByZXF1ZXN0SWQsIGluY3JlbWVudEJ5KVxuXG5cdGlmIHJlcXVlc3RzSW5DdXJyZW50V2luZG93ID09IDAgdGhlbiBcblx0ICAtLSBUaGUgZmlyc3QgdGltZSB0aGlzIGtleSBpcyBzZXQsIHRoZSB2YWx1ZSB3aWxsIGJlIGVxdWFsIHRvIGluY3JlbWVudEJ5LlxuXHQgIC0tIFNvIHdlIG9ubHkgbmVlZCB0aGUgZXhwaXJlIGNvbW1hbmQgb25jZVxuXHQgIHJlZGlzLmNhbGwoXCJQRVhQSVJFXCIsIGN1cnJlbnRLZXksIHdpbmRvdyAqIDIgKyAxMDAwKSAtLSBFbm91Z2ggdGltZSB0byBvdmVybGFwIHdpdGggYSBuZXcgd2luZG93ICsgMSBzZWNvbmRcblx0ZW5kXG5cdHJldHVybiB7Y3VycmVudEZpZWxkcywgcHJldmlvdXNGaWVsZHMsIHRydWV9XG5gO1xudmFyIHNsaWRpbmdXaW5kb3dSZW1haW5pbmdUb2tlbnNTY3JpcHQgPSBgXG5cdGxvY2FsIGN1cnJlbnRLZXkgICAgPSBLRVlTWzFdICAgICAgICAgICAtLSBpZGVudGlmaWVyIGluY2x1ZGluZyBwcmVmaXhlc1xuXHRsb2NhbCBwcmV2aW91c0tleSAgID0gS0VZU1syXSAgICAgICAgICAgLS0ga2V5IG9mIHRoZSBwcmV2aW91cyBidWNrZXRcblx0bG9jYWwgbm93ICAgICAgICAgXHQ9IEFSR1ZbMV0gICAgICAgICAgIC0tIGN1cnJlbnQgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICBcdGxvY2FsIHdpbmRvdyAgICAgIFx0PSBBUkdWWzJdICAgICAgICAgICAtLSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcblxuXHRsb2NhbCBjdXJyZW50RmllbGRzID0gcmVkaXMuY2FsbChcIkhHRVRBTExcIiwgY3VycmVudEtleSlcblx0bG9jYWwgcmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSAwXG5cdGZvciBpID0gMiwgI2N1cnJlbnRGaWVsZHMsIDIgZG9cblx0cmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyArIHRvbnVtYmVyKGN1cnJlbnRGaWVsZHNbaV0pXG5cdGVuZFxuXG5cdGxvY2FsIHByZXZpb3VzRmllbGRzID0gcmVkaXMuY2FsbChcIkhHRVRBTExcIiwgcHJldmlvdXNLZXkpXG5cdGxvY2FsIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyA9IDBcblx0Zm9yIGkgPSAyLCAjcHJldmlvdXNGaWVsZHMsIDIgZG9cblx0cmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gcmVxdWVzdHNJblByZXZpb3VzV2luZG93ICsgdG9udW1iZXIocHJldmlvdXNGaWVsZHNbaV0pXG5cdGVuZFxuXG5cdGxvY2FsIHBlcmNlbnRhZ2VJbkN1cnJlbnQgPSAoIG5vdyAlIHdpbmRvdykgLyB3aW5kb3dcbiAgXHRyZXF1ZXN0c0luUHJldmlvdXNXaW5kb3cgPSBtYXRoLmZsb29yKCggMSAtIHBlcmNlbnRhZ2VJbkN1cnJlbnQgKSAqIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdylcblx0XG5cdHJldHVybiByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyArIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvd1xuYDtcblxuLy8gc3JjL2x1YS1zY3JpcHRzL3Jlc2V0LnRzXG52YXIgcmVzZXRTY3JpcHQgPSBgXG4gICAgICBsb2NhbCBwYXR0ZXJuID0gS0VZU1sxXVxuXG4gICAgICAtLSBJbml0aWFsaXplIGN1cnNvciB0byBzdGFydCBmcm9tIDBcbiAgICAgIGxvY2FsIGN1cnNvciA9IFwiMFwiXG5cbiAgICAgIHJlcGVhdFxuICAgICAgICAgIC0tIFNjYW4gZm9yIGtleXMgbWF0Y2hpbmcgdGhlIHBhdHRlcm5cbiAgICAgICAgICBsb2NhbCBzY2FuX3Jlc3VsdCA9IHJlZGlzLmNhbGwoJ1NDQU4nLCBjdXJzb3IsICdNQVRDSCcsIHBhdHRlcm4pXG5cbiAgICAgICAgICAtLSBFeHRyYWN0IGN1cnNvciBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgY3Vyc29yID0gc2Nhbl9yZXN1bHRbMV1cblxuICAgICAgICAgIC0tIEV4dHJhY3Qga2V5cyBmcm9tIHRoZSBzY2FuIHJlc3VsdFxuICAgICAgICAgIGxvY2FsIGtleXMgPSBzY2FuX3Jlc3VsdFsyXVxuXG4gICAgICAgICAgZm9yIGk9MSwgI2tleXMgZG9cbiAgICAgICAgICByZWRpcy5jYWxsKCdERUwnLCBrZXlzW2ldKVxuICAgICAgICAgIGVuZFxuXG4gICAgICAtLSBDb250aW51ZSBzY2FubmluZyB1bnRpbCBjdXJzb3IgaXMgMCAoZW5kIG9mIGtleXNwYWNlKVxuICAgICAgdW50aWwgY3Vyc29yID09IFwiMFwiXG4gICAgYDtcblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgRGVueUxpc3RFeHRlbnNpb24gPSBcImRlbnlMaXN0XCI7XG52YXIgSXBEZW55TGlzdEtleSA9IFwiaXBEZW55TGlzdFwiO1xudmFyIElwRGVueUxpc3RTdGF0dXNLZXkgPSBcImlwRGVueUxpc3RTdGF0dXNcIjtcblxuLy8gc3JjL2RlbnktbGlzdC9zY3JpcHRzLnRzXG52YXIgY2hlY2tEZW55TGlzdFNjcmlwdCA9IGBcbiAgLS0gQ2hlY2tzIGlmIHZhbHVlcyBwcm92aWRlZWQgaW4gQVJHViBhcmUgcHJlc2VudCBpbiB0aGUgZGVueSBsaXN0cy5cbiAgLS0gVGhpcyBpcyBkb25lIHVzaW5nIHRoZSBhbGxEZW55TGlzdHNLZXkgYmVsb3cuXG5cbiAgLS0gQWRkaXRpb25hbGx5LCBjaGVja3MgdGhlIHN0YXR1cyBvZiB0aGUgaXAgZGVueSBsaXN0IHVzaW5nIHRoZVxuICAtLSBpcERlbnlMaXN0U3RhdHVzS2V5IGJlbG93LiBIZXJlIGFyZSB0aGUgcG9zc2libGUgc3RhdGVzIG9mIHRoZVxuICAtLSBpcERlbnlMaXN0U3RhdHVzS2V5IGtleTpcbiAgLS0gKiBzdGF0dXMgPT0gLTE6IHNldCB0byBcImRpc2FibGVkXCIgd2l0aCBubyBUVExcbiAgLS0gKiBzdGF0dXMgPT0gLTI6IG5vdCBzZXQsIG1lYW5pbmcgdGhhdCBpcyB3YXMgc2V0IGJlZm9yZSBidXQgZXhwaXJlZFxuICAtLSAqIHN0YXR1cyAgPiAgMDogc2V0IHRvIFwidmFsaWRcIiwgd2l0aCBhIFRUTFxuICAtLVxuICAtLSBJbiB0aGUgY2FzZSBvZiBzdGF0dXMgPT0gLTIsIHdlIHNldCB0aGUgc3RhdHVzIHRvIFwicGVuZGluZ1wiIHdpdGhcbiAgLS0gMzAgc2Vjb25kIHR0bC4gRHVyaW5nIHRoaXMgdGltZSwgdGhlIHByb2Nlc3Mgd2hpY2ggZ290IHN0YXR1cyA9PSAtMlxuICAtLSB3aWxsIHVwZGF0ZSB0aGUgaXAgZGVueSBsaXN0LlxuXG4gIGxvY2FsIGFsbERlbnlMaXN0c0tleSAgICAgPSBLRVlTWzFdXG4gIGxvY2FsIGlwRGVueUxpc3RTdGF0dXNLZXkgPSBLRVlTWzJdXG5cbiAgbG9jYWwgcmVzdWx0cyA9IHJlZGlzLmNhbGwoJ1NNSVNNRU1CRVInLCBhbGxEZW55TGlzdHNLZXksIHVucGFjayhBUkdWKSlcbiAgbG9jYWwgc3RhdHVzICA9IHJlZGlzLmNhbGwoJ1RUTCcsIGlwRGVueUxpc3RTdGF0dXNLZXkpXG4gIGlmIHN0YXR1cyA9PSAtMiB0aGVuXG4gICAgcmVkaXMuY2FsbCgnU0VURVgnLCBpcERlbnlMaXN0U3RhdHVzS2V5LCAzMCwgXCJwZW5kaW5nXCIpXG4gIGVuZFxuXG4gIHJldHVybiB7IHJlc3VsdHMsIHN0YXR1cyB9XG5gO1xuXG4vLyBzcmMvZGVueS1saXN0L2lwLWRlbnktbGlzdC50c1xudmFyIGlwX2RlbnlfbGlzdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpcF9kZW55X2xpc3RfZXhwb3J0cywge1xuICBUaHJlc2hvbGRFcnJvcjogKCkgPT4gVGhyZXNob2xkRXJyb3IsXG4gIGRpc2FibGVJcERlbnlMaXN0OiAoKSA9PiBkaXNhYmxlSXBEZW55TGlzdCxcbiAgdXBkYXRlSXBEZW55TGlzdDogKCkgPT4gdXBkYXRlSXBEZW55TGlzdFxufSk7XG5cbi8vIHNyYy9kZW55LWxpc3QvdGltZS50c1xudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gNjAgKiA2MCAqIDFlMztcbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZID0gMjQgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUjtcbnZhciBNSUxMSVNFQ09ORFNfVE9fMkFNID0gMiAqIE1JTExJU0VDT05EU19JTl9IT1VSO1xudmFyIGdldElwTGlzdFRUTCA9ICh0aW1lKSA9PiB7XG4gIGNvbnN0IG5vdyA9IHRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgY29uc3QgdGltZVNpbmNlTGFzdDJBTSA9IChub3cgLSBNSUxMSVNFQ09ORFNfVE9fMkFNKSAlIE1JTExJU0VDT05EU19JTl9EQVk7XG4gIHJldHVybiBNSUxMSVNFQ09ORFNfSU5fREFZIC0gdGltZVNpbmNlTGFzdDJBTTtcbn07XG5cbi8vIHNyYy9kZW55LWxpc3QvaXAtZGVueS1saXN0LnRzXG52YXIgYmFzZVVybCA9IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0YW1wYXJtL2lwc3VtL21hc3Rlci9sZXZlbHNcIjtcbnZhciBUaHJlc2hvbGRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0aHJlc2hvbGQpIHtcbiAgICBzdXBlcihgQWxsb3dlZCB0aHJlc2hvbGQgdmFsdWVzIGFyZSBmcm9tIDEgdG8gOCwgMSBhbmQgOCBpbmNsdWRlZC4gUmVjZWl2ZWQ6ICR7dGhyZXNob2xkfWApO1xuICAgIHRoaXMubmFtZSA9IFwiVGhyZXNob2xkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBnZXRJcERlbnlMaXN0ID0gYXN5bmMgKHRocmVzaG9sZCkgPT4ge1xuICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gXCJudW1iZXJcIiB8fCB0aHJlc2hvbGQgPCAxIHx8IHRocmVzaG9sZCA+IDgpIHtcbiAgICB0aHJvdyBuZXcgVGhyZXNob2xkRXJyb3IodGhyZXNob2xkKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVybH0vJHt0aHJlc2hvbGR9LnR4dGApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgZGF0YTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gbGluZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaXAgZGVueSBsaXN0OiAke2Vycm9yfWApO1xuICB9XG59O1xudmFyIHVwZGF0ZUlwRGVueUxpc3QgPSBhc3luYyAocmVkaXMsIHByZWZpeCwgdGhyZXNob2xkLCB0dGwpID0+IHtcbiAgY29uc3QgYWxsSXBzID0gYXdhaXQgZ2V0SXBEZW55TGlzdCh0aHJlc2hvbGQpO1xuICBjb25zdCBhbGxEZW55TGlzdHMgPSBbcHJlZml4LCBEZW55TGlzdEV4dGVuc2lvbiwgXCJhbGxcIl0uam9pbihcIjpcIik7XG4gIGNvbnN0IGlwRGVueUxpc3QgPSBbcHJlZml4LCBEZW55TGlzdEV4dGVuc2lvbiwgSXBEZW55TGlzdEtleV0uam9pbihcIjpcIik7XG4gIGNvbnN0IHN0YXR1c0tleSA9IFtwcmVmaXgsIElwRGVueUxpc3RTdGF0dXNLZXldLmpvaW4oXCI6XCIpO1xuICBjb25zdCB0cmFuc2FjdGlvbiA9IHJlZGlzLm11bHRpKCk7XG4gIHRyYW5zYWN0aW9uLnNkaWZmc3RvcmUoYWxsRGVueUxpc3RzLCBhbGxEZW55TGlzdHMsIGlwRGVueUxpc3QpO1xuICB0cmFuc2FjdGlvbi5kZWwoaXBEZW55TGlzdCk7XG4gIHRyYW5zYWN0aW9uLnNhZGQoaXBEZW55TGlzdCwgLi4uYWxsSXBzKTtcbiAgdHJhbnNhY3Rpb24uc2RpZmZzdG9yZShpcERlbnlMaXN0LCBpcERlbnlMaXN0LCBhbGxEZW55TGlzdHMpO1xuICB0cmFuc2FjdGlvbi5zdW5pb25zdG9yZShhbGxEZW55TGlzdHMsIGFsbERlbnlMaXN0cywgaXBEZW55TGlzdCk7XG4gIHRyYW5zYWN0aW9uLnNldChzdGF0dXNLZXksIFwidmFsaWRcIiwgeyBweDogdHRsID8/IGdldElwTGlzdFRUTCgpIH0pO1xuICByZXR1cm4gYXdhaXQgdHJhbnNhY3Rpb24uZXhlYygpO1xufTtcbnZhciBkaXNhYmxlSXBEZW55TGlzdCA9IGFzeW5jIChyZWRpcywgcHJlZml4KSA9PiB7XG4gIGNvbnN0IGFsbERlbnlMaXN0c0tleSA9IFtwcmVmaXgsIERlbnlMaXN0RXh0ZW5zaW9uLCBcImFsbFwiXS5qb2luKFwiOlwiKTtcbiAgY29uc3QgaXBEZW55TGlzdEtleSA9IFtwcmVmaXgsIERlbnlMaXN0RXh0ZW5zaW9uLCBJcERlbnlMaXN0S2V5XS5qb2luKFwiOlwiKTtcbiAgY29uc3Qgc3RhdHVzS2V5ID0gW3ByZWZpeCwgSXBEZW55TGlzdFN0YXR1c0tleV0uam9pbihcIjpcIik7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gcmVkaXMubXVsdGkoKTtcbiAgdHJhbnNhY3Rpb24uc2RpZmZzdG9yZShhbGxEZW55TGlzdHNLZXksIGFsbERlbnlMaXN0c0tleSwgaXBEZW55TGlzdEtleSk7XG4gIHRyYW5zYWN0aW9uLmRlbChpcERlbnlMaXN0S2V5KTtcbiAgdHJhbnNhY3Rpb24uc2V0KHN0YXR1c0tleSwgXCJkaXNhYmxlZFwiKTtcbiAgcmV0dXJuIGF3YWl0IHRyYW5zYWN0aW9uLmV4ZWMoKTtcbn07XG5cbi8vIHNyYy9kZW55LWxpc3QvZGVueS1saXN0LnRzXG52YXIgZGVueUxpc3RDYWNoZSA9IG5ldyBDYWNoZSgvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbnZhciBjaGVja0RlbnlMaXN0Q2FjaGUgPSAobWVtYmVycykgPT4ge1xuICByZXR1cm4gbWVtYmVycy5maW5kKFxuICAgIChtZW1iZXIpID0+IGRlbnlMaXN0Q2FjaGUuaXNCbG9ja2VkKG1lbWJlcikuYmxvY2tlZFxuICApO1xufTtcbnZhciBibG9ja01lbWJlciA9IChtZW1iZXIpID0+IHtcbiAgaWYgKGRlbnlMaXN0Q2FjaGUuc2l6ZSgpID4gMWUzKVxuICAgIGRlbnlMaXN0Q2FjaGUuZW1wdHkoKTtcbiAgZGVueUxpc3RDYWNoZS5ibG9ja1VudGlsKG1lbWJlciwgRGF0ZS5ub3coKSArIDZlNCk7XG59O1xudmFyIGNoZWNrRGVueUxpc3QgPSBhc3luYyAocmVkaXMsIHByZWZpeCwgbWVtYmVycykgPT4ge1xuICBjb25zdCBbZGVuaWVkVmFsdWVzLCBpcERlbnlMaXN0U3RhdHVzXSA9IGF3YWl0IHJlZGlzLmV2YWwoXG4gICAgY2hlY2tEZW55TGlzdFNjcmlwdCxcbiAgICBbXG4gICAgICBbcHJlZml4LCBEZW55TGlzdEV4dGVuc2lvbiwgXCJhbGxcIl0uam9pbihcIjpcIiksXG4gICAgICBbcHJlZml4LCBJcERlbnlMaXN0U3RhdHVzS2V5XS5qb2luKFwiOlwiKVxuICAgIF0sXG4gICAgbWVtYmVyc1xuICApO1xuICBsZXQgZGVuaWVkVmFsdWUgPSB2b2lkIDA7XG4gIGRlbmllZFZhbHVlcy5tYXAoKG1lbWJlckRlbmllZCwgaW5kZXgpID0+IHtcbiAgICBpZiAobWVtYmVyRGVuaWVkKSB7XG4gICAgICBibG9ja01lbWJlcihtZW1iZXJzW2luZGV4XSk7XG4gICAgICBkZW5pZWRWYWx1ZSA9IG1lbWJlcnNbaW5kZXhdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGVuaWVkVmFsdWUsXG4gICAgaW52YWxpZElwRGVueUxpc3Q6IGlwRGVueUxpc3RTdGF0dXMgPT09IC0yXG4gIH07XG59O1xudmFyIHJlc29sdmVMaW1pdFBheWxvYWQgPSAocmVkaXMsIHByZWZpeCwgW3JhdGVsaW1pdFJlc3BvbnNlLCBkZW55TGlzdFJlc3BvbnNlXSwgdGhyZXNob2xkKSA9PiB7XG4gIGlmIChkZW55TGlzdFJlc3BvbnNlLmRlbmllZFZhbHVlKSB7XG4gICAgcmF0ZWxpbWl0UmVzcG9uc2Uuc3VjY2VzcyA9IGZhbHNlO1xuICAgIHJhdGVsaW1pdFJlc3BvbnNlLnJlbWFpbmluZyA9IDA7XG4gICAgcmF0ZWxpbWl0UmVzcG9uc2UucmVhc29uID0gXCJkZW55TGlzdFwiO1xuICAgIHJhdGVsaW1pdFJlc3BvbnNlLmRlbmllZFZhbHVlID0gZGVueUxpc3RSZXNwb25zZS5kZW5pZWRWYWx1ZTtcbiAgfVxuICBpZiAoZGVueUxpc3RSZXNwb25zZS5pbnZhbGlkSXBEZW55TGlzdCkge1xuICAgIGNvbnN0IHVwZGF0ZVByb21pc2UgPSB1cGRhdGVJcERlbnlMaXN0KHJlZGlzLCBwcmVmaXgsIHRocmVzaG9sZCk7XG4gICAgcmF0ZWxpbWl0UmVzcG9uc2UucGVuZGluZyA9IFByb21pc2UuYWxsKFtcbiAgICAgIHJhdGVsaW1pdFJlc3BvbnNlLnBlbmRpbmcsXG4gICAgICB1cGRhdGVQcm9taXNlXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIHJhdGVsaW1pdFJlc3BvbnNlO1xufTtcbnZhciBkZWZhdWx0RGVuaWVkUmVzcG9uc2UgPSAoZGVuaWVkVmFsdWUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBsaW1pdDogMCxcbiAgICByZW1haW5pbmc6IDAsXG4gICAgcmVzZXQ6IDAsXG4gICAgcGVuZGluZzogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgcmVhc29uOiBcImRlbnlMaXN0XCIsXG4gICAgZGVuaWVkVmFsdWVcbiAgfTtcbn07XG5cbi8vIHNyYy9yYXRlbGltaXQudHNcbnZhciBSYXRlbGltaXQgPSBjbGFzcyB7XG4gIGxpbWl0ZXI7XG4gIGN0eDtcbiAgcHJlZml4O1xuICB0aW1lb3V0O1xuICBwcmltYXJ5UmVkaXM7XG4gIGFuYWx5dGljcztcbiAgZW5hYmxlUHJvdGVjdGlvbjtcbiAgZGVueUxpc3RUaHJlc2hvbGQ7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxpbWl0ZXIgPSBjb25maWcubGltaXRlcjtcbiAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dCA/PyA1ZTM7XG4gICAgdGhpcy5wcmVmaXggPSBjb25maWcucHJlZml4ID8/IFwiQHVwc3Rhc2gvcmF0ZWxpbWl0XCI7XG4gICAgdGhpcy5lbmFibGVQcm90ZWN0aW9uID0gY29uZmlnLmVuYWJsZVByb3RlY3Rpb24gPz8gZmFsc2U7XG4gICAgdGhpcy5kZW55TGlzdFRocmVzaG9sZCA9IGNvbmZpZy5kZW55TGlzdFRocmVzaG9sZCA/PyA2O1xuICAgIHRoaXMucHJpbWFyeVJlZGlzID0gXCJyZWRpc1wiIGluIHRoaXMuY3R4ID8gdGhpcy5jdHgucmVkaXMgOiB0aGlzLmN0eC5yZWdpb25Db250ZXh0c1swXS5yZWRpcztcbiAgICB0aGlzLmFuYWx5dGljcyA9IGNvbmZpZy5hbmFseXRpY3MgPyBuZXcgQW5hbHl0aWNzKHtcbiAgICAgIHJlZGlzOiB0aGlzLnByaW1hcnlSZWRpcyxcbiAgICAgIHByZWZpeDogdGhpcy5wcmVmaXhcbiAgICB9KSA6IHZvaWQgMDtcbiAgICBpZiAoY29uZmlnLmVwaGVtZXJhbENhY2hlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICB0aGlzLmN0eC5jYWNoZSA9IG5ldyBDYWNoZShjb25maWcuZXBoZW1lcmFsQ2FjaGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5lcGhlbWVyYWxDYWNoZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5jdHguY2FjaGUgPSBuZXcgQ2FjaGUoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBwYXNzIG9yIGJlIHJlamVjdGVkIGJhc2VkIG9uIHRoZSBpZGVudGlmaWVyIGFuZCBwcmV2aW91c2x5IGNob3NlbiByYXRlbGltaXQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHJlamVjdCBhbGwgcmVxdWVzdHMgdGhhdCB5b3UgY2FuIG5vdCBoYW5kbGUgcmlnaHQgbm93LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAgY29uc3QgcmF0ZWxpbWl0ID0gbmV3IFJhdGVsaW1pdCh7XG4gICAqICAgIHJlZGlzOiBSZWRpcy5mcm9tRW52KCksXG4gICAqICAgIGxpbWl0ZXI6IFJhdGVsaW1pdC5zbGlkaW5nV2luZG93KDEwLCBcIjEwIHNcIilcbiAgICogIH0pXG4gICAqXG4gICAqICBjb25zdCB7IHN1Y2Nlc3MgfSA9IGF3YWl0IHJhdGVsaW1pdC5saW1pdChpZClcbiAgICogIGlmICghc3VjY2Vzcyl7XG4gICAqICAgIHJldHVybiBcIk5vcGVcIlxuICAgKiAgfVxuICAgKiAgcmV0dXJuIFwiWWVzXCJcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByZXEucmF0ZSAtIFRoZSByYXRlIGF0IHdoaWNoIHRva2VucyB3aWxsIGJlIGFkZGVkIG9yIGNvbnN1bWVkIGZyb20gdGhlIHRva2VuIGJ1Y2tldC4gQSBoaWdoZXIgcmF0ZSBhbGxvd3MgZm9yIG1vcmUgcmVxdWVzdHMgdG8gYmUgcHJvY2Vzc2VkLiBEZWZhdWx0cyB0byAxIHRva2VuIHBlciBpbnRlcnZhbCBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBVc2FnZSB3aXRoIGByZXEucmF0ZWBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogIGNvbnN0IHJhdGVsaW1pdCA9IG5ldyBSYXRlbGltaXQoe1xuICAgKiAgICByZWRpczogUmVkaXMuZnJvbUVudigpLFxuICAgKiAgICBsaW1pdGVyOiBSYXRlbGltaXQuc2xpZGluZ1dpbmRvdygxMDAsIFwiMTAgc1wiKVxuICAgKiAgfSlcbiAgICpcbiAgICogIGNvbnN0IHsgc3VjY2VzcyB9ID0gYXdhaXQgcmF0ZWxpbWl0LmxpbWl0KGlkLCB7cmF0ZTogMTB9KVxuICAgKiAgaWYgKCFzdWNjZXNzKXtcbiAgICogICAgcmV0dXJuIFwiTm9wZVwiXG4gICAqICB9XG4gICAqICByZXR1cm4gXCJZZXNcIlxuICAgKiBgYGBcbiAgICovXG4gIGxpbWl0ID0gYXN5bmMgKGlkZW50aWZpZXIsIHJlcSkgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuZ2V0UmF0ZWxpbWl0UmVzcG9uc2UoaWRlbnRpZmllciwgcmVxKTtcbiAgICAgIGNvbnN0IHsgcmVzcG9uc2VBcnJheSwgbmV3VGltZW91dElkIH0gPSB0aGlzLmFwcGx5VGltZW91dChyZXNwb25zZSk7XG4gICAgICB0aW1lb3V0SWQgPSBuZXdUaW1lb3V0SWQ7XG4gICAgICBjb25zdCB0aW1lZFJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKHJlc3BvbnNlQXJyYXkpO1xuICAgICAgY29uc3QgZmluYWxSZXNwb25zZSA9IHRoaXMuc3VibWl0QW5hbHl0aWNzKHRpbWVkUmVzcG9uc2UsIGlkZW50aWZpZXIsIHJlcSk7XG4gICAgICByZXR1cm4gZmluYWxSZXNwb25zZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBCbG9jayB1bnRpbCB0aGUgcmVxdWVzdCBtYXkgcGFzcyBvciB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYXMgc29vbiBhcyB0aGUgcmVxdWVzdCBtYXkgYmUgcHJvY2Vzc2VkXG4gICAqIG9yIGFmdGVyIHRoZSB0aW1lb3V0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGRlbGF5IHRoZSByZXF1ZXN0IHVudGlsIGl0IGlzIHJlYWR5IHRvIGdldCBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqICBjb25zdCByYXRlbGltaXQgPSBuZXcgUmF0ZWxpbWl0KHtcbiAgICogICAgcmVkaXM6IFJlZGlzLmZyb21FbnYoKSxcbiAgICogICAgbGltaXRlcjogUmF0ZWxpbWl0LnNsaWRpbmdXaW5kb3coMTAsIFwiMTAgc1wiKVxuICAgKiAgfSlcbiAgICpcbiAgICogIGNvbnN0IHsgc3VjY2VzcyB9ID0gYXdhaXQgcmF0ZWxpbWl0LmJsb2NrVW50aWxSZWFkeShpZCwgNjBfMDAwKVxuICAgKiAgaWYgKCFzdWNjZXNzKXtcbiAgICogICAgcmV0dXJuIFwiTm9wZVwiXG4gICAqICB9XG4gICAqICByZXR1cm4gXCJZZXNcIlxuICAgKiBgYGBcbiAgICovXG4gIGJsb2NrVW50aWxSZWFkeSA9IGFzeW5jIChpZGVudGlmaWVyLCB0aW1lb3V0KSA9PiB7XG4gICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGltZW91dCBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzO1xuICAgIGNvbnN0IGRlYWRsaW5lID0gRGF0ZS5ub3coKSArIHRpbWVvdXQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHJlcyA9IGF3YWl0IHRoaXMubGltaXQoaWRlbnRpZmllcik7XG4gICAgICBpZiAocmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocmVzLnJlc2V0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWl0ID0gTWF0aC5taW4ocmVzLnJlc2V0LCBkZWFkbGluZSkgLSBEYXRlLm5vdygpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgd2FpdCkpO1xuICAgICAgaWYgKERhdGUubm93KCkgPiBkZWFkbGluZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVzZXRVc2VkVG9rZW5zID0gYXN5bmMgKGlkZW50aWZpZXIpID0+IHtcbiAgICBjb25zdCBwYXR0ZXJuID0gW3RoaXMucHJlZml4LCBpZGVudGlmaWVyXS5qb2luKFwiOlwiKTtcbiAgICBhd2FpdCB0aGlzLmxpbWl0ZXIoKS5yZXNldFRva2Vucyh0aGlzLmN0eCwgcGF0dGVybik7XG4gIH07XG4gIGdldFJlbWFpbmluZyA9IGFzeW5jIChpZGVudGlmaWVyKSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IFt0aGlzLnByZWZpeCwgaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubGltaXRlcigpLmdldFJlbWFpbmluZyh0aGlzLmN0eCwgcGF0dGVybik7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGlkZW50aWZpZXIgb3IgdGhlIHZhbHVlcyBpbiByZXEgYXJlIGluIHRoZSBkZW55IGxpc3QgY2FjaGUuXG4gICAqIElmIHNvLCByZXR1cm5zIHRoZSBkZWZhdWx0IGRlbmllZCByZXNwb25zZS5cbiAgICogXG4gICAqIE90aGVyd2lzZSwgY2FsbHMgcmVkaXMgdG8gY2hlY2sgdGhlIHJhdGUgbGltaXQgYW5kIGRlbnkgbGlzdC4gUmV0dXJucyBhZnRlclxuICAgKiByZXNvbHZpbmcgdGhlIHJlc3VsdC4gUmVzb2x2aW5nIGlzIG92ZXJyaWRpbmcgdGhlIHJhdGUgbGltaXQgcmVzdWx0IGlmXG4gICAqIHRoZSBzb21lIHZhbHVlIGlzIGluIGRlbnkgbGlzdC5cbiAgICogXG4gICAqIEBwYXJhbSBpZGVudGlmaWVyIGlkZW50aWZpZXIgdG8gYmxvY2tcbiAgICogQHBhcmFtIHJlcSBvcHRpb25zIHdpdGggaXAsIHVzZXIgYWdlbnQsIGNvdW50cnksIHJhdGUgYW5kIGdlbyBpbmZvXG4gICAqIEByZXR1cm5zIHJhdGUgbGltaXQgcmVzcG9uc2VcbiAgICovXG4gIGdldFJhdGVsaW1pdFJlc3BvbnNlID0gYXN5bmMgKGlkZW50aWZpZXIsIHJlcSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGlkZW50aWZpZXIpO1xuICAgIGNvbnN0IGRlZmluZWRNZW1iZXJzID0gdGhpcy5nZXREZWZpbmVkTWVtYmVycyhpZGVudGlmaWVyLCByZXEpO1xuICAgIGNvbnN0IGRlbmllZFZhbHVlID0gY2hlY2tEZW55TGlzdENhY2hlKGRlZmluZWRNZW1iZXJzKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChkZW5pZWRWYWx1ZSkge1xuICAgICAgcmVzdWx0ID0gW2RlZmF1bHREZW5pZWRSZXNwb25zZShkZW5pZWRWYWx1ZSksIHsgZGVuaWVkVmFsdWUsIGludmFsaWRJcERlbnlMaXN0OiBmYWxzZSB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmxpbWl0ZXIoKS5saW1pdCh0aGlzLmN0eCwga2V5LCByZXE/LnJhdGUpLFxuICAgICAgICB0aGlzLmVuYWJsZVByb3RlY3Rpb24gPyBjaGVja0RlbnlMaXN0KHRoaXMucHJpbWFyeVJlZGlzLCB0aGlzLnByZWZpeCwgZGVmaW5lZE1lbWJlcnMpIDogeyBkZW5pZWRWYWx1ZTogdm9pZCAwLCBpbnZhbGlkSXBEZW55TGlzdDogZmFsc2UgfVxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlTGltaXRQYXlsb2FkKHRoaXMucHJpbWFyeVJlZGlzLCB0aGlzLnByZWZpeCwgcmVzdWx0LCB0aGlzLmRlbnlMaXN0VGhyZXNob2xkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgcHJvbWlzZSBhbmQgYSB0aW1lb3V0IHByb21pc2VcbiAgICogaWYgdGhpcy50aW1lb3V0ID4gMC5cbiAgICogXG4gICAqIEBwYXJhbSByZXNwb25zZSBSYXRlbGltaXQgcmVzcG9uc2UgcHJvbWlzZVxuICAgKiBAcmV0dXJucyBhcnJheSB3aXRoIHRoZSByZXNwb25zZSBhbmQgdGltZW91dCBwcm9taXNlLiBhbHNvIGluY2x1ZGVzIHRoZSB0aW1lb3V0IGlkXG4gICAqL1xuICBhcHBseVRpbWVvdXQgPSAocmVzcG9uc2UpID0+IHtcbiAgICBsZXQgbmV3VGltZW91dElkID0gbnVsbDtcbiAgICBjb25zdCByZXNwb25zZUFycmF5ID0gW3Jlc3BvbnNlXTtcbiAgICBpZiAodGhpcy50aW1lb3V0ID4gMCkge1xuICAgICAgY29uc3QgdGltZW91dFJlc3BvbnNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgbmV3VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgbGltaXQ6IDAsXG4gICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICByZXNldDogMCxcbiAgICAgICAgICAgIHBlbmRpbmc6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVhc29uOiBcInRpbWVvdXRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgfSk7XG4gICAgICByZXNwb25zZUFycmF5LnB1c2godGltZW91dFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlQXJyYXksXG4gICAgICBuZXdUaW1lb3V0SWRcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogc3VibWl0cyBhbmFseXRpY3MgaWYgdGhpcy5hbmFseXRpY3MgaXMgc2V0XG4gICAqIFxuICAgKiBAcGFyYW0gcmF0ZWxpbWl0UmVzcG9uc2UgZmluYWwgcmF0ZSBsaW1pdCByZXNwb25zZVxuICAgKiBAcGFyYW0gaWRlbnRpZmllciBpZGVudGlmaWVyIHRvIHN1Ym1pdFxuICAgKiBAcGFyYW0gcmVxIGxpbWl0IG9wdGlvbnNcbiAgICogQHJldHVybnMgcmF0ZSBsaW1pdCByZXNwb25zZSBhZnRlciB1cGRhdGluZyB0aGUgLnBlbmRpbmcgZmllbGRcbiAgICovXG4gIHN1Ym1pdEFuYWx5dGljcyA9IChyYXRlbGltaXRSZXNwb25zZSwgaWRlbnRpZmllciwgcmVxKSA9PiB7XG4gICAgaWYgKHRoaXMuYW5hbHl0aWNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBnZW8gPSByZXEgPyB0aGlzLmFuYWx5dGljcy5leHRyYWN0R2VvKHJlcSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGFuYWx5dGljc1AgPSB0aGlzLmFuYWx5dGljcy5yZWNvcmQoe1xuICAgICAgICAgIGlkZW50aWZpZXI6IHJhdGVsaW1pdFJlc3BvbnNlLnJlYXNvbiA9PT0gXCJkZW55TGlzdFwiID8gcmF0ZWxpbWl0UmVzcG9uc2UuZGVuaWVkVmFsdWUgOiBpZGVudGlmaWVyLFxuICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgc3VjY2VzczogcmF0ZWxpbWl0UmVzcG9uc2UucmVhc29uID09PSBcImRlbnlMaXN0XCIgPyBcImRlbmllZFwiIDogcmF0ZWxpbWl0UmVzcG9uc2Uuc3VjY2VzcyxcbiAgICAgICAgICAuLi5nZW9cbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIkZhaWxlZCB0byByZWNvcmQgYW5hbHl0aWNzXCI7XG4gICAgICAgICAgaWYgKGAke2Vycn1gLmluY2x1ZGVzKFwiV1JPTkdUWVBFXCIpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgXG4gICAgRmFpbGVkIHRvIHJlY29yZCBhbmFseXRpY3MuIFNlZSB0aGUgaW5mb3JtYXRpb24gYmVsb3c6XG5cbiAgICBUaGlzIGNhbiBvY2N1ciB3aGVuIHlvdSB1cHJhZGUgdG8gUmF0ZWxpbWl0IHZlcnNpb24gMS4xLjJcbiAgICBvciBsYXRlciBmcm9tIGFuIGVhcmxpZXIgdmVyc2lvbi5cblxuICAgIFRoaXMgb2NjdXJzIHNpbXBseSBiZWNhdXNlIHRoZSB3YXkgd2Ugc3RvcmUgYW5hbHl0aWNzIGRhdGFcbiAgICBoYXMgY2hhbmdlZC4gVG8gYXZvaWQgZ2V0dGluZyB0aGlzIGVycm9yLCBkaXNhYmxlIGFuYWx5dGljc1xuICAgIGZvciAqYW4gaG91ciosIHRoZW4gc2ltcGx5IGVuYWJsZSBpdCBiYWNrLlxuXG4gICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS53YXJuKGVycm9yTWVzc2FnZSwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJhdGVsaW1pdFJlc3BvbnNlLnBlbmRpbmcgPSBQcm9taXNlLmFsbChbcmF0ZWxpbWl0UmVzcG9uc2UucGVuZGluZywgYW5hbHl0aWNzUF0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byByZWNvcmQgYW5hbHl0aWNzXCIsIGVycik7XG4gICAgICB9XG4gICAgICA7XG4gICAgfVxuICAgIDtcbiAgICByZXR1cm4gcmF0ZWxpbWl0UmVzcG9uc2U7XG4gIH07XG4gIGdldEtleSA9IChpZGVudGlmaWVyKSA9PiB7XG4gICAgcmV0dXJuIFt0aGlzLnByZWZpeCwgaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gIH07XG4gIC8qKlxuICAgKiByZXR1cm5zIGEgbGlzdCBvZiBkZWZpbmVkIHZhbHVlcyBmcm9tXG4gICAqIFtpZGVudGlmaWVyLCByZXEuaXAsIHJlcS51c2VyQWdlbnQsIHJlcS5jb3VudHJ5XVxuICAgKiBcbiAgICogQHBhcmFtIGlkZW50aWZpZXIgaWRlbnRpZmllclxuICAgKiBAcGFyYW0gcmVxIGxpbWl0IG9wdGlvbnNcbiAgICogQHJldHVybnMgbGlzdCBvZiBkZWZpbmVkIHZhbHVlc1xuICAgKi9cbiAgZ2V0RGVmaW5lZE1lbWJlcnMgPSAoaWRlbnRpZmllciwgcmVxKSA9PiB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtpZGVudGlmaWVyLCByZXE/LmlwLCByZXE/LnVzZXJBZ2VudCwgcmVxPy5jb3VudHJ5XTtcbiAgICByZXR1cm4gbWVtYmVycy5maWx0ZXIoKGl0ZW0pID0+IEJvb2xlYW4oaXRlbSkpO1xuICB9O1xufTtcblxuLy8gc3JjL211bHRpLnRzXG5mdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGNvbnN0IGNoYXJhY3RlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gIGNvbnN0IGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIE11bHRpUmVnaW9uUmF0ZWxpbWl0ID0gY2xhc3MgZXh0ZW5kcyBSYXRlbGltaXQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhdGVsaW1pdCBpbnN0YW5jZSBieSBwcm92aWRpbmcgYSBgQHVwc3Rhc2gvcmVkaXNgIGluc3RhbmNlIGFuZCB0aGUgYWxnb3JpdGhuIG9mIHlvdXIgY2hvaWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoe1xuICAgICAgcHJlZml4OiBjb25maWcucHJlZml4LFxuICAgICAgbGltaXRlcjogY29uZmlnLmxpbWl0ZXIsXG4gICAgICB0aW1lb3V0OiBjb25maWcudGltZW91dCxcbiAgICAgIGFuYWx5dGljczogY29uZmlnLmFuYWx5dGljcyxcbiAgICAgIGN0eDoge1xuICAgICAgICByZWdpb25Db250ZXh0czogY29uZmlnLnJlZGlzLm1hcCgocmVkaXMpID0+ICh7XG4gICAgICAgICAgcmVkaXMsXG4gICAgICAgICAgc2NyaXB0SGFzaGVzOiB7fSxcbiAgICAgICAgICBjYWNoZVNjcmlwdHM6IGNvbmZpZy5jYWNoZVNjcmlwdHMgPz8gdHJ1ZVxuICAgICAgICB9KSksXG4gICAgICAgIGNhY2hlOiBjb25maWcuZXBoZW1lcmFsQ2FjaGUgPyBuZXcgQ2FjaGUoY29uZmlnLmVwaGVtZXJhbENhY2hlKSA6IHZvaWQgMFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFYWNoIHJlcXVlc3QgaW5zaWRlIGEgZml4ZWQgdGltZSBpbmNyZWFzZXMgYSBjb3VudGVyLlxuICAgKiBPbmNlIHRoZSBjb3VudGVyIHJlYWNoZXMgdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIsIGFsbCBmdXJ0aGVyIHJlcXVlc3RzIGFyZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogKipQcm86KipcbiAgICpcbiAgICogLSBOZXdlciByZXF1ZXN0cyBhcmUgbm90IHN0YXJ2ZWQgYnkgb2xkIG9uZXMuXG4gICAqIC0gTG93IHN0b3JhZ2UgY29zdC5cbiAgICpcbiAgICogKipDb246KipcbiAgICpcbiAgICogQSBidXJzdCBvZiByZXF1ZXN0cyBuZWFyIHRoZSBib3VuZGFyeSBvZiBhIHdpbmRvdyBjYW4gcmVzdWx0IGluIGEgdmVyeVxuICAgKiBoaWdoIHJlcXVlc3QgcmF0ZSBiZWNhdXNlIHR3byB3aW5kb3dzIHdpbGwgYmUgZmlsbGVkIHdpdGggcmVxdWVzdHMgcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHRva2VucyAtIEhvdyBtYW55IHJlcXVlc3RzIGEgdXNlciBjYW4gbWFrZSBpbiBlYWNoIHRpbWUgd2luZG93LlxuICAgKiBAcGFyYW0gd2luZG93IC0gQSBmaXhlZCB0aW1lZnJhbWVcbiAgICovXG4gIHN0YXRpYyBmaXhlZFdpbmRvdyh0b2tlbnMsIHdpbmRvdykge1xuICAgIGNvbnN0IHdpbmRvd0R1cmF0aW9uID0gbXMod2luZG93KTtcbiAgICByZXR1cm4gKCkgPT4gKHtcbiAgICAgIGFzeW5jIGxpbWl0KGN0eCwgaWRlbnRpZmllciwgcmF0ZSkge1xuICAgICAgICBpZiAoY3R4LmNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgeyBibG9ja2VkLCByZXNldDogcmVzZXQyIH0gPSBjdHguY2FjaGUuaXNCbG9ja2VkKGlkZW50aWZpZXIpO1xuICAgICAgICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICByZXNldDogcmVzZXQyLFxuICAgICAgICAgICAgICBwZW5kaW5nOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgcmVhc29uOiBcImNhY2hlQmxvY2tcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gd2luZG93RHVyYXRpb24pO1xuICAgICAgICBjb25zdCBrZXkgPSBbaWRlbnRpZmllciwgYnVja2V0XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgaW5jcmVtZW50QnkgPSByYXRlID8gTWF0aC5tYXgoMSwgcmF0ZSkgOiAxO1xuICAgICAgICBjb25zdCBkYnMgPSBjdHgucmVnaW9uQ29udGV4dHMubWFwKChyZWdpb25Db250ZXh0KSA9PiAoe1xuICAgICAgICAgIHJlZGlzOiByZWdpb25Db250ZXh0LnJlZGlzLFxuICAgICAgICAgIHJlcXVlc3Q6IHNhZmVFdmFsKFxuICAgICAgICAgICAgcmVnaW9uQ29udGV4dCxcbiAgICAgICAgICAgIGZpeGVkV2luZG93TGltaXRTY3JpcHQsXG4gICAgICAgICAgICBcImxpbWl0SGFzaFwiLFxuICAgICAgICAgICAgW2tleV0sXG4gICAgICAgICAgICBbcmVxdWVzdElkLCB3aW5kb3dEdXJhdGlvbiwgaW5jcmVtZW50QnldXG4gICAgICAgICAgKVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLmFueShkYnMubWFwKChzKSA9PiBzLnJlcXVlc3QpKTtcbiAgICAgICAgY29uc3QgdXNlZFRva2VucyA9IGZpcnN0UmVzcG9uc2UucmVkdWNlKChhY2NUb2tlbnMsIHVzZWRUb2tlbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgcGFyc2VkVG9rZW4gPSAwO1xuICAgICAgICAgIGlmIChpbmRleCAlIDIpIHtcbiAgICAgICAgICAgIHBhcnNlZFRva2VuID0gTnVtYmVyLnBhcnNlSW50KHVzZWRUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2NUb2tlbnMgKyBwYXJzZWRUb2tlbjtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRva2VucyAtIHVzZWRUb2tlbnM7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgICAgY29uc3QgaW5kaXZpZHVhbElEcyA9IGF3YWl0IFByb21pc2UuYWxsKGRicy5tYXAoKHMpID0+IHMucmVxdWVzdCkpO1xuICAgICAgICAgIGNvbnN0IGFsbElEcyA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICBuZXcgU2V0KFxuICAgICAgICAgICAgICBpbmRpdmlkdWFsSURzLmZsYXRNYXAoKF8pID0+IF8pLnJlZHVjZSgoYWNjLCBjdXJyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgICkudmFsdWVzKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgZGIgb2YgZGJzKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VkRGJUb2tlbnMgPSAoYXdhaXQgZGIucmVxdWVzdCkucmVkdWNlKFxuICAgICAgICAgICAgICAoYWNjVG9rZW5zLCB1c2VkVG9rZW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZFRva2VuID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWRUb2tlbiA9IE51bWJlci5wYXJzZUludCh1c2VkVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjVG9rZW5zICsgcGFyc2VkVG9rZW47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBkYklkcyA9IChhd2FpdCBkYi5yZXF1ZXN0KS5yZWR1Y2UoKGlkcywgY3VycmVudElkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goY3VycmVudElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgaWYgKHVzZWREYlRva2VucyA+PSB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWxsSURzLmZpbHRlcigoaWQpID0+ICFkYklkcy5pbmNsdWRlcyhpZCkpO1xuICAgICAgICAgICAgaWYgKGRpZmYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0SWQyIG9mIGRpZmYpIHtcbiAgICAgICAgICAgICAgYXdhaXQgZGIucmVkaXMuaHNldChrZXksIHsgW3JlcXVlc3RJZDJdOiBpbmNyZW1lbnRCeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJlbWFpbmluZyA+IDA7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKGJ1Y2tldCArIDEpICogd2luZG93RHVyYXRpb247XG4gICAgICAgIGlmIChjdHguY2FjaGUgJiYgIXN1Y2Nlc3MpIHtcbiAgICAgICAgICBjdHguY2FjaGUuYmxvY2tVbnRpbChpZGVudGlmaWVyLCByZXNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgIGxpbWl0OiB0b2tlbnMsXG4gICAgICAgICAgcmVtYWluaW5nLFxuICAgICAgICAgIHJlc2V0LFxuICAgICAgICAgIHBlbmRpbmc6IHN5bmMoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGdldFJlbWFpbmluZyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gd2luZG93RHVyYXRpb24pO1xuICAgICAgICBjb25zdCBrZXkgPSBbaWRlbnRpZmllciwgYnVja2V0XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgZGJzID0gY3R4LnJlZ2lvbkNvbnRleHRzLm1hcCgocmVnaW9uQ29udGV4dCkgPT4gKHtcbiAgICAgICAgICByZWRpczogcmVnaW9uQ29udGV4dC5yZWRpcyxcbiAgICAgICAgICByZXF1ZXN0OiBzYWZlRXZhbChcbiAgICAgICAgICAgIHJlZ2lvbkNvbnRleHQsXG4gICAgICAgICAgICBmaXhlZFdpbmRvd1JlbWFpbmluZ1Rva2Vuc1NjcmlwdCxcbiAgICAgICAgICAgIFwiZ2V0UmVtYWluaW5nSGFzaFwiLFxuICAgICAgICAgICAgW2tleV0sXG4gICAgICAgICAgICBbbnVsbF1cbiAgICAgICAgICApXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgZmlyc3RSZXNwb25zZSA9IGF3YWl0IFByb21pc2UuYW55KGRicy5tYXAoKHMpID0+IHMucmVxdWVzdCkpO1xuICAgICAgICBjb25zdCB1c2VkVG9rZW5zID0gZmlyc3RSZXNwb25zZS5yZWR1Y2UoKGFjY1Rva2VucywgdXNlZFRva2VuLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGxldCBwYXJzZWRUb2tlbiA9IDA7XG4gICAgICAgICAgaWYgKGluZGV4ICUgMikge1xuICAgICAgICAgICAgcGFyc2VkVG9rZW4gPSBOdW1iZXIucGFyc2VJbnQodXNlZFRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjY1Rva2VucyArIHBhcnNlZFRva2VuO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRva2VucyAtIHVzZWRUb2tlbnMpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHJlc2V0VG9rZW5zKGN0eCwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gW2lkZW50aWZpZXIsIFwiKlwiXS5qb2luKFwiOlwiKTtcbiAgICAgICAgaWYgKGN0eC5jYWNoZSkge1xuICAgICAgICAgIGN0eC5jYWNoZS5wb3AoaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY3R4LnJlZ2lvbkNvbnRleHRzLm1hcCgocmVnaW9uQ29udGV4dCkgPT4ge1xuICAgICAgICAgIHNhZmVFdmFsKFxuICAgICAgICAgICAgcmVnaW9uQ29udGV4dCxcbiAgICAgICAgICAgIHJlc2V0U2NyaXB0LFxuICAgICAgICAgICAgXCJyZXNldEhhc2hcIixcbiAgICAgICAgICAgIFtwYXR0ZXJuXSxcbiAgICAgICAgICAgIFtudWxsXVxuICAgICAgICAgICk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tYmluZWQgYXBwcm9hY2ggb2YgYHNsaWRpbmdMb2dzYCBhbmQgYGZpeGVkV2luZG93YCB3aXRoIGxvd2VyIHN0b3JhZ2VcbiAgICogY29zdHMgdGhhbiBgc2xpZGluZ0xvZ3NgIGFuZCBpbXByb3ZlZCBib3VuZGFyeSBiZWhhdmlvciBieSBjYWxjdWxhdGluZyBhXG4gICAqIHdlaWdodGVkIHNjb3JlIGJldHdlZW4gdHdvIHdpbmRvd3MuXG4gICAqXG4gICAqICoqUHJvOioqXG4gICAqXG4gICAqIEdvb2QgcGVyZm9ybWFuY2UgYWxsb3dzIHRoaXMgdG8gc2NhbGUgdG8gdmVyeSBoaWdoIGxvYWRzLlxuICAgKlxuICAgKiAqKkNvbjoqKlxuICAgKlxuICAgKiBOb3RoaW5nIG1ham9yLlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5zIC0gSG93IG1hbnkgcmVxdWVzdHMgYSB1c2VyIGNhbiBtYWtlIGluIGVhY2ggdGltZSB3aW5kb3cuXG4gICAqIEBwYXJhbSB3aW5kb3cgLSBUaGUgZHVyYXRpb24gaW4gd2hpY2ggdGhlIHVzZXIgY2FuIG1heCBYIHJlcXVlc3RzLlxuICAgKi9cbiAgc3RhdGljIHNsaWRpbmdXaW5kb3codG9rZW5zLCB3aW5kb3cpIHtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gbXMod2luZG93KTtcbiAgICBjb25zdCB3aW5kb3dEdXJhdGlvbiA9IG1zKHdpbmRvdyk7XG4gICAgcmV0dXJuICgpID0+ICh7XG4gICAgICBhc3luYyBsaW1pdChjdHgsIGlkZW50aWZpZXIsIHJhdGUpIHtcbiAgICAgICAgaWYgKGN0eC5jYWNoZSkge1xuICAgICAgICAgIGNvbnN0IHsgYmxvY2tlZCwgcmVzZXQ6IHJlc2V0MiB9ID0gY3R4LmNhY2hlLmlzQmxvY2tlZChpZGVudGlmaWVyKTtcbiAgICAgICAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGxpbWl0OiB0b2tlbnMsXG4gICAgICAgICAgICAgIHJlbWFpbmluZzogMCxcbiAgICAgICAgICAgICAgcmVzZXQ6IHJlc2V0MixcbiAgICAgICAgICAgICAgcGVuZGluZzogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICAgIHJlYXNvbjogXCJjYWNoZUJsb2NrXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBNYXRoLmZsb29yKG5vdyAvIHdpbmRvd1NpemUpO1xuICAgICAgICBjb25zdCBjdXJyZW50S2V5ID0gW2lkZW50aWZpZXIsIGN1cnJlbnRXaW5kb3ddLmpvaW4oXCI6XCIpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1dpbmRvdyA9IGN1cnJlbnRXaW5kb3cgLSAxO1xuICAgICAgICBjb25zdCBwcmV2aW91c0tleSA9IFtpZGVudGlmaWVyLCBwcmV2aW91c1dpbmRvd10uam9pbihcIjpcIik7XG4gICAgICAgIGNvbnN0IGluY3JlbWVudEJ5ID0gcmF0ZSA/IE1hdGgubWF4KDEsIHJhdGUpIDogMTtcbiAgICAgICAgY29uc3QgZGJzID0gY3R4LnJlZ2lvbkNvbnRleHRzLm1hcCgocmVnaW9uQ29udGV4dCkgPT4gKHtcbiAgICAgICAgICByZWRpczogcmVnaW9uQ29udGV4dC5yZWRpcyxcbiAgICAgICAgICByZXF1ZXN0OiBzYWZlRXZhbChcbiAgICAgICAgICAgIHJlZ2lvbkNvbnRleHQsXG4gICAgICAgICAgICBzbGlkaW5nV2luZG93TGltaXRTY3JpcHQsXG4gICAgICAgICAgICBcImxpbWl0SGFzaFwiLFxuICAgICAgICAgICAgW2N1cnJlbnRLZXksIHByZXZpb3VzS2V5XSxcbiAgICAgICAgICAgIFt0b2tlbnMsIG5vdywgd2luZG93RHVyYXRpb24sIHJlcXVlc3RJZCwgaW5jcmVtZW50QnldXG4gICAgICAgICAgICAvLyBsdWEgc2VlbXMgdG8gcmV0dXJuIGAxYCBmb3IgdHJ1ZSBhbmQgYG51bGxgIGZvciBmYWxzZVxuICAgICAgICAgIClcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlSW5DdXJyZW50ID0gbm93ICUgd2luZG93RHVyYXRpb24gLyB3aW5kb3dEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgW2N1cnJlbnQsIHByZXZpb3VzLCBzdWNjZXNzXSA9IGF3YWl0IFByb21pc2UuYW55KGRicy5tYXAoKHMpID0+IHMucmVxdWVzdCkpO1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGN1cnJlbnQucHVzaChyZXF1ZXN0SWQsIGluY3JlbWVudEJ5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVXNlZFRva2VucyA9IHByZXZpb3VzLnJlZHVjZSgoYWNjVG9rZW5zLCB1c2VkVG9rZW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgbGV0IHBhcnNlZFRva2VuID0gMDtcbiAgICAgICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgICAgICBwYXJzZWRUb2tlbiA9IE51bWJlci5wYXJzZUludCh1c2VkVG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjVG9rZW5zICsgcGFyc2VkVG9rZW47XG4gICAgICAgIH0sIDApO1xuICAgICAgICBjb25zdCBjdXJyZW50VXNlZFRva2VucyA9IGN1cnJlbnQucmVkdWNlKChhY2NUb2tlbnMsIHVzZWRUb2tlbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgcGFyc2VkVG9rZW4gPSAwO1xuICAgICAgICAgIGlmIChpbmRleCAlIDIpIHtcbiAgICAgICAgICAgIHBhcnNlZFRva2VuID0gTnVtYmVyLnBhcnNlSW50KHVzZWRUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2NUb2tlbnMgKyBwYXJzZWRUb2tlbjtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUGFydGlhbFVzZWQgPSBNYXRoLmNlaWwocHJldmlvdXNVc2VkVG9rZW5zICogKDEgLSBwZXJjZW50YWdlSW5DdXJyZW50KSk7XG4gICAgICAgIGNvbnN0IHVzZWRUb2tlbnMgPSBwcmV2aW91c1BhcnRpYWxVc2VkICsgY3VycmVudFVzZWRUb2tlbnM7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRva2VucyAtIHVzZWRUb2tlbnM7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoZGJzLm1hcCgocykgPT4gcy5yZXF1ZXN0KSk7XG4gICAgICAgICAgY29uc3QgYWxsQ3VycmVudElkcyA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICBuZXcgU2V0KFxuICAgICAgICAgICAgICByZXMuZmxhdE1hcCgoW2N1cnJlbnQyXSkgPT4gY3VycmVudDIpLnJlZHVjZSgoYWNjLCBjdXJyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgICkudmFsdWVzKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgZGIgb2YgZGJzKSB7XG4gICAgICAgICAgICBjb25zdCBbY3VycmVudDIsIF9wcmV2aW91cywgX3N1Y2Nlc3NdID0gYXdhaXQgZGIucmVxdWVzdDtcbiAgICAgICAgICAgIGNvbnN0IGRiSWRzID0gY3VycmVudDIucmVkdWNlKChpZHMsIGN1cnJlbnRJZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKGN1cnJlbnRJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZWREYlRva2VucyA9IGN1cnJlbnQyLnJlZHVjZSgoYWNjVG9rZW5zLCB1c2VkVG9rZW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBwYXJzZWRUb2tlbiA9IDA7XG4gICAgICAgICAgICAgIGlmIChpbmRleCAlIDIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRUb2tlbiA9IE51bWJlci5wYXJzZUludCh1c2VkVG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhY2NUb2tlbnMgKyBwYXJzZWRUb2tlbjtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKHVzZWREYlRva2VucyA+PSB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWxsQ3VycmVudElkcy5maWx0ZXIoKGlkKSA9PiAhZGJJZHMuaW5jbHVkZXMoaWQpKTtcbiAgICAgICAgICAgIGlmIChkaWZmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdElkMiBvZiBkaWZmKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGRiLnJlZGlzLmhzZXQoY3VycmVudEtleSwgeyBbcmVxdWVzdElkMl06IGluY3JlbWVudEJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNldCA9IChjdXJyZW50V2luZG93ICsgMSkgKiB3aW5kb3dEdXJhdGlvbjtcbiAgICAgICAgaWYgKGN0eC5jYWNoZSAmJiAhc3VjY2Vzcykge1xuICAgICAgICAgIGN0eC5jYWNoZS5ibG9ja1VudGlsKGlkZW50aWZpZXIsIHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IEJvb2xlYW4oc3VjY2VzcyksXG4gICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICByZW1haW5pbmc6IE1hdGgubWF4KDAsIHJlbWFpbmluZyksXG4gICAgICAgICAgcmVzZXQsXG4gICAgICAgICAgcGVuZGluZzogc3luYygpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXN5bmMgZ2V0UmVtYWluaW5nKGN0eCwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjdXJyZW50V2luZG93ID0gTWF0aC5mbG9vcihub3cgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgY29uc3QgY3VycmVudEtleSA9IFtpZGVudGlmaWVyLCBjdXJyZW50V2luZG93XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNXaW5kb3cgPSBjdXJyZW50V2luZG93IC0gMTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNLZXkgPSBbaWRlbnRpZmllciwgcHJldmlvdXNXaW5kb3ddLmpvaW4oXCI6XCIpO1xuICAgICAgICBjb25zdCBkYnMgPSBjdHgucmVnaW9uQ29udGV4dHMubWFwKChyZWdpb25Db250ZXh0KSA9PiAoe1xuICAgICAgICAgIHJlZGlzOiByZWdpb25Db250ZXh0LnJlZGlzLFxuICAgICAgICAgIHJlcXVlc3Q6IHNhZmVFdmFsKFxuICAgICAgICAgICAgcmVnaW9uQ29udGV4dCxcbiAgICAgICAgICAgIHNsaWRpbmdXaW5kb3dSZW1haW5pbmdUb2tlbnNTY3JpcHQsXG4gICAgICAgICAgICBcImdldFJlbWFpbmluZ0hhc2hcIixcbiAgICAgICAgICAgIFtjdXJyZW50S2V5LCBwcmV2aW91c0tleV0sXG4gICAgICAgICAgICBbbm93LCB3aW5kb3dTaXplXVxuICAgICAgICAgICAgLy8gbHVhIHNlZW1zIHRvIHJldHVybiBgMWAgZm9yIHRydWUgYW5kIGBudWxsYCBmb3IgZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdXNlZFRva2VucyA9IGF3YWl0IFByb21pc2UuYW55KGRicy5tYXAoKHMpID0+IHMucmVxdWVzdCkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdG9rZW5zIC0gdXNlZFRva2Vucyk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgcmVzZXRUb2tlbnMoY3R4LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBbaWRlbnRpZmllciwgXCIqXCJdLmpvaW4oXCI6XCIpO1xuICAgICAgICBpZiAoY3R4LmNhY2hlKSB7XG4gICAgICAgICAgY3R4LmNhY2hlLnBvcChpZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjdHgucmVnaW9uQ29udGV4dHMubWFwKChyZWdpb25Db250ZXh0KSA9PiB7XG4gICAgICAgICAgc2FmZUV2YWwoXG4gICAgICAgICAgICByZWdpb25Db250ZXh0LFxuICAgICAgICAgICAgcmVzZXRTY3JpcHQsXG4gICAgICAgICAgICBcInJlc2V0SGFzaFwiLFxuICAgICAgICAgICAgW3BhdHRlcm5dLFxuICAgICAgICAgICAgW251bGxdXG4gICAgICAgICAgKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbHVhLXNjcmlwdHMvc2luZ2xlLnRzXG52YXIgZml4ZWRXaW5kb3dMaW1pdFNjcmlwdDIgPSBgXG4gIGxvY2FsIGtleSAgICAgICAgICAgPSBLRVlTWzFdXG4gIGxvY2FsIHdpbmRvdyAgICAgICAgPSBBUkdWWzFdXG4gIGxvY2FsIGluY3JlbWVudEJ5ICAgPSBBUkdWWzJdIC0tIGluY3JlbWVudCByYXRlIHBlciByZXF1ZXN0IGF0IGEgZ2l2ZW4gdmFsdWUsIGRlZmF1bHQgaXMgMVxuXG4gIGxvY2FsIHIgPSByZWRpcy5jYWxsKFwiSU5DUkJZXCIsIGtleSwgaW5jcmVtZW50QnkpXG4gIGlmIHIgPT0gdG9udW1iZXIoaW5jcmVtZW50QnkpIHRoZW5cbiAgLS0gVGhlIGZpcnN0IHRpbWUgdGhpcyBrZXkgaXMgc2V0LCB0aGUgdmFsdWUgd2lsbCBiZSBlcXVhbCB0byBpbmNyZW1lbnRCeS5cbiAgLS0gU28gd2Ugb25seSBuZWVkIHRoZSBleHBpcmUgY29tbWFuZCBvbmNlXG4gIHJlZGlzLmNhbGwoXCJQRVhQSVJFXCIsIGtleSwgd2luZG93KVxuICBlbmRcblxuICByZXR1cm4gclxuYDtcbnZhciBmaXhlZFdpbmRvd1JlbWFpbmluZ1Rva2Vuc1NjcmlwdDIgPSBgXG4gICAgICBsb2NhbCBrZXkgPSBLRVlTWzFdXG4gICAgICBsb2NhbCB0b2tlbnMgPSAwXG5cbiAgICAgIGxvY2FsIHZhbHVlID0gcmVkaXMuY2FsbCgnR0VUJywga2V5KVxuICAgICAgaWYgdmFsdWUgdGhlblxuICAgICAgICAgIHRva2VucyA9IHZhbHVlXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0b2tlbnNcbiAgICBgO1xudmFyIHNsaWRpbmdXaW5kb3dMaW1pdFNjcmlwdDIgPSBgXG4gIGxvY2FsIGN1cnJlbnRLZXkgID0gS0VZU1sxXSAgICAgICAgICAgLS0gaWRlbnRpZmllciBpbmNsdWRpbmcgcHJlZml4ZXNcbiAgbG9jYWwgcHJldmlvdXNLZXkgPSBLRVlTWzJdICAgICAgICAgICAtLSBrZXkgb2YgdGhlIHByZXZpb3VzIGJ1Y2tldFxuICBsb2NhbCB0b2tlbnMgICAgICA9IHRvbnVtYmVyKEFSR1ZbMV0pIC0tIHRva2VucyBwZXIgd2luZG93XG4gIGxvY2FsIG5vdyAgICAgICAgID0gQVJHVlsyXSAgICAgICAgICAgLS0gY3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gIGxvY2FsIHdpbmRvdyAgICAgID0gQVJHVlszXSAgICAgICAgICAgLS0gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gIGxvY2FsIGluY3JlbWVudEJ5ID0gQVJHVls0XSAgICAgICAgICAgLS0gaW5jcmVtZW50IHJhdGUgcGVyIHJlcXVlc3QgYXQgYSBnaXZlbiB2YWx1ZSwgZGVmYXVsdCBpcyAxXG5cbiAgbG9jYWwgcmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSByZWRpcy5jYWxsKFwiR0VUXCIsIGN1cnJlbnRLZXkpXG4gIGlmIHJlcXVlc3RzSW5DdXJyZW50V2luZG93ID09IGZhbHNlIHRoZW5cbiAgICByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyA9IDBcbiAgZW5kXG5cbiAgbG9jYWwgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gcmVkaXMuY2FsbChcIkdFVFwiLCBwcmV2aW91c0tleSlcbiAgaWYgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ID09IGZhbHNlIHRoZW5cbiAgICByZXF1ZXN0c0luUHJldmlvdXNXaW5kb3cgPSAwXG4gIGVuZFxuICBsb2NhbCBwZXJjZW50YWdlSW5DdXJyZW50ID0gKCBub3cgJSB3aW5kb3cgKSAvIHdpbmRvd1xuICAtLSB3ZWlnaHRlZCByZXF1ZXN0cyB0byBjb25zaWRlciBmcm9tIHRoZSBwcmV2aW91cyB3aW5kb3dcbiAgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gbWF0aC5mbG9vcigoIDEgLSBwZXJjZW50YWdlSW5DdXJyZW50ICkgKiByZXF1ZXN0c0luUHJldmlvdXNXaW5kb3cpXG4gIGlmIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyArIHJlcXVlc3RzSW5DdXJyZW50V2luZG93ID49IHRva2VucyB0aGVuXG4gICAgcmV0dXJuIC0xXG4gIGVuZFxuXG4gIGxvY2FsIG5ld1ZhbHVlID0gcmVkaXMuY2FsbChcIklOQ1JCWVwiLCBjdXJyZW50S2V5LCBpbmNyZW1lbnRCeSlcbiAgaWYgbmV3VmFsdWUgPT0gdG9udW1iZXIoaW5jcmVtZW50QnkpIHRoZW5cbiAgICAtLSBUaGUgZmlyc3QgdGltZSB0aGlzIGtleSBpcyBzZXQsIHRoZSB2YWx1ZSB3aWxsIGJlIGVxdWFsIHRvIGluY3JlbWVudEJ5LlxuICAgIC0tIFNvIHdlIG9ubHkgbmVlZCB0aGUgZXhwaXJlIGNvbW1hbmQgb25jZVxuICAgIHJlZGlzLmNhbGwoXCJQRVhQSVJFXCIsIGN1cnJlbnRLZXksIHdpbmRvdyAqIDIgKyAxMDAwKSAtLSBFbm91Z2ggdGltZSB0byBvdmVybGFwIHdpdGggYSBuZXcgd2luZG93ICsgMSBzZWNvbmRcbiAgZW5kXG4gIHJldHVybiB0b2tlbnMgLSAoIG5ld1ZhbHVlICsgcmVxdWVzdHNJblByZXZpb3VzV2luZG93IClcbmA7XG52YXIgc2xpZGluZ1dpbmRvd1JlbWFpbmluZ1Rva2Vuc1NjcmlwdDIgPSBgXG4gIGxvY2FsIGN1cnJlbnRLZXkgID0gS0VZU1sxXSAgICAgICAgICAgLS0gaWRlbnRpZmllciBpbmNsdWRpbmcgcHJlZml4ZXNcbiAgbG9jYWwgcHJldmlvdXNLZXkgPSBLRVlTWzJdICAgICAgICAgICAtLSBrZXkgb2YgdGhlIHByZXZpb3VzIGJ1Y2tldFxuICBsb2NhbCBub3cgICAgICAgICA9IEFSR1ZbMV0gICAgICAgICAgIC0tIGN1cnJlbnQgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICBsb2NhbCB3aW5kb3cgICAgICA9IEFSR1ZbMl0gICAgICAgICAgIC0tIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuXG4gIGxvY2FsIHJlcXVlc3RzSW5DdXJyZW50V2luZG93ID0gcmVkaXMuY2FsbChcIkdFVFwiLCBjdXJyZW50S2V5KVxuICBpZiByZXF1ZXN0c0luQ3VycmVudFdpbmRvdyA9PSBmYWxzZSB0aGVuXG4gICAgcmVxdWVzdHNJbkN1cnJlbnRXaW5kb3cgPSAwXG4gIGVuZFxuXG4gIGxvY2FsIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyA9IHJlZGlzLmNhbGwoXCJHRVRcIiwgcHJldmlvdXNLZXkpXG4gIGlmIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyA9PSBmYWxzZSB0aGVuXG4gICAgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gMFxuICBlbmRcblxuICBsb2NhbCBwZXJjZW50YWdlSW5DdXJyZW50ID0gKCBub3cgJSB3aW5kb3cgKSAvIHdpbmRvd1xuICAtLSB3ZWlnaHRlZCByZXF1ZXN0cyB0byBjb25zaWRlciBmcm9tIHRoZSBwcmV2aW91cyB3aW5kb3dcbiAgcmVxdWVzdHNJblByZXZpb3VzV2luZG93ID0gbWF0aC5mbG9vcigoIDEgLSBwZXJjZW50YWdlSW5DdXJyZW50ICkgKiByZXF1ZXN0c0luUHJldmlvdXNXaW5kb3cpXG5cbiAgcmV0dXJuIHJlcXVlc3RzSW5QcmV2aW91c1dpbmRvdyArIHJlcXVlc3RzSW5DdXJyZW50V2luZG93XG5gO1xudmFyIHRva2VuQnVja2V0TGltaXRTY3JpcHQgPSBgXG4gIGxvY2FsIGtleSAgICAgICAgID0gS0VZU1sxXSAgICAgICAgICAgLS0gaWRlbnRpZmllciBpbmNsdWRpbmcgcHJlZml4ZXNcbiAgbG9jYWwgbWF4VG9rZW5zICAgPSB0b251bWJlcihBUkdWWzFdKSAtLSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnNcbiAgbG9jYWwgaW50ZXJ2YWwgICAgPSB0b251bWJlcihBUkdWWzJdKSAtLSBzaXplIG9mIHRoZSB3aW5kb3cgaW4gbWlsbGlzZWNvbmRzXG4gIGxvY2FsIHJlZmlsbFJhdGUgID0gdG9udW1iZXIoQVJHVlszXSkgLS0gaG93IG1hbnkgdG9rZW5zIGFyZSByZWZpbGxlZCBhZnRlciBlYWNoIGludGVydmFsXG4gIGxvY2FsIG5vdyAgICAgICAgID0gdG9udW1iZXIoQVJHVls0XSkgLS0gY3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gIGxvY2FsIGluY3JlbWVudEJ5ID0gdG9udW1iZXIoQVJHVls1XSkgLS0gaG93IG1hbnkgdG9rZW5zIHRvIGNvbnN1bWUsIGRlZmF1bHQgaXMgMVxuICAgICAgICBcbiAgbG9jYWwgYnVja2V0ID0gcmVkaXMuY2FsbChcIkhNR0VUXCIsIGtleSwgXCJyZWZpbGxlZEF0XCIsIFwidG9rZW5zXCIpXG4gICAgICAgIFxuICBsb2NhbCByZWZpbGxlZEF0XG4gIGxvY2FsIHRva2Vuc1xuXG4gIGlmIGJ1Y2tldFsxXSA9PSBmYWxzZSB0aGVuXG4gICAgcmVmaWxsZWRBdCA9IG5vd1xuICAgIHRva2VucyA9IG1heFRva2Vuc1xuICBlbHNlXG4gICAgcmVmaWxsZWRBdCA9IHRvbnVtYmVyKGJ1Y2tldFsxXSlcbiAgICB0b2tlbnMgPSB0b251bWJlcihidWNrZXRbMl0pXG4gIGVuZFxuICAgICAgICBcbiAgaWYgbm93ID49IHJlZmlsbGVkQXQgKyBpbnRlcnZhbCB0aGVuXG4gICAgbG9jYWwgbnVtUmVmaWxscyA9IG1hdGguZmxvb3IoKG5vdyAtIHJlZmlsbGVkQXQpIC8gaW50ZXJ2YWwpXG4gICAgdG9rZW5zID0gbWF0aC5taW4obWF4VG9rZW5zLCB0b2tlbnMgKyBudW1SZWZpbGxzICogcmVmaWxsUmF0ZSlcblxuICAgIHJlZmlsbGVkQXQgPSByZWZpbGxlZEF0ICsgbnVtUmVmaWxscyAqIGludGVydmFsXG4gIGVuZFxuXG4gIGlmIHRva2VucyA9PSAwIHRoZW5cbiAgICByZXR1cm4gey0xLCByZWZpbGxlZEF0ICsgaW50ZXJ2YWx9XG4gIGVuZFxuXG4gIGxvY2FsIHJlbWFpbmluZyA9IHRva2VucyAtIGluY3JlbWVudEJ5XG4gIGxvY2FsIGV4cGlyZUF0ID0gbWF0aC5jZWlsKCgobWF4VG9rZW5zIC0gcmVtYWluaW5nKSAvIHJlZmlsbFJhdGUpKSAqIGludGVydmFsXG4gICAgICAgIFxuICByZWRpcy5jYWxsKFwiSFNFVFwiLCBrZXksIFwicmVmaWxsZWRBdFwiLCByZWZpbGxlZEF0LCBcInRva2Vuc1wiLCByZW1haW5pbmcpXG4gIHJlZGlzLmNhbGwoXCJQRVhQSVJFXCIsIGtleSwgZXhwaXJlQXQpXG4gIHJldHVybiB7cmVtYWluaW5nLCByZWZpbGxlZEF0ICsgaW50ZXJ2YWx9XG5gO1xudmFyIHRva2VuQnVja2V0UmVtYWluaW5nVG9rZW5zU2NyaXB0ID0gYFxuICBsb2NhbCBrZXkgICAgICAgICA9IEtFWVNbMV1cbiAgbG9jYWwgbWF4VG9rZW5zICAgPSB0b251bWJlcihBUkdWWzFdKVxuICAgICAgICBcbiAgbG9jYWwgYnVja2V0ID0gcmVkaXMuY2FsbChcIkhNR0VUXCIsIGtleSwgXCJ0b2tlbnNcIilcblxuICBpZiBidWNrZXRbMV0gPT0gZmFsc2UgdGhlblxuICAgIHJldHVybiBtYXhUb2tlbnNcbiAgZW5kXG4gICAgICAgIFxuICByZXR1cm4gdG9udW1iZXIoYnVja2V0WzFdKVxuYDtcbnZhciBjYWNoZWRGaXhlZFdpbmRvd0xpbWl0U2NyaXB0ID0gYFxuICBsb2NhbCBrZXkgICAgID0gS0VZU1sxXVxuICBsb2NhbCB3aW5kb3cgID0gQVJHVlsxXVxuICBsb2NhbCBpbmNyZW1lbnRCeSAgID0gQVJHVlsyXSAtLSBpbmNyZW1lbnQgcmF0ZSBwZXIgcmVxdWVzdCBhdCBhIGdpdmVuIHZhbHVlLCBkZWZhdWx0IGlzIDFcblxuICBsb2NhbCByID0gcmVkaXMuY2FsbChcIklOQ1JCWVwiLCBrZXksIGluY3JlbWVudEJ5KVxuICBpZiByID09IGluY3JlbWVudEJ5IHRoZW5cbiAgLS0gVGhlIGZpcnN0IHRpbWUgdGhpcyBrZXkgaXMgc2V0LCB0aGUgdmFsdWUgd2lsbCBiZSBlcXVhbCB0byBpbmNyZW1lbnRCeS5cbiAgLS0gU28gd2Ugb25seSBuZWVkIHRoZSBleHBpcmUgY29tbWFuZCBvbmNlXG4gIHJlZGlzLmNhbGwoXCJQRVhQSVJFXCIsIGtleSwgd2luZG93KVxuICBlbmRcbiAgICAgIFxuICByZXR1cm4gclxuYDtcbnZhciBjYWNoZWRGaXhlZFdpbmRvd1JlbWFpbmluZ1Rva2VuU2NyaXB0ID0gYFxuICBsb2NhbCBrZXkgPSBLRVlTWzFdXG4gIGxvY2FsIHRva2VucyA9IDBcblxuICBsb2NhbCB2YWx1ZSA9IHJlZGlzLmNhbGwoJ0dFVCcsIGtleSlcbiAgaWYgdmFsdWUgdGhlblxuICAgICAgdG9rZW5zID0gdmFsdWVcbiAgZW5kXG4gIHJldHVybiB0b2tlbnNcbmA7XG5cbi8vIHNyYy9zaW5nbGUudHNcbnZhciBSZWdpb25SYXRlbGltaXQgPSBjbGFzcyBleHRlbmRzIFJhdGVsaW1pdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmF0ZWxpbWl0IGluc3RhbmNlIGJ5IHByb3ZpZGluZyBhIGBAdXBzdGFzaC9yZWRpc2AgaW5zdGFuY2UgYW5kIHRoZSBhbGdvcml0aG0gb2YgeW91ciBjaG9pY2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcih7XG4gICAgICBwcmVmaXg6IGNvbmZpZy5wcmVmaXgsXG4gICAgICBsaW1pdGVyOiBjb25maWcubGltaXRlcixcbiAgICAgIHRpbWVvdXQ6IGNvbmZpZy50aW1lb3V0LFxuICAgICAgYW5hbHl0aWNzOiBjb25maWcuYW5hbHl0aWNzLFxuICAgICAgY3R4OiB7XG4gICAgICAgIHJlZGlzOiBjb25maWcucmVkaXMsXG4gICAgICAgIHNjcmlwdEhhc2hlczoge30sXG4gICAgICAgIGNhY2hlU2NyaXB0czogY29uZmlnLmNhY2hlU2NyaXB0cyA/PyB0cnVlXG4gICAgICB9LFxuICAgICAgZXBoZW1lcmFsQ2FjaGU6IGNvbmZpZy5lcGhlbWVyYWxDYWNoZSxcbiAgICAgIGVuYWJsZVByb3RlY3Rpb246IGNvbmZpZy5lbmFibGVQcm90ZWN0aW9uLFxuICAgICAgZGVueUxpc3RUaHJlc2hvbGQ6IGNvbmZpZy5kZW55TGlzdFRocmVzaG9sZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFYWNoIHJlcXVlc3QgaW5zaWRlIGEgZml4ZWQgdGltZSBpbmNyZWFzZXMgYSBjb3VudGVyLlxuICAgKiBPbmNlIHRoZSBjb3VudGVyIHJlYWNoZXMgdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIsIGFsbCBmdXJ0aGVyIHJlcXVlc3RzIGFyZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogKipQcm86KipcbiAgICpcbiAgICogLSBOZXdlciByZXF1ZXN0cyBhcmUgbm90IHN0YXJ2ZWQgYnkgb2xkIG9uZXMuXG4gICAqIC0gTG93IHN0b3JhZ2UgY29zdC5cbiAgICpcbiAgICogKipDb246KipcbiAgICpcbiAgICogQSBidXJzdCBvZiByZXF1ZXN0cyBuZWFyIHRoZSBib3VuZGFyeSBvZiBhIHdpbmRvdyBjYW4gcmVzdWx0IGluIGEgdmVyeVxuICAgKiBoaWdoIHJlcXVlc3QgcmF0ZSBiZWNhdXNlIHR3byB3aW5kb3dzIHdpbGwgYmUgZmlsbGVkIHdpdGggcmVxdWVzdHMgcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHRva2VucyAtIEhvdyBtYW55IHJlcXVlc3RzIGEgdXNlciBjYW4gbWFrZSBpbiBlYWNoIHRpbWUgd2luZG93LlxuICAgKiBAcGFyYW0gd2luZG93IC0gQSBmaXhlZCB0aW1lZnJhbWVcbiAgICovXG4gIHN0YXRpYyBmaXhlZFdpbmRvdyh0b2tlbnMsIHdpbmRvdykge1xuICAgIGNvbnN0IHdpbmRvd0R1cmF0aW9uID0gbXMod2luZG93KTtcbiAgICByZXR1cm4gKCkgPT4gKHtcbiAgICAgIGFzeW5jIGxpbWl0KGN0eCwgaWRlbnRpZmllciwgcmF0ZSkge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyB3aW5kb3dEdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGtleSA9IFtpZGVudGlmaWVyLCBidWNrZXRdLmpvaW4oXCI6XCIpO1xuICAgICAgICBpZiAoY3R4LmNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgeyBibG9ja2VkLCByZXNldDogcmVzZXQyIH0gPSBjdHguY2FjaGUuaXNCbG9ja2VkKGlkZW50aWZpZXIpO1xuICAgICAgICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICByZXNldDogcmVzZXQyLFxuICAgICAgICAgICAgICBwZW5kaW5nOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgcmVhc29uOiBcImNhY2hlQmxvY2tcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5jcmVtZW50QnkgPSByYXRlID8gTWF0aC5tYXgoMSwgcmF0ZSkgOiAxO1xuICAgICAgICBjb25zdCB1c2VkVG9rZW5zQWZ0ZXJVcGRhdGUgPSBhd2FpdCBzYWZlRXZhbChcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgZml4ZWRXaW5kb3dMaW1pdFNjcmlwdDIsXG4gICAgICAgICAgXCJsaW1pdEhhc2hcIixcbiAgICAgICAgICBba2V5XSxcbiAgICAgICAgICBbd2luZG93RHVyYXRpb24sIGluY3JlbWVudEJ5XVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gdXNlZFRva2Vuc0FmdGVyVXBkYXRlIDw9IHRva2VucztcbiAgICAgICAgY29uc3QgcmVtYWluaW5nVG9rZW5zID0gTWF0aC5tYXgoMCwgdG9rZW5zIC0gdXNlZFRva2Vuc0FmdGVyVXBkYXRlKTtcbiAgICAgICAgY29uc3QgcmVzZXQgPSAoYnVja2V0ICsgMSkgKiB3aW5kb3dEdXJhdGlvbjtcbiAgICAgICAgaWYgKGN0eC5jYWNoZSAmJiAhc3VjY2Vzcykge1xuICAgICAgICAgIGN0eC5jYWNoZS5ibG9ja1VudGlsKGlkZW50aWZpZXIsIHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICByZW1haW5pbmc6IHJlbWFpbmluZ1Rva2VucyxcbiAgICAgICAgICByZXNldCxcbiAgICAgICAgICBwZW5kaW5nOiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGdldFJlbWFpbmluZyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gd2luZG93RHVyYXRpb24pO1xuICAgICAgICBjb25zdCBrZXkgPSBbaWRlbnRpZmllciwgYnVja2V0XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgdXNlZFRva2VucyA9IGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICBmaXhlZFdpbmRvd1JlbWFpbmluZ1Rva2Vuc1NjcmlwdDIsXG4gICAgICAgICAgXCJnZXRSZW1haW5pbmdIYXNoXCIsXG4gICAgICAgICAgW2tleV0sXG4gICAgICAgICAgW251bGxdXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0b2tlbnMgLSB1c2VkVG9rZW5zKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyByZXNldFRva2VucyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IFtpZGVudGlmaWVyLCBcIipcIl0uam9pbihcIjpcIik7XG4gICAgICAgIGlmIChjdHguY2FjaGUpIHtcbiAgICAgICAgICBjdHguY2FjaGUucG9wKGlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICByZXNldFNjcmlwdCxcbiAgICAgICAgICBcInJlc2V0SGFzaFwiLFxuICAgICAgICAgIFtwYXR0ZXJuXSxcbiAgICAgICAgICBbbnVsbF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tYmluZWQgYXBwcm9hY2ggb2YgYHNsaWRpbmdMb2dzYCBhbmQgYGZpeGVkV2luZG93YCB3aXRoIGxvd2VyIHN0b3JhZ2VcbiAgICogY29zdHMgdGhhbiBgc2xpZGluZ0xvZ3NgIGFuZCBpbXByb3ZlZCBib3VuZGFyeSBiZWhhdmlvciBieSBjYWxjdWxhdGluZyBhXG4gICAqIHdlaWdodGVkIHNjb3JlIGJldHdlZW4gdHdvIHdpbmRvd3MuXG4gICAqXG4gICAqICoqUHJvOioqXG4gICAqXG4gICAqIEdvb2QgcGVyZm9ybWFuY2UgYWxsb3dzIHRoaXMgdG8gc2NhbGUgdG8gdmVyeSBoaWdoIGxvYWRzLlxuICAgKlxuICAgKiAqKkNvbjoqKlxuICAgKlxuICAgKiBOb3RoaW5nIG1ham9yLlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5zIC0gSG93IG1hbnkgcmVxdWVzdHMgYSB1c2VyIGNhbiBtYWtlIGluIGVhY2ggdGltZSB3aW5kb3cuXG4gICAqIEBwYXJhbSB3aW5kb3cgLSBUaGUgZHVyYXRpb24gaW4gd2hpY2ggdGhlIHVzZXIgY2FuIG1heCBYIHJlcXVlc3RzLlxuICAgKi9cbiAgc3RhdGljIHNsaWRpbmdXaW5kb3codG9rZW5zLCB3aW5kb3cpIHtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gbXMod2luZG93KTtcbiAgICByZXR1cm4gKCkgPT4gKHtcbiAgICAgIGFzeW5jIGxpbWl0KGN0eCwgaWRlbnRpZmllciwgcmF0ZSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjdXJyZW50V2luZG93ID0gTWF0aC5mbG9vcihub3cgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgY29uc3QgY3VycmVudEtleSA9IFtpZGVudGlmaWVyLCBjdXJyZW50V2luZG93XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNXaW5kb3cgPSBjdXJyZW50V2luZG93IC0gMTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNLZXkgPSBbaWRlbnRpZmllciwgcHJldmlvdXNXaW5kb3ddLmpvaW4oXCI6XCIpO1xuICAgICAgICBpZiAoY3R4LmNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgeyBibG9ja2VkLCByZXNldDogcmVzZXQyIH0gPSBjdHguY2FjaGUuaXNCbG9ja2VkKGlkZW50aWZpZXIpO1xuICAgICAgICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICByZXNldDogcmVzZXQyLFxuICAgICAgICAgICAgICBwZW5kaW5nOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgcmVhc29uOiBcImNhY2hlQmxvY2tcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5jcmVtZW50QnkgPSByYXRlID8gTWF0aC5tYXgoMSwgcmF0ZSkgOiAxO1xuICAgICAgICBjb25zdCByZW1haW5pbmdUb2tlbnMgPSBhd2FpdCBzYWZlRXZhbChcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgc2xpZGluZ1dpbmRvd0xpbWl0U2NyaXB0MixcbiAgICAgICAgICBcImxpbWl0SGFzaFwiLFxuICAgICAgICAgIFtjdXJyZW50S2V5LCBwcmV2aW91c0tleV0sXG4gICAgICAgICAgW3Rva2Vucywgbm93LCB3aW5kb3dTaXplLCBpbmNyZW1lbnRCeV1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJlbWFpbmluZ1Rva2VucyA+PSAwO1xuICAgICAgICBjb25zdCByZXNldCA9IChjdXJyZW50V2luZG93ICsgMSkgKiB3aW5kb3dTaXplO1xuICAgICAgICBpZiAoY3R4LmNhY2hlICYmICFzdWNjZXNzKSB7XG4gICAgICAgICAgY3R4LmNhY2hlLmJsb2NrVW50aWwoaWRlbnRpZmllciwgcmVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICBsaW1pdDogdG9rZW5zLFxuICAgICAgICAgIHJlbWFpbmluZzogTWF0aC5tYXgoMCwgcmVtYWluaW5nVG9rZW5zKSxcbiAgICAgICAgICByZXNldCxcbiAgICAgICAgICBwZW5kaW5nOiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGdldFJlbWFpbmluZyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgY3VycmVudFdpbmRvdyA9IE1hdGguZmxvb3Iobm93IC8gd2luZG93U2l6ZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBbaWRlbnRpZmllciwgY3VycmVudFdpbmRvd10uam9pbihcIjpcIik7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzV2luZG93ID0gY3VycmVudFdpbmRvdyAtIDE7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gW2lkZW50aWZpZXIsIHByZXZpb3VzV2luZG93XS5qb2luKFwiOlwiKTtcbiAgICAgICAgY29uc3QgdXNlZFRva2VucyA9IGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICBzbGlkaW5nV2luZG93UmVtYWluaW5nVG9rZW5zU2NyaXB0MixcbiAgICAgICAgICBcImdldFJlbWFpbmluZ0hhc2hcIixcbiAgICAgICAgICBbY3VycmVudEtleSwgcHJldmlvdXNLZXldLFxuICAgICAgICAgIFtub3csIHdpbmRvd1NpemVdXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0b2tlbnMgLSB1c2VkVG9rZW5zKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyByZXNldFRva2VucyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IFtpZGVudGlmaWVyLCBcIipcIl0uam9pbihcIjpcIik7XG4gICAgICAgIGlmIChjdHguY2FjaGUpIHtcbiAgICAgICAgICBjdHguY2FjaGUucG9wKGlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICByZXNldFNjcmlwdCxcbiAgICAgICAgICBcInJlc2V0SGFzaFwiLFxuICAgICAgICAgIFtwYXR0ZXJuXSxcbiAgICAgICAgICBbbnVsbF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogWW91IGhhdmUgYSBidWNrZXQgZmlsbGVkIHdpdGggYHttYXhUb2tlbnN9YCB0b2tlbnMgdGhhdCByZWZpbGxzIGNvbnN0YW50bHlcbiAgICogYXQgYHtyZWZpbGxSYXRlfWAgcGVyIGB7aW50ZXJ2YWx9YC5cbiAgICogRXZlcnkgcmVxdWVzdCB3aWxsIHJlbW92ZSBvbmUgdG9rZW4gZnJvbSB0aGUgYnVja2V0IGFuZCBpZiB0aGVyZSBpcyBub1xuICAgKiB0b2tlbiB0byB0YWtlLCB0aGUgcmVxdWVzdCBpcyByZWplY3RlZC5cbiAgICpcbiAgICogKipQcm86KipcbiAgICpcbiAgICogLSBCdXJzdHMgb2YgcmVxdWVzdHMgYXJlIHNtb290aGVkIG91dCBhbmQgeW91IGNhbiBwcm9jZXNzIHRoZW0gYXQgYSBjb25zdGFudFxuICAgKiByYXRlLlxuICAgKiAtIEFsbG93cyB0byBzZXQgYSBoaWdoZXIgaW5pdGlhbCBidXJzdCBsaW1pdCBieSBzZXR0aW5nIGBtYXhUb2tlbnNgIGhpZ2hlclxuICAgKiB0aGFuIGByZWZpbGxSYXRlYFxuICAgKi9cbiAgc3RhdGljIHRva2VuQnVja2V0KHJlZmlsbFJhdGUsIGludGVydmFsLCBtYXhUb2tlbnMpIHtcbiAgICBjb25zdCBpbnRlcnZhbER1cmF0aW9uID0gbXMoaW50ZXJ2YWwpO1xuICAgIHJldHVybiAoKSA9PiAoe1xuICAgICAgYXN5bmMgbGltaXQoY3R4LCBpZGVudGlmaWVyLCByYXRlKSB7XG4gICAgICAgIGlmIChjdHguY2FjaGUpIHtcbiAgICAgICAgICBjb25zdCB7IGJsb2NrZWQsIHJlc2V0OiByZXNldDIgfSA9IGN0eC5jYWNoZS5pc0Jsb2NrZWQoaWRlbnRpZmllcik7XG4gICAgICAgICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBsaW1pdDogbWF4VG9rZW5zLFxuICAgICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICAgIHJlc2V0OiByZXNldDIsXG4gICAgICAgICAgICAgIHBlbmRpbmc6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgICAgICByZWFzb246IFwiY2FjaGVCbG9ja1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBpbmNyZW1lbnRCeSA9IHJhdGUgPyBNYXRoLm1heCgxLCByYXRlKSA6IDE7XG4gICAgICAgIGNvbnN0IFtyZW1haW5pbmcsIHJlc2V0XSA9IGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB0b2tlbkJ1Y2tldExpbWl0U2NyaXB0LFxuICAgICAgICAgIFwibGltaXRIYXNoXCIsXG4gICAgICAgICAgW2lkZW50aWZpZXJdLFxuICAgICAgICAgIFttYXhUb2tlbnMsIGludGVydmFsRHVyYXRpb24sIHJlZmlsbFJhdGUsIG5vdywgaW5jcmVtZW50QnldXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSByZW1haW5pbmcgPj0gMDtcbiAgICAgICAgaWYgKGN0eC5jYWNoZSAmJiAhc3VjY2Vzcykge1xuICAgICAgICAgIGN0eC5jYWNoZS5ibG9ja1VudGlsKGlkZW50aWZpZXIsIHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgbGltaXQ6IG1heFRva2VucyxcbiAgICAgICAgICByZW1haW5pbmcsXG4gICAgICAgICAgcmVzZXQsXG4gICAgICAgICAgcGVuZGluZzogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBnZXRSZW1haW5pbmcoY3R4LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1Rva2VucyA9IGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB0b2tlbkJ1Y2tldFJlbWFpbmluZ1Rva2Vuc1NjcmlwdCxcbiAgICAgICAgICBcImdldFJlbWFpbmluZ0hhc2hcIixcbiAgICAgICAgICBbaWRlbnRpZmllcl0sXG4gICAgICAgICAgW21heFRva2Vuc11cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ1Rva2VucztcbiAgICAgIH0sXG4gICAgICBhc3luYyByZXNldFRva2VucyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGlkZW50aWZpZXI7XG4gICAgICAgIGlmIChjdHguY2FjaGUpIHtcbiAgICAgICAgICBjdHguY2FjaGUucG9wKGlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICByZXNldFNjcmlwdCxcbiAgICAgICAgICBcInJlc2V0SGFzaFwiLFxuICAgICAgICAgIFtwYXR0ZXJuXSxcbiAgICAgICAgICBbbnVsbF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogY2FjaGVkRml4ZWRXaW5kb3cgZmlyc3QgdXNlcyB0aGUgbG9jYWwgY2FjaGUgdG8gZGVjaWRlIGlmIGEgcmVxdWVzdCBtYXkgcGFzcyBhbmQgdGhlbiB1cGRhdGVzXG4gICAqIGl0IGFzeW5jaHJvbm91c2x5LlxuICAgKiBUaGlzIGlzIGV4cGVyaW1lbnRhbCBhbmQgbm90IHlldCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiB1c2UuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICpcbiAgICogRWFjaCByZXF1ZXN0IGluc2lkZSBhIGZpeGVkIHRpbWUgaW5jcmVhc2VzIGEgY291bnRlci5cbiAgICogT25jZSB0aGUgY291bnRlciByZWFjaGVzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyLCBhbGwgZnVydGhlciByZXF1ZXN0cyBhcmVcbiAgICogcmVqZWN0ZWQuXG4gICAqXG4gICAqICoqUHJvOioqXG4gICAqXG4gICAqIC0gTmV3ZXIgcmVxdWVzdHMgYXJlIG5vdCBzdGFydmVkIGJ5IG9sZCBvbmVzLlxuICAgKiAtIExvdyBzdG9yYWdlIGNvc3QuXG4gICAqXG4gICAqICoqQ29uOioqXG4gICAqXG4gICAqIEEgYnVyc3Qgb2YgcmVxdWVzdHMgbmVhciB0aGUgYm91bmRhcnkgb2YgYSB3aW5kb3cgY2FuIHJlc3VsdCBpbiBhIHZlcnlcbiAgICogaGlnaCByZXF1ZXN0IHJhdGUgYmVjYXVzZSB0d28gd2luZG93cyB3aWxsIGJlIGZpbGxlZCB3aXRoIHJlcXVlc3RzIHF1aWNrbHkuXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbnMgLSBIb3cgbWFueSByZXF1ZXN0cyBhIHVzZXIgY2FuIG1ha2UgaW4gZWFjaCB0aW1lIHdpbmRvdy5cbiAgICogQHBhcmFtIHdpbmRvdyAtIEEgZml4ZWQgdGltZWZyYW1lXG4gICAqL1xuICBzdGF0aWMgY2FjaGVkRml4ZWRXaW5kb3codG9rZW5zLCB3aW5kb3cpIHtcbiAgICBjb25zdCB3aW5kb3dEdXJhdGlvbiA9IG1zKHdpbmRvdyk7XG4gICAgcmV0dXJuICgpID0+ICh7XG4gICAgICBhc3luYyBsaW1pdChjdHgsIGlkZW50aWZpZXIsIHJhdGUpIHtcbiAgICAgICAgaWYgKCFjdHguY2FjaGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGFsZ29yaXRobSByZXF1aXJlcyBhIGNhY2hlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIHdpbmRvd0R1cmF0aW9uKTtcbiAgICAgICAgY29uc3Qga2V5ID0gW2lkZW50aWZpZXIsIGJ1Y2tldF0uam9pbihcIjpcIik7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKGJ1Y2tldCArIDEpICogd2luZG93RHVyYXRpb247XG4gICAgICAgIGNvbnN0IGluY3JlbWVudEJ5ID0gcmF0ZSA/IE1hdGgubWF4KDEsIHJhdGUpIDogMTtcbiAgICAgICAgY29uc3QgaGl0ID0gdHlwZW9mIGN0eC5jYWNoZS5nZXQoa2V5KSA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlZFRva2Vuc0FmdGVyVXBkYXRlID0gY3R4LmNhY2hlLmluY3Ioa2V5KTtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gY2FjaGVkVG9rZW5zQWZ0ZXJVcGRhdGUgPCB0b2tlbnM7XG4gICAgICAgICAgY29uc3QgcGVuZGluZyA9IHN1Y2Nlc3MgPyBzYWZlRXZhbChcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIGNhY2hlZEZpeGVkV2luZG93TGltaXRTY3JpcHQsXG4gICAgICAgICAgICBcImxpbWl0SGFzaFwiLFxuICAgICAgICAgICAgW2tleV0sXG4gICAgICAgICAgICBbd2luZG93RHVyYXRpb24sIGluY3JlbWVudEJ5XVxuICAgICAgICAgICkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgIGxpbWl0OiB0b2tlbnMsXG4gICAgICAgICAgICByZW1haW5pbmc6IHRva2VucyAtIGNhY2hlZFRva2Vuc0FmdGVyVXBkYXRlLFxuICAgICAgICAgICAgcmVzZXQsXG4gICAgICAgICAgICBwZW5kaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VkVG9rZW5zQWZ0ZXJVcGRhdGUgPSBhd2FpdCBzYWZlRXZhbChcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgY2FjaGVkRml4ZWRXaW5kb3dMaW1pdFNjcmlwdCxcbiAgICAgICAgICBcImxpbWl0SGFzaFwiLFxuICAgICAgICAgIFtrZXldLFxuICAgICAgICAgIFt3aW5kb3dEdXJhdGlvbiwgaW5jcmVtZW50QnldXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5jYWNoZS5zZXQoa2V5LCB1c2VkVG9rZW5zQWZ0ZXJVcGRhdGUpO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0b2tlbnMgLSB1c2VkVG9rZW5zQWZ0ZXJVcGRhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogcmVtYWluaW5nID49IDAsXG4gICAgICAgICAgbGltaXQ6IHRva2VucyxcbiAgICAgICAgICByZW1haW5pbmcsXG4gICAgICAgICAgcmVzZXQsXG4gICAgICAgICAgcGVuZGluZzogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBnZXRSZW1haW5pbmcoY3R4LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghY3R4LmNhY2hlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBhbGdvcml0aG0gcmVxdWlyZXMgYSBjYWNoZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyB3aW5kb3dEdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGtleSA9IFtpZGVudGlmaWVyLCBidWNrZXRdLmpvaW4oXCI6XCIpO1xuICAgICAgICBjb25zdCBoaXQgPSB0eXBlb2YgY3R4LmNhY2hlLmdldChrZXkpID09PSBcIm51bWJlclwiO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVkVXNlZFRva2VucyA9IGN0eC5jYWNoZS5nZXQoa2V5KSA/PyAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0b2tlbnMgLSBjYWNoZWRVc2VkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VkVG9rZW5zID0gYXdhaXQgc2FmZUV2YWwoXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIGNhY2hlZEZpeGVkV2luZG93UmVtYWluaW5nVG9rZW5TY3JpcHQsXG4gICAgICAgICAgXCJnZXRSZW1haW5pbmdIYXNoXCIsXG4gICAgICAgICAgW2tleV0sXG4gICAgICAgICAgW251bGxdXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0b2tlbnMgLSB1c2VkVG9rZW5zKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyByZXNldFRva2VucyhjdHgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKCFjdHguY2FjaGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGFsZ29yaXRobSByZXF1aXJlcyBhIGNhY2hlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIHdpbmRvd0R1cmF0aW9uKTtcbiAgICAgICAgY29uc3Qga2V5ID0gW2lkZW50aWZpZXIsIGJ1Y2tldF0uam9pbihcIjpcIik7XG4gICAgICAgIGN0eC5jYWNoZS5wb3Aoa2V5KTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IFtpZGVudGlmaWVyLCBcIipcIl0uam9pbihcIjpcIik7XG4gICAgICAgIGF3YWl0IHNhZmVFdmFsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICByZXNldFNjcmlwdCxcbiAgICAgICAgICBcInJlc2V0SGFzaFwiLFxuICAgICAgICAgIFtwYXR0ZXJuXSxcbiAgICAgICAgICBbbnVsbF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBbmFseXRpY3MsXG4gIElwRGVueUxpc3QsXG4gIE11bHRpUmVnaW9uUmF0ZWxpbWl0LFxuICBSYXRlbGltaXRcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@upstash/ratelimit/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@upstash/redis/chunk-DFUAPYBG.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@upstash/redis/chunk-DFUAPYBG.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ ze),\n/* harmony export */   b: () => (/* binding */ Me),\n/* harmony export */   c: () => (/* binding */ Ie),\n/* harmony export */   d: () => (/* binding */ tg)\n/* harmony export */ });\n/* harmony import */ var crypto_js_enc_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js/enc-hex.js */ \"(action-browser)/./node_modules/crypto-js/enc-hex.js\");\n/* harmony import */ var crypto_js_sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js/sha1.js */ \"(action-browser)/./node_modules/crypto-js/sha1.js\");\nvar Ne=Object.defineProperty;var Le=(s,n)=>{for(var t in n)Ne(s,t,{get:n[t],enumerable:!0})};var ze={};Le(ze,{UpstashError:()=>u,UrlError:()=>Oe});var u=class extends Error{constructor(n){super(n),this.name=\"UpstashError\"}},Oe=class extends Error{constructor(n){super(`Upstash Redis client was passed an invalid URL. You should pass the URL together with https. Received: \"${n}\". `),this.name=\"UrlError\"}};var Me=class{baseUrl;headers;options;retry;constructor(n){if(this.options={backend:n.options?.backend,agent:n.agent,responseEncoding:n.responseEncoding??\"base64\",cache:n.cache,signal:n.signal,keepAlive:n.keepAlive??!0},this.baseUrl=n.baseUrl.replace(/\\/$/,\"\"),!/^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/.test(this.baseUrl))throw new Oe(this.baseUrl);this.headers={\"Content-Type\":\"application/json\",...n.headers},this.options.responseEncoding===\"base64\"&&(this.headers[\"Upstash-Encoding\"]=\"base64\"),typeof n?.retry==\"boolean\"&&n?.retry===!1?this.retry={attempts:1,backoff:()=>0}:this.retry={attempts:n?.retry?.retries??5,backoff:n?.retry?.backoff??(o=>Math.exp(o)*50)}}mergeTelemetry(n){function t(o,m,r){return r&&(o[m]?o[m]=[o[m],r].join(\",\"):o[m]=r),o}this.headers=t(this.headers,\"Upstash-Telemetry-Runtime\",n.runtime),this.headers=t(this.headers,\"Upstash-Telemetry-Platform\",n.platform),this.headers=t(this.headers,\"Upstash-Telemetry-Sdk\",n.sdk)}async request(n){let t={cache:this.options.cache,method:\"POST\",headers:this.headers,body:JSON.stringify(n.body),keepalive:this.options.keepAlive,agent:this.options?.agent,signal:this.options.signal,backend:this.options?.backend},o=null,m=null;for(let a=0;a<=this.retry.attempts;a++)try{o=await fetch([this.baseUrl,...n.path??[]].join(\"/\"),t);break}catch(i){if(this.options.signal?.aborted){let p=new Blob([JSON.stringify({result:this.options.signal.reason??\"Aborted\"})]),d={status:200,statusText:this.options.signal.reason??\"Aborted\"};o=new Response(p,d);break}m=i,await new Promise(p=>setTimeout(p,this.retry.backoff(a)))}if(!o)throw m??new Error(\"Exhausted all retries\");let r=await o.json();if(!o.ok)throw new u(`${r.error}, command was: ${JSON.stringify(n.body)}`);return this.options?.responseEncoding===\"base64\"?Array.isArray(r)?r.map(({result:i,error:p})=>({result:ke(i),error:p})):{result:ke(r.result),error:r.error}:r}};function ve(s){let n=\"\";try{let t=atob(s),o=t.length,m=new Uint8Array(o);for(let r=0;r<o;r++)m[r]=t.charCodeAt(r);n=new TextDecoder().decode(m)}catch{n=s}return n}function ke(s){let n;switch(typeof s){case\"undefined\":return s;case\"number\":{n=s;break}case\"object\":{Array.isArray(s)?n=s.map(t=>typeof t==\"string\"?ve(t):Array.isArray(t)?t.map(ke):t):n=null;break}case\"string\":{n=s===\"OK\"?\"OK\":ve(s);break}default:break}return n}function Se(s,n){let t=s;return t.autoPipelineExecutor||(t.autoPipelineExecutor=new Re(t)),new Proxy(t,{get:(o,m)=>m===\"pipelineCounter\"?o.autoPipelineExecutor.pipelineCounter:m===\"json\"?Se(o,!0):m in o&&!(m in o.autoPipelineExecutor.pipeline)?o[m]:(n?typeof o.autoPipelineExecutor.pipeline.json[m]==\"function\":typeof o.autoPipelineExecutor.pipeline[m]==\"function\")?(...i)=>o.autoPipelineExecutor.withAutoPipeline(p=>{n?p.json[m](...i):p[m](...i)}):o.autoPipelineExecutor.pipeline[m]})}var Re=class{pipelinePromises=new WeakMap;activePipeline=null;indexInCurrentPipeline=0;redis;pipeline;pipelineCounter=0;constructor(n){this.redis=n,this.pipeline=n.pipeline()}async withAutoPipeline(n){let t=this.activePipeline||this.redis.pipeline();this.activePipeline||(this.activePipeline=t,this.indexInCurrentPipeline=0);let o=this.indexInCurrentPipeline++;return n(t),(await this.deferExecution().then(()=>{if(!this.pipelinePromises.has(t)){let a=t.exec();this.pipelineCounter+=1,this.pipelinePromises.set(t,a),this.activePipeline=null}return this.pipelinePromises.get(t)}))[o]}async deferExecution(){return await Promise.resolve(),await Promise.resolve()}};function Pe(s){let n=Array.isArray(s)?s.map(t=>{try{return Pe(t)}catch{return t}}):JSON.parse(s);return typeof n==\"number\"&&n.toString()!==s?s:n}function Ee(s){try{return Pe(s)}catch{return s}}function h(s){return[s[0],...Ee(s.slice(1))]}var Ge=s=>{switch(typeof s){case\"string\":case\"number\":case\"boolean\":return s;default:return JSON.stringify(s)}},e=class{command;serialize;deserialize;constructor(n,t){if(this.serialize=Ge,this.deserialize=typeof t?.automaticDeserialization>\"u\"||t.automaticDeserialization?t?.deserialize??Ee:o=>o,this.command=n.map(o=>this.serialize(o)),t?.latencyLogging){let o=this.exec.bind(this);this.exec=async m=>{let r=performance.now(),a=await o(m),p=(performance.now()-r).toFixed(2);return console.log(`Latency for \\x1B[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\\x1B[0m: \\x1B[38;2;0;255;255m${p} ms\\x1B[0m`),a}}}async exec(n){let{result:t,error:o}=await n.request({body:this.command});if(o)throw new u(o);if(typeof t>\"u\")throw new Error(\"Request did not return a result\");return this.deserialize(t)}};var g=class extends e{constructor(n,t){super([\"append\",...n],t)}};var x=class extends e{constructor([n,t,o],m){let r=[\"bitcount\",n];typeof t==\"number\"&&r.push(t),typeof o==\"number\"&&r.push(o),super(r,m)}};var f=class{constructor(n,t,o,m=r=>r.exec(this.client)){this.client=t;this.opts=o;this.execOperation=m;this.command=[\"bitfield\",...n]}command;chain(...n){return this.command.push(...n),this}get(...n){return this.chain(\"get\",...n)}set(...n){return this.chain(\"set\",...n)}incrby(...n){return this.chain(\"incrby\",...n)}overflow(n){return this.chain(\"overflow\",n)}exec(){let n=new e(this.command,this.opts);return this.execOperation(n)}};var y=class extends e{constructor(n,t){super([\"bitop\",...n],t)}};var b=class extends e{constructor(n,t){super([\"bitpos\",...n],t)}};var T=class extends e{constructor([n,t,o],m){super([\"COPY\",n,t,...o?.replace?[\"REPLACE\"]:[]],{...m,deserialize(r){return r>0?\"COPIED\":\"NOT_COPIED\"}})}};var O=class extends e{constructor(n){super([\"dbsize\"],n)}};var w=class extends e{constructor(n,t){super([\"decr\",...n],t)}};var D=class extends e{constructor(n,t){super([\"decrby\",...n],t)}};var A=class extends e{constructor(n,t){super([\"del\",...n],t)}};var k=class extends e{constructor(n,t){super([\"echo\",...n],t)}};var R=class extends e{constructor([n,t,o],m){super([\"eval\",n,t.length,...t,...o??[]],m)}};var S=class extends e{constructor([n,t,o],m){super([\"evalsha\",n,t.length,...t,...o??[]],m)}};var E=class extends e{constructor(n,t){super([\"exists\",...n],t)}};var M=class extends e{constructor(n,t){super([\"expire\",...n.filter(Boolean)],t)}};var v=class extends e{constructor(n,t){super([\"expireat\",...n],t)}};var P=class extends e{constructor(n,t){let o=[\"flushall\"];n&&n.length>0&&n[0].async&&o.push(\"async\"),super(o,t)}};var I=class extends e{constructor([n],t){let o=[\"flushdb\"];n?.async&&o.push(\"async\"),super(o,t)}};var N=class extends e{constructor([n,t,...o],m){let r=[\"geoadd\",n];\"nx\"in t&&t.nx?r.push(\"nx\"):\"xx\"in t&&t.xx&&r.push(\"xx\"),\"ch\"in t&&t.ch&&r.push(\"ch\"),\"latitude\"in t&&t.latitude&&r.push(t.longitude,t.latitude,t.member),r.push(...o.flatMap(({latitude:a,longitude:i,member:p})=>[i,a,p])),super(r,m)}};var L=class extends e{constructor([n,t,o,m=\"M\"],r){super([\"GEODIST\",n,t,o,m],r)}};var z=class extends e{constructor(n,t){let[o]=n,m=Array.isArray(n[1])?n[1]:n.slice(1);super([\"GEOHASH\",o,...m],t)}};var G=class extends e{constructor(n,t){let[o]=n,m=Array.isArray(n[1])?n[1]:n.slice(1);super([\"GEOPOS\",o,...m],{deserialize:r=>Ke(r),...t})}};function Ke(s){let n=[];for(let t of s)!t?.[0]||!t?.[1]||n.push({lng:parseFloat(t[0]),lat:parseFloat(t[1])});return n}var K=class extends e{constructor([n,t,o,m,r],a){let i=[\"GEOSEARCH\",n];(t.type===\"FROMMEMBER\"||t.type===\"frommember\")&&i.push(t.type,t.member),(t.type===\"FROMLONLAT\"||t.type===\"fromlonlat\")&&i.push(t.type,t.coordinate.lon,t.coordinate.lat),(o.type===\"BYRADIUS\"||o.type===\"byradius\")&&i.push(o.type,o.radius,o.radiusType),(o.type===\"BYBOX\"||o.type===\"bybox\")&&i.push(o.type,o.rect.width,o.rect.height,o.rectType),i.push(m),r?.count&&i.push(\"COUNT\",r.count.limit,...r.count.any?[\"ANY\"]:[]);let p=d=>!r?.withCoord&&!r?.withDist&&!r?.withHash?d.map(c=>{try{return{member:JSON.parse(c)}}catch{return{member:c}}}):d.map(c=>{let De=1,C={};try{C.member=JSON.parse(c[0])}catch{C.member=c[0]}return r.withDist&&(C.dist=parseFloat(c[De++])),r.withHash&&(C.hash=c[De++].toString()),r.withCoord&&(C.coord={long:parseFloat(c[De][0]),lat:parseFloat(c[De][1])}),C});super([...i,...r?.withCoord?[\"WITHCOORD\"]:[],...r?.withDist?[\"WITHDIST\"]:[],...r?.withHash?[\"WITHHASH\"]:[]],{deserialize:p,...a})}};var X=class extends e{constructor([n,t,o,m,r,a],i){let p=[\"GEOSEARCHSTORE\",n,t];(o.type===\"FROMMEMBER\"||o.type===\"frommember\")&&p.push(o.type,o.member),(o.type===\"FROMLONLAT\"||o.type===\"fromlonlat\")&&p.push(o.type,o.coordinate.lon,o.coordinate.lat),(m.type===\"BYRADIUS\"||m.type===\"byradius\")&&p.push(m.type,m.radius,m.radiusType),(m.type===\"BYBOX\"||m.type===\"bybox\")&&p.push(m.type,m.rect.width,m.rect.height,m.rectType),p.push(r),a?.count&&p.push(\"COUNT\",a.count.limit,...a.count.any?[\"ANY\"]:[]),super([...p,...a?.storeDist?[\"STOREDIST\"]:[]],i)}};var U=class extends e{constructor(n,t){super([\"get\",...n],t)}};var J=class extends e{constructor(n,t){super([\"getbit\",...n],t)}};var B=class extends e{constructor(n,t){super([\"getdel\",...n],t)}};var Z=class extends e{constructor(n,t){super([\"getrange\",...n],t)}};var H=class extends e{constructor(n,t){super([\"getset\",...n],t)}};var F=class extends e{constructor(n,t){super([\"hdel\",...n],t)}};var $=class extends e{constructor(n,t){super([\"hexists\",...n],t)}};var q=class extends e{constructor(n,t){super([\"hget\",...n],t)}};function Xe(s){if(s.length===0)return null;let n={};for(;s.length>=2;){let t=s.shift(),o=s.shift();try{!Number.isNaN(Number(o))&&!Number.isSafeInteger(Number(o))?n[t]=o:n[t]=JSON.parse(o)}catch{n[t]=o}}return n}var j=class extends e{constructor(n,t){super([\"hgetall\",...n],{deserialize:o=>Xe(o),...t})}};var Y=class extends e{constructor(n,t){super([\"hincrby\",...n],t)}};var V=class extends e{constructor(n,t){super([\"hincrbyfloat\",...n],t)}};var _=class extends e{constructor([n],t){super([\"hkeys\",n],t)}};var W=class extends e{constructor(n,t){super([\"hlen\",...n],t)}};function Ue(s,n){if(n.length===0||n.every(o=>o===null))return null;let t={};for(let o=0;o<s.length;o++)try{t[s[o]]=JSON.parse(n[o])}catch{t[s[o]]=n[o]}return t}var Q=class extends e{constructor([n,...t],o){super([\"hmget\",n,...t],{deserialize:m=>Ue(t,m),...o})}};var nn=class extends e{constructor([n,t],o){super([\"hmset\",n,...Object.entries(t).flatMap(([m,r])=>[m,r])],o)}};function Je(s){if(s.length===0)return null;let n={};for(;s.length>=2;){let t=s.shift(),o=s.shift();try{n[t]=JSON.parse(o)}catch{n[t]=o}}return n}var tn=class extends e{constructor(n,t){let o=[\"hrandfield\",n[0]];typeof n[1]==\"number\"&&o.push(n[1]),n[2]&&o.push(\"WITHVALUES\"),super(o,{deserialize:n[2]?m=>Je(m):t?.deserialize,...t})}};var en=class extends e{constructor([n,t,o],m){let r=[\"hscan\",n,t];o?.match&&r.push(\"match\",o.match),typeof o?.count==\"number\"&&r.push(\"count\",o.count),super(r,{deserialize:h,...m})}};var on=class extends e{constructor([n,t],o){super([\"hset\",n,...Object.entries(t).flatMap(([m,r])=>[m,r])],o)}};var sn=class extends e{constructor(n,t){super([\"hsetnx\",...n],t)}};var mn=class extends e{constructor(n,t){super([\"hstrlen\",...n],t)}};var rn=class extends e{constructor(n,t){super([\"hvals\",...n],t)}};var an=class extends e{constructor(n,t){super([\"incr\",...n],t)}};var pn=class extends e{constructor(n,t){super([\"incrby\",...n],t)}};var dn=class extends e{constructor(n,t){super([\"incrbyfloat\",...n],t)}};var cn=class extends e{constructor(n,t){super([\"JSON.ARRAPPEND\",...n],t)}};var un=class extends e{constructor(n,t){super([\"JSON.ARRINDEX\",...n],t)}};var hn=class extends e{constructor(n,t){super([\"JSON.ARRINSERT\",...n],t)}};var ln=class extends e{constructor(n,t){super([\"JSON.ARRLEN\",n[0],n[1]??\"$\"],t)}};var Cn=class extends e{constructor(n,t){super([\"JSON.ARRPOP\",...n],t)}};var gn=class extends e{constructor(n,t){let o=n[1]??\"$\",m=n[2]??0,r=n[3]??0;super([\"JSON.ARRTRIM\",n[0],o,m,r],t)}};var xn=class extends e{constructor(n,t){super([\"JSON.CLEAR\",...n],t)}};var fn=class extends e{constructor(n,t){super([\"JSON.DEL\",...n],t)}};var yn=class extends e{constructor(n,t){super([\"JSON.FORGET\",...n],t)}};var bn=class extends e{constructor(n,t){let o=[\"JSON.GET\"];typeof n[1]==\"string\"?o.push(...n):(o.push(n[0]),n[1]&&(n[1].indent&&o.push(\"INDENT\",n[1].indent),n[1].newline&&o.push(\"NEWLINE\",n[1].newline),n[1].space&&o.push(\"SPACE\",n[1].space)),o.push(...n.slice(2))),super(o,t)}};var Tn=class extends e{constructor(n,t){super([\"JSON.MGET\",...n[0],n[1]],t)}};var On=class extends e{constructor(n,t){super([\"JSON.NUMINCRBY\",...n],t)}};var wn=class extends e{constructor(n,t){super([\"JSON.NUMMULTBY\",...n],t)}};var Dn=class extends e{constructor(n,t){super([\"JSON.OBJKEYS\",...n],t)}};var An=class extends e{constructor(n,t){super([\"JSON.OBJLEN\",...n],t)}};var kn=class extends e{constructor(n,t){super([\"JSON.RESP\",...n],t)}};var Rn=class extends e{constructor(n,t){let o=[\"JSON.SET\",n[0],n[1],n[2]];n[3]&&(n[3].nx?o.push(\"NX\"):n[3].xx&&o.push(\"XX\")),super(o,t)}};var Sn=class extends e{constructor(n,t){super([\"JSON.STRAPPEND\",...n],t)}};var En=class extends e{constructor(n,t){super([\"JSON.STRLEN\",...n],t)}};var Mn=class extends e{constructor(n,t){super([\"JSON.TOGGLE\",...n],t)}};var vn=class extends e{constructor(n,t){super([\"JSON.TYPE\",...n],t)}};var Pn=class extends e{constructor(n,t){super([\"keys\",...n],t)}};var In=class extends e{constructor(n,t){super([\"lindex\",...n],t)}};var Nn=class extends e{constructor(n,t){super([\"linsert\",...n],t)}};var Ln=class extends e{constructor(n,t){super([\"llen\",...n],t)}};var zn=class extends e{constructor(n,t){super([\"lmove\",...n],t)}};var Gn=class extends e{constructor(n,t){let[o,m,r,a]=n;super([\"LMPOP\",o,...m,r,...a?[\"COUNT\",a]:[]],t)}};var Kn=class extends e{constructor(n,t){super([\"lpop\",...n],t)}};var Xn=class extends e{constructor(n,t){let o=[\"lpos\",n[0],n[1]];typeof n[2]?.rank==\"number\"&&o.push(\"rank\",n[2].rank),typeof n[2]?.count==\"number\"&&o.push(\"count\",n[2].count),typeof n[2]?.maxLen==\"number\"&&o.push(\"maxLen\",n[2].maxLen),super(o,t)}};var Un=class extends e{constructor(n,t){super([\"lpush\",...n],t)}};var Jn=class extends e{constructor(n,t){super([\"lpushx\",...n],t)}};var Bn=class extends e{constructor(n,t){super([\"lrange\",...n],t)}};var Zn=class extends e{constructor(n,t){super([\"lrem\",...n],t)}};var Hn=class extends e{constructor(n,t){super([\"lset\",...n],t)}};var Fn=class extends e{constructor(n,t){super([\"ltrim\",...n],t)}};var $n=class extends e{constructor(n,t){let o=Array.isArray(n[0])?n[0]:n;super([\"mget\",...o],t)}};var qn=class extends e{constructor([n],t){super([\"mset\",...Object.entries(n).flatMap(([o,m])=>[o,m])],t)}};var jn=class extends e{constructor([n],t){super([\"msetnx\",...Object.entries(n).flatMap(o=>o)],t)}};var Yn=class extends e{constructor(n,t){super([\"persist\",...n],t)}};var Vn=class extends e{constructor(n,t){super([\"pexpire\",...n],t)}};var _n=class extends e{constructor(n,t){super([\"pexpireat\",...n],t)}};var Wn=class extends e{constructor(n,t){super([\"pfadd\",...n],t)}};var Qn=class extends e{constructor(n,t){super([\"pfcount\",...n],t)}};var nt=class extends e{constructor(n,t){super([\"pfmerge\",...n],t)}};var tt=class extends e{constructor(n,t){let o=[\"ping\"];typeof n<\"u\"&&typeof n[0]<\"u\"&&o.push(n[0]),super(o,t)}};var et=class extends e{constructor(n,t){super([\"psetex\",...n],t)}};var ot=class extends e{constructor(n,t){super([\"pttl\",...n],t)}};var st=class extends e{constructor(n,t){super([\"publish\",...n],t)}};var mt=class extends e{constructor(n){super([\"randomkey\"],n)}};var rt=class extends e{constructor(n,t){super([\"rename\",...n],t)}};var at=class extends e{constructor(n,t){super([\"renamenx\",...n],t)}};var it=class extends e{constructor(n,t){super([\"rpop\",...n],t)}};var pt=class extends e{constructor(n,t){super([\"rpush\",...n],t)}};var dt=class extends e{constructor(n,t){super([\"rpushx\",...n],t)}};var ct=class extends e{constructor(n,t){super([\"sadd\",...n],t)}};var ut=class extends e{constructor([n,t],o){let m=[\"scan\",n];t?.match&&m.push(\"match\",t.match),typeof t?.count==\"number\"&&m.push(\"count\",t.count),t?.type&&t.type.length>0&&m.push(\"type\",t.type),super(m,{deserialize:h,...o})}};var ht=class extends e{constructor(n,t){super([\"scard\",...n],t)}};var lt=class extends e{constructor(n,t){super([\"script\",\"exists\",...n],{deserialize:o=>o,...t})}};var Ct=class extends e{constructor([n],t){let o=[\"script\",\"flush\"];n?.sync?o.push(\"sync\"):n?.async&&o.push(\"async\"),super(o,t)}};var gt=class extends e{constructor(n,t){super([\"script\",\"load\",...n],t)}};var xt=class extends e{constructor(n,t){super([\"sdiff\",...n],t)}};var ft=class extends e{constructor(n,t){super([\"sdiffstore\",...n],t)}};var yt=class extends e{constructor([n,t,o],m){let r=[\"set\",n,t];o&&(\"nx\"in o&&o.nx?r.push(\"nx\"):\"xx\"in o&&o.xx&&r.push(\"xx\"),\"get\"in o&&o.get&&r.push(\"get\"),\"ex\"in o&&typeof o.ex==\"number\"?r.push(\"ex\",o.ex):\"px\"in o&&typeof o.px==\"number\"?r.push(\"px\",o.px):\"exat\"in o&&typeof o.exat==\"number\"?r.push(\"exat\",o.exat):\"pxat\"in o&&typeof o.pxat==\"number\"?r.push(\"pxat\",o.pxat):\"keepTtl\"in o&&o.keepTtl&&r.push(\"keepTtl\")),super(r,m)}};var bt=class extends e{constructor(n,t){super([\"setbit\",...n],t)}};var Tt=class extends e{constructor(n,t){super([\"setex\",...n],t)}};var Ot=class extends e{constructor(n,t){super([\"setnx\",...n],t)}};var wt=class extends e{constructor(n,t){super([\"setrange\",...n],t)}};var Dt=class extends e{constructor(n,t){super([\"sinter\",...n],t)}};var At=class extends e{constructor(n,t){super([\"sinterstore\",...n],t)}};var kt=class extends e{constructor(n,t){super([\"sismember\",...n],t)}};var Rt=class extends e{constructor(n,t){super([\"smembers\",...n],t)}};var St=class extends e{constructor(n,t){super([\"smismember\",n[0],...n[1]],t)}};var Et=class extends e{constructor(n,t){super([\"smove\",...n],t)}};var Mt=class extends e{constructor([n,t],o){let m=[\"spop\",n];typeof t==\"number\"&&m.push(t),super(m,o)}};var vt=class extends e{constructor([n,t],o){let m=[\"srandmember\",n];typeof t==\"number\"&&m.push(t),super(m,o)}};var Pt=class extends e{constructor(n,t){super([\"srem\",...n],t)}};var It=class extends e{constructor([n,t,o],m){let r=[\"sscan\",n,t];o?.match&&r.push(\"match\",o.match),typeof o?.count==\"number\"&&r.push(\"count\",o.count),super(r,{deserialize:h,...m})}};var Nt=class extends e{constructor(n,t){super([\"strlen\",...n],t)}};var Lt=class extends e{constructor(n,t){super([\"sunion\",...n],t)}};var zt=class extends e{constructor(n,t){super([\"sunionstore\",...n],t)}};var Gt=class extends e{constructor(n){super([\"time\"],n)}};var Kt=class extends e{constructor(n,t){super([\"touch\",...n],t)}};var Xt=class extends e{constructor(n,t){super([\"ttl\",...n],t)}};var Ut=class extends e{constructor(n,t){super([\"type\",...n],t)}};var Jt=class extends e{constructor(n,t){super([\"unlink\",...n],t)}};var Bt=class extends e{constructor([n,t,o],m){let r=Array.isArray(o)?[...o]:[o];super([\"XACK\",n,t,...r],m)}};var Zt=class extends e{constructor([n,t,o,m],r){let a=[\"XADD\",n];m&&(m.nomkStream&&a.push(\"NOMKSTREAM\"),m.trim&&(a.push(m.trim.type,m.trim.comparison,m.trim.threshold),typeof m.trim.limit<\"u\"&&a.push(\"LIMIT\",m.trim.limit))),a.push(t);for(let[i,p]of Object.entries(o))a.push(i,p);super(a,r)}};var Ht=class extends e{constructor([n,t,o,m,r,a],i){let p=[];a?.count&&p.push(\"COUNT\",a.count),a?.justId&&p.push(\"JUSTID\"),super([\"XAUTOCLAIM\",n,t,o,m,r,...p],i)}};var Ft=class extends e{constructor([n,t,o,m,r,a],i){let p=Array.isArray(r)?[...r]:[r],d=[];a?.idleMS&&d.push(\"IDLE\",a.idleMS),a?.idleMS&&d.push(\"TIME\",a.timeMS),a?.retryCount&&d.push(\"RETRYCOUNT\",a?.retryCount),a?.force&&d.push(\"FORCE\"),a?.justId&&d.push(\"JUSTID\"),a?.lastId&&d.push(\"LASTID\",a.lastId),super([\"XCLAIM\",n,t,o,m,...p,...d],i)}};var $t=class extends e{constructor([n,t],o){let m=Array.isArray(t)?[...t]:[t];super([\"XDEL\",n,...m],o)}};var qt=class extends e{constructor([n,t],o){let m=[\"XGROUP\"];switch(t.type){case\"CREATE\":m.push(\"CREATE\",n,t.group,t.id),t.options&&(t.options.MKSTREAM&&m.push(\"MKSTREAM\"),t.options.ENTRIESREAD!==void 0&&m.push(\"ENTRIESREAD\",t.options.ENTRIESREAD.toString()));break;case\"CREATECONSUMER\":m.push(\"CREATECONSUMER\",n,t.group,t.consumer);break;case\"DELCONSUMER\":m.push(\"DELCONSUMER\",n,t.group,t.consumer);break;case\"DESTROY\":m.push(\"DESTROY\",n,t.group);break;case\"SETID\":m.push(\"SETID\",n,t.group,t.id),t.options&&t.options.ENTRIESREAD!==void 0&&m.push(\"ENTRIESREAD\",t.options.ENTRIESREAD.toString());break;default:throw new Error(\"Invalid XGROUP\")}super(m,o)}};var jt=class extends e{constructor([n,t],o){let m=[];t.type===\"CONSUMERS\"?m.push(\"CONSUMERS\",n,t.group):m.push(\"GROUPS\",n),super([\"XINFO\",...m],o)}};var Yt=class extends e{constructor(n,t){super([\"XLEN\",...n],t)}};var Vt=class extends e{constructor([n,t,o,m,r,a],i){let p=typeof a?.consumer<\"u\"?Array.isArray(a.consumer)?[...a.consumer]:[a.consumer]:[];super([\"XPENDING\",n,t,...a?.idleTime?[\"IDLE\",a.idleTime]:[],o,m,r,...p],i)}};function Be(s){let n={};for(let t of s)for(;t.length>=2;){let o=t.shift(),m=t.shift();for((o in n)||(n[o]={});m.length>=2;){let r=m.shift(),a=m.shift();try{n[o][r]=JSON.parse(a)}catch{n[o][r]=a}}}return n}var _t=class extends e{constructor([n,t,o,m],r){let a=[\"XRANGE\",n,t,o];typeof m==\"number\"&&a.push(\"COUNT\",m),super(a,{deserialize:i=>Be(i),...r})}};var Ze=\"ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified\",Wt=class extends e{constructor([n,t,o],m){if(Array.isArray(n)&&Array.isArray(t)&&n.length!==t.length)throw new Error(Ze);let r=[];typeof o?.count==\"number\"&&r.push(\"COUNT\",o.count),typeof o?.blockMS==\"number\"&&r.push(\"BLOCK\",o.blockMS),r.push(\"STREAMS\",...Array.isArray(n)?[...n]:[n],...Array.isArray(t)?[...t]:[t]),super([\"XREAD\",...r],m)}};var He=\"ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified\",Qt=class extends e{constructor([n,t,o,m,r],a){if(Array.isArray(o)&&Array.isArray(m)&&o.length!==m.length)throw new Error(He);let i=[];typeof r?.count==\"number\"&&i.push(\"COUNT\",r.count),typeof r?.blockMS==\"number\"&&i.push(\"BLOCK\",r.blockMS),typeof r?.NOACK==\"boolean\"&&r?.NOACK&&i.push(\"NOACK\"),i.push(\"STREAMS\",...Array.isArray(o)?[...o]:[o],...Array.isArray(m)?[...m]:[m]),super([\"XREADGROUP\",\"GROUP\",n,t,...i],a)}};var ne=class extends e{constructor([n,t,o,m],r){let a=[\"XREVRANGE\",n,t,o];typeof m==\"number\"&&a.push(\"COUNT\",m),super(a,{deserialize:i=>Fe(i),...r})}};function Fe(s){let n={};for(let t of s)for(;t.length>=2;){let o=t.shift(),m=t.shift();for((o in n)||(n[o]={});m.length>=2;){let r=m.shift(),a=m.shift();try{n[o][r]=JSON.parse(a)}catch{n[o][r]=a}}}return n}var te=class extends e{constructor([n,t],o){let{limit:m,strategy:r,threshold:a,exactness:i=\"~\"}=t;super([\"XTRIM\",n,r,i,a,...m?[\"LIMIT\",m]:[]],o)}};var l=class extends e{constructor([n,t,...o],m){let r=[\"zadd\",n];\"nx\"in t&&t.nx?r.push(\"nx\"):\"xx\"in t&&t.xx&&r.push(\"xx\"),\"ch\"in t&&t.ch&&r.push(\"ch\"),\"incr\"in t&&t.incr&&r.push(\"incr\"),\"lt\"in t&&t.lt?r.push(\"lt\"):\"gt\"in t&&t.gt&&r.push(\"gt\"),\"score\"in t&&\"member\"in t&&r.push(t.score,t.member),r.push(...o.flatMap(({score:a,member:i})=>[a,i])),super(r,m)}};var ee=class extends e{constructor(n,t){super([\"zcard\",...n],t)}};var oe=class extends e{constructor(n,t){super([\"zcount\",...n],t)}};var se=class extends e{constructor(n,t){super([\"zincrby\",...n],t)}};var me=class extends e{constructor([n,t,o,m],r){let a=[\"zinterstore\",n,t];Array.isArray(o)?a.push(...o):a.push(o),m&&(\"weights\"in m&&m.weights?a.push(\"weights\",...m.weights):\"weight\"in m&&typeof m.weight==\"number\"&&a.push(\"weights\",m.weight),\"aggregate\"in m&&a.push(\"aggregate\",m.aggregate)),super(a,r)}};var re=class extends e{constructor(n,t){super([\"zlexcount\",...n],t)}};var ae=class extends e{constructor([n,t],o){let m=[\"zpopmax\",n];typeof t==\"number\"&&m.push(t),super(m,o)}};var ie=class extends e{constructor([n,t],o){let m=[\"zpopmin\",n];typeof t==\"number\"&&m.push(t),super(m,o)}};var pe=class extends e{constructor([n,t,o,m],r){let a=[\"zrange\",n,t,o];m?.byScore&&a.push(\"byscore\"),m?.byLex&&a.push(\"bylex\"),m?.rev&&a.push(\"rev\"),typeof m?.count<\"u\"&&typeof m?.offset<\"u\"&&a.push(\"limit\",m.offset,m.count),m?.withScores&&a.push(\"withscores\"),super(a,r)}};var de=class extends e{constructor(n,t){super([\"zrank\",...n],t)}};var ce=class extends e{constructor(n,t){super([\"zrem\",...n],t)}};var ue=class extends e{constructor(n,t){super([\"zremrangebylex\",...n],t)}};var he=class extends e{constructor(n,t){super([\"zremrangebyrank\",...n],t)}};var le=class extends e{constructor(n,t){super([\"zremrangebyscore\",...n],t)}};var Ce=class extends e{constructor(n,t){super([\"zrevrank\",...n],t)}};var ge=class extends e{constructor([n,t,o],m){let r=[\"zscan\",n,t];o?.match&&r.push(\"match\",o.match),typeof o?.count==\"number\"&&r.push(\"count\",o.count),super(r,{deserialize:h,...m})}};var xe=class extends e{constructor(n,t){super([\"zscore\",...n],t)}};var fe=class extends e{constructor([n,t,o],m){let r=[\"zunion\",n];Array.isArray(t)?r.push(...t):r.push(t),o&&(\"weights\"in o&&o.weights?r.push(\"weights\",...o.weights):\"weight\"in o&&typeof o.weight==\"number\"&&r.push(\"weights\",o.weight),\"aggregate\"in o&&r.push(\"aggregate\",o.aggregate),o?.withScores&&r.push(\"withscores\")),super(r,m)}};var ye=class extends e{constructor([n,t,o,m],r){let a=[\"zunionstore\",n,t];Array.isArray(o)?a.push(...o):a.push(o),m&&(\"weights\"in m&&m.weights?a.push(\"weights\",...m.weights):\"weight\"in m&&typeof m.weight==\"number\"&&a.push(\"weights\",m.weight),\"aggregate\"in m&&a.push(\"aggregate\",m.aggregate)),super(a,r)}};var be=class extends e{constructor(n,t){super([\"zdiffstore\",...n],t)}};var Te=class extends e{constructor(n,t){let[o,m]=n;super([\"zmscore\",o,...m],t)}};var we=class{client;commands;commandOptions;multiExec;constructor(n){if(this.client=n.client,this.commands=[],this.commandOptions=n.commandOptions,this.multiExec=n.multiExec??!1,this.commandOptions?.latencyLogging){let t=this.exec.bind(this);this.exec=async()=>{let o=performance.now(),m=await t(),a=(performance.now()-o).toFixed(2);return console.log(`Latency for \\x1B[38;2;19;185;39m${this.multiExec?[\"MULTI-EXEC\"]:[\"PIPELINE\"].toString().toUpperCase()}\\x1B[0m: \\x1B[38;2;0;255;255m${a} ms\\x1B[0m`),m}}}exec=async()=>{if(this.commands.length===0)throw new Error(\"Pipeline is empty\");let n=this.multiExec?[\"multi-exec\"]:[\"pipeline\"];return(await this.client.request({path:n,body:Object.values(this.commands).map(o=>o.command)})).map(({error:o,result:m},r)=>{if(o)throw new u(`Command ${r+1} [ ${this.commands[r].command[0]} ] failed: ${o}`);return this.commands[r].deserialize(m)})};length(){return this.commands.length}chain(n){return this.commands.push(n),this}append=(...n)=>this.chain(new g(n,this.commandOptions));bitcount=(...n)=>this.chain(new x(n,this.commandOptions));bitfield=(...n)=>new f(n,this.client,this.commandOptions,this.chain.bind(this));bitop=(n,t,o,...m)=>this.chain(new y([n,t,o,...m],this.commandOptions));bitpos=(...n)=>this.chain(new b(n,this.commandOptions));copy=(...n)=>this.chain(new T(n,this.commandOptions));zdiffstore=(...n)=>this.chain(new be(n,this.commandOptions));dbsize=()=>this.chain(new O(this.commandOptions));decr=(...n)=>this.chain(new w(n,this.commandOptions));decrby=(...n)=>this.chain(new D(n,this.commandOptions));del=(...n)=>this.chain(new A(n,this.commandOptions));echo=(...n)=>this.chain(new k(n,this.commandOptions));eval=(...n)=>this.chain(new R(n,this.commandOptions));evalsha=(...n)=>this.chain(new S(n,this.commandOptions));exists=(...n)=>this.chain(new E(n,this.commandOptions));expire=(...n)=>this.chain(new M(n,this.commandOptions));expireat=(...n)=>this.chain(new v(n,this.commandOptions));flushall=n=>this.chain(new P(n,this.commandOptions));flushdb=(...n)=>this.chain(new I(n,this.commandOptions));geoadd=(...n)=>this.chain(new N(n,this.commandOptions));geodist=(...n)=>this.chain(new L(n,this.commandOptions));geopos=(...n)=>this.chain(new G(n,this.commandOptions));geohash=(...n)=>this.chain(new z(n,this.commandOptions));geosearch=(...n)=>this.chain(new K(n,this.commandOptions));geosearchstore=(...n)=>this.chain(new X(n,this.commandOptions));get=(...n)=>this.chain(new U(n,this.commandOptions));getbit=(...n)=>this.chain(new J(n,this.commandOptions));getdel=(...n)=>this.chain(new B(n,this.commandOptions));getrange=(...n)=>this.chain(new Z(n,this.commandOptions));getset=(n,t)=>this.chain(new H([n,t],this.commandOptions));hdel=(...n)=>this.chain(new F(n,this.commandOptions));hexists=(...n)=>this.chain(new $(n,this.commandOptions));hget=(...n)=>this.chain(new q(n,this.commandOptions));hgetall=(...n)=>this.chain(new j(n,this.commandOptions));hincrby=(...n)=>this.chain(new Y(n,this.commandOptions));hincrbyfloat=(...n)=>this.chain(new V(n,this.commandOptions));hkeys=(...n)=>this.chain(new _(n,this.commandOptions));hlen=(...n)=>this.chain(new W(n,this.commandOptions));hmget=(...n)=>this.chain(new Q(n,this.commandOptions));hmset=(n,t)=>this.chain(new nn([n,t],this.commandOptions));hrandfield=(n,t,o)=>this.chain(new tn([n,t,o],this.commandOptions));hscan=(...n)=>this.chain(new en(n,this.commandOptions));hset=(n,t)=>this.chain(new on([n,t],this.commandOptions));hsetnx=(n,t,o)=>this.chain(new sn([n,t,o],this.commandOptions));hstrlen=(...n)=>this.chain(new mn(n,this.commandOptions));hvals=(...n)=>this.chain(new rn(n,this.commandOptions));incr=(...n)=>this.chain(new an(n,this.commandOptions));incrby=(...n)=>this.chain(new pn(n,this.commandOptions));incrbyfloat=(...n)=>this.chain(new dn(n,this.commandOptions));keys=(...n)=>this.chain(new Pn(n,this.commandOptions));lindex=(...n)=>this.chain(new In(n,this.commandOptions));linsert=(n,t,o,m)=>this.chain(new Nn([n,t,o,m],this.commandOptions));llen=(...n)=>this.chain(new Ln(n,this.commandOptions));lmove=(...n)=>this.chain(new zn(n,this.commandOptions));lpop=(...n)=>this.chain(new Kn(n,this.commandOptions));lmpop=(...n)=>this.chain(new Gn(n,this.commandOptions));lpos=(...n)=>this.chain(new Xn(n,this.commandOptions));lpush=(n,...t)=>this.chain(new Un([n,...t],this.commandOptions));lpushx=(n,...t)=>this.chain(new Jn([n,...t],this.commandOptions));lrange=(...n)=>this.chain(new Bn(n,this.commandOptions));lrem=(n,t,o)=>this.chain(new Zn([n,t,o],this.commandOptions));lset=(n,t,o)=>this.chain(new Hn([n,t,o],this.commandOptions));ltrim=(...n)=>this.chain(new Fn(n,this.commandOptions));mget=(...n)=>this.chain(new $n(n,this.commandOptions));mset=n=>this.chain(new qn([n],this.commandOptions));msetnx=n=>this.chain(new jn([n],this.commandOptions));persist=(...n)=>this.chain(new Yn(n,this.commandOptions));pexpire=(...n)=>this.chain(new Vn(n,this.commandOptions));pexpireat=(...n)=>this.chain(new _n(n,this.commandOptions));pfadd=(...n)=>this.chain(new Wn(n,this.commandOptions));pfcount=(...n)=>this.chain(new Qn(n,this.commandOptions));pfmerge=(...n)=>this.chain(new nt(n,this.commandOptions));ping=n=>this.chain(new tt(n,this.commandOptions));psetex=(n,t,o)=>this.chain(new et([n,t,o],this.commandOptions));pttl=(...n)=>this.chain(new ot(n,this.commandOptions));publish=(...n)=>this.chain(new st(n,this.commandOptions));randomkey=()=>this.chain(new mt(this.commandOptions));rename=(...n)=>this.chain(new rt(n,this.commandOptions));renamenx=(...n)=>this.chain(new at(n,this.commandOptions));rpop=(...n)=>this.chain(new it(n,this.commandOptions));rpush=(n,...t)=>this.chain(new pt([n,...t],this.commandOptions));rpushx=(n,...t)=>this.chain(new dt([n,...t],this.commandOptions));sadd=(n,...t)=>this.chain(new ct([n,...t],this.commandOptions));scan=(...n)=>this.chain(new ut(n,this.commandOptions));scard=(...n)=>this.chain(new ht(n,this.commandOptions));scriptExists=(...n)=>this.chain(new lt(n,this.commandOptions));scriptFlush=(...n)=>this.chain(new Ct(n,this.commandOptions));scriptLoad=(...n)=>this.chain(new gt(n,this.commandOptions));sdiff=(...n)=>this.chain(new xt(n,this.commandOptions));sdiffstore=(...n)=>this.chain(new ft(n,this.commandOptions));set=(n,t,o)=>this.chain(new yt([n,t,o],this.commandOptions));setbit=(...n)=>this.chain(new bt(n,this.commandOptions));setex=(n,t,o)=>this.chain(new Tt([n,t,o],this.commandOptions));setnx=(n,t)=>this.chain(new Ot([n,t],this.commandOptions));setrange=(...n)=>this.chain(new wt(n,this.commandOptions));sinter=(...n)=>this.chain(new Dt(n,this.commandOptions));sinterstore=(...n)=>this.chain(new At(n,this.commandOptions));sismember=(n,t)=>this.chain(new kt([n,t],this.commandOptions));smembers=(...n)=>this.chain(new Rt(n,this.commandOptions));smismember=(n,t)=>this.chain(new St([n,t],this.commandOptions));smove=(n,t,o)=>this.chain(new Et([n,t,o],this.commandOptions));spop=(...n)=>this.chain(new Mt(n,this.commandOptions));srandmember=(...n)=>this.chain(new vt(n,this.commandOptions));srem=(n,...t)=>this.chain(new Pt([n,...t],this.commandOptions));sscan=(...n)=>this.chain(new It(n,this.commandOptions));strlen=(...n)=>this.chain(new Nt(n,this.commandOptions));sunion=(...n)=>this.chain(new Lt(n,this.commandOptions));sunionstore=(...n)=>this.chain(new zt(n,this.commandOptions));time=()=>this.chain(new Gt(this.commandOptions));touch=(...n)=>this.chain(new Kt(n,this.commandOptions));ttl=(...n)=>this.chain(new Xt(n,this.commandOptions));type=(...n)=>this.chain(new Ut(n,this.commandOptions));unlink=(...n)=>this.chain(new Jt(n,this.commandOptions));zadd=(...n)=>\"score\"in n[1]?this.chain(new l([n[0],n[1],...n.slice(2)],this.commandOptions)):this.chain(new l([n[0],n[1],...n.slice(2)],this.commandOptions));xadd=(...n)=>this.chain(new Zt(n,this.commandOptions));xack=(...n)=>this.chain(new Bt(n,this.commandOptions));xdel=(...n)=>this.chain(new $t(n,this.commandOptions));xgroup=(...n)=>this.chain(new qt(n,this.commandOptions));xread=(...n)=>this.chain(new Wt(n,this.commandOptions));xreadgroup=(...n)=>this.chain(new Qt(n,this.commandOptions));xinfo=(...n)=>this.chain(new jt(n,this.commandOptions));xlen=(...n)=>this.chain(new Yt(n,this.commandOptions));xpending=(...n)=>this.chain(new Vt(n,this.commandOptions));xclaim=(...n)=>this.chain(new Ft(n,this.commandOptions));xautoclaim=(...n)=>this.chain(new Ht(n,this.commandOptions));xtrim=(...n)=>this.chain(new te(n,this.commandOptions));xrange=(...n)=>this.chain(new _t(n,this.commandOptions));xrevrange=(...n)=>this.chain(new ne(n,this.commandOptions));zcard=(...n)=>this.chain(new ee(n,this.commandOptions));zcount=(...n)=>this.chain(new oe(n,this.commandOptions));zincrby=(n,t,o)=>this.chain(new se([n,t,o],this.commandOptions));zinterstore=(...n)=>this.chain(new me(n,this.commandOptions));zlexcount=(...n)=>this.chain(new re(n,this.commandOptions));zmscore=(...n)=>this.chain(new Te(n,this.commandOptions));zpopmax=(...n)=>this.chain(new ae(n,this.commandOptions));zpopmin=(...n)=>this.chain(new ie(n,this.commandOptions));zrange=(...n)=>this.chain(new pe(n,this.commandOptions));zrank=(n,t)=>this.chain(new de([n,t],this.commandOptions));zrem=(n,...t)=>this.chain(new ce([n,...t],this.commandOptions));zremrangebylex=(...n)=>this.chain(new ue(n,this.commandOptions));zremrangebyrank=(...n)=>this.chain(new he(n,this.commandOptions));zremrangebyscore=(...n)=>this.chain(new le(n,this.commandOptions));zrevrank=(n,t)=>this.chain(new Ce([n,t],this.commandOptions));zscan=(...n)=>this.chain(new ge(n,this.commandOptions));zscore=(n,t)=>this.chain(new xe([n,t],this.commandOptions));zunionstore=(...n)=>this.chain(new ye(n,this.commandOptions));zunion=(...n)=>this.chain(new fe(n,this.commandOptions));get json(){return{arrappend:(...n)=>this.chain(new cn(n,this.commandOptions)),arrindex:(...n)=>this.chain(new un(n,this.commandOptions)),arrinsert:(...n)=>this.chain(new hn(n,this.commandOptions)),arrlen:(...n)=>this.chain(new ln(n,this.commandOptions)),arrpop:(...n)=>this.chain(new Cn(n,this.commandOptions)),arrtrim:(...n)=>this.chain(new gn(n,this.commandOptions)),clear:(...n)=>this.chain(new xn(n,this.commandOptions)),del:(...n)=>this.chain(new fn(n,this.commandOptions)),forget:(...n)=>this.chain(new yn(n,this.commandOptions)),get:(...n)=>this.chain(new bn(n,this.commandOptions)),mget:(...n)=>this.chain(new Tn(n,this.commandOptions)),numincrby:(...n)=>this.chain(new On(n,this.commandOptions)),nummultby:(...n)=>this.chain(new wn(n,this.commandOptions)),objkeys:(...n)=>this.chain(new Dn(n,this.commandOptions)),objlen:(...n)=>this.chain(new An(n,this.commandOptions)),resp:(...n)=>this.chain(new kn(n,this.commandOptions)),set:(...n)=>this.chain(new Rn(n,this.commandOptions)),strappend:(...n)=>this.chain(new Sn(n,this.commandOptions)),strlen:(...n)=>this.chain(new En(n,this.commandOptions)),toggle:(...n)=>this.chain(new Mn(n,this.commandOptions)),type:(...n)=>this.chain(new vn(n,this.commandOptions))}}};var Ae=class{script;sha1;redis;constructor(n,t){this.redis=n,this.sha1=this.digest(t),this.script=t}async eval(n,t){return await this.redis.eval(this.script,n,t)}async evalsha(n,t){return await this.redis.evalsha(this.sha1,n,t)}async exec(n,t){return await this.redis.evalsha(this.sha1,n,t).catch(async m=>{if(m instanceof Error&&m.message.toLowerCase().includes(\"noscript\"))return await this.redis.eval(this.script,n,t);throw m})}digest(n){return crypto_js_enc_hex_js__WEBPACK_IMPORTED_MODULE_0__.stringify(crypto_js_sha1_js__WEBPACK_IMPORTED_MODULE_1__(n))}};var Ie=class{client;opts;enableTelemetry;enableAutoPipelining;constructor(n,t){this.client=n,this.opts=t,this.enableTelemetry=t?.enableTelemetry??!0,this.enableAutoPipelining=t?.enableAutoPipelining??!1}get json(){return{arrappend:(...n)=>new cn(n,this.opts).exec(this.client),arrindex:(...n)=>new un(n,this.opts).exec(this.client),arrinsert:(...n)=>new hn(n,this.opts).exec(this.client),arrlen:(...n)=>new ln(n,this.opts).exec(this.client),arrpop:(...n)=>new Cn(n,this.opts).exec(this.client),arrtrim:(...n)=>new gn(n,this.opts).exec(this.client),clear:(...n)=>new xn(n,this.opts).exec(this.client),del:(...n)=>new fn(n,this.opts).exec(this.client),forget:(...n)=>new yn(n,this.opts).exec(this.client),get:(...n)=>new bn(n,this.opts).exec(this.client),mget:(...n)=>new Tn(n,this.opts).exec(this.client),numincrby:(...n)=>new On(n,this.opts).exec(this.client),nummultby:(...n)=>new wn(n,this.opts).exec(this.client),objkeys:(...n)=>new Dn(n,this.opts).exec(this.client),objlen:(...n)=>new An(n,this.opts).exec(this.client),resp:(...n)=>new kn(n,this.opts).exec(this.client),set:(...n)=>new Rn(n,this.opts).exec(this.client),strappend:(...n)=>new Sn(n,this.opts).exec(this.client),strlen:(...n)=>new En(n,this.opts).exec(this.client),toggle:(...n)=>new Mn(n,this.opts).exec(this.client),type:(...n)=>new vn(n,this.opts).exec(this.client)}}use=n=>{let t=this.client.request.bind(this.client);this.client.request=o=>n(o,t)};addTelemetry=n=>{if(this.enableTelemetry)try{this.client.mergeTelemetry(n)}catch{}};createScript(n){return new Ae(this,n)}pipeline=()=>new we({client:this.client,commandOptions:this.opts,multiExec:!1});autoPipeline=()=>Se(this);multi=()=>new we({client:this.client,commandOptions:this.opts,multiExec:!0});bitfield=(...n)=>new f(n,this.client,this.opts);append=(...n)=>new g(n,this.opts).exec(this.client);bitcount=(...n)=>new x(n,this.opts).exec(this.client);bitop=(n,t,o,...m)=>new y([n,t,o,...m],this.opts).exec(this.client);bitpos=(...n)=>new b(n,this.opts).exec(this.client);copy=(...n)=>new T(n,this.opts).exec(this.client);dbsize=()=>new O(this.opts).exec(this.client);decr=(...n)=>new w(n,this.opts).exec(this.client);decrby=(...n)=>new D(n,this.opts).exec(this.client);del=(...n)=>new A(n,this.opts).exec(this.client);echo=(...n)=>new k(n,this.opts).exec(this.client);eval=(...n)=>new R(n,this.opts).exec(this.client);evalsha=(...n)=>new S(n,this.opts).exec(this.client);exists=(...n)=>new E(n,this.opts).exec(this.client);expire=(...n)=>new M(n,this.opts).exec(this.client);expireat=(...n)=>new v(n,this.opts).exec(this.client);flushall=n=>new P(n,this.opts).exec(this.client);flushdb=(...n)=>new I(n,this.opts).exec(this.client);geoadd=(...n)=>new N(n,this.opts).exec(this.client);geopos=(...n)=>new G(n,this.opts).exec(this.client);geodist=(...n)=>new L(n,this.opts).exec(this.client);geohash=(...n)=>new z(n,this.opts).exec(this.client);geosearch=(...n)=>new K(n,this.opts).exec(this.client);geosearchstore=(...n)=>new X(n,this.opts).exec(this.client);get=(...n)=>new U(n,this.opts).exec(this.client);getbit=(...n)=>new J(n,this.opts).exec(this.client);getdel=(...n)=>new B(n,this.opts).exec(this.client);getrange=(...n)=>new Z(n,this.opts).exec(this.client);getset=(n,t)=>new H([n,t],this.opts).exec(this.client);hdel=(...n)=>new F(n,this.opts).exec(this.client);hexists=(...n)=>new $(n,this.opts).exec(this.client);hget=(...n)=>new q(n,this.opts).exec(this.client);hgetall=(...n)=>new j(n,this.opts).exec(this.client);hincrby=(...n)=>new Y(n,this.opts).exec(this.client);hincrbyfloat=(...n)=>new V(n,this.opts).exec(this.client);hkeys=(...n)=>new _(n,this.opts).exec(this.client);hlen=(...n)=>new W(n,this.opts).exec(this.client);hmget=(...n)=>new Q(n,this.opts).exec(this.client);hmset=(n,t)=>new nn([n,t],this.opts).exec(this.client);hrandfield=(n,t,o)=>new tn([n,t,o],this.opts).exec(this.client);hscan=(...n)=>new en(n,this.opts).exec(this.client);hset=(n,t)=>new on([n,t],this.opts).exec(this.client);hsetnx=(n,t,o)=>new sn([n,t,o],this.opts).exec(this.client);hstrlen=(...n)=>new mn(n,this.opts).exec(this.client);hvals=(...n)=>new rn(n,this.opts).exec(this.client);incr=(...n)=>new an(n,this.opts).exec(this.client);incrby=(...n)=>new pn(n,this.opts).exec(this.client);incrbyfloat=(...n)=>new dn(n,this.opts).exec(this.client);keys=(...n)=>new Pn(n,this.opts).exec(this.client);lindex=(...n)=>new In(n,this.opts).exec(this.client);linsert=(n,t,o,m)=>new Nn([n,t,o,m],this.opts).exec(this.client);llen=(...n)=>new Ln(n,this.opts).exec(this.client);lmove=(...n)=>new zn(n,this.opts).exec(this.client);lpop=(...n)=>new Kn(n,this.opts).exec(this.client);lmpop=(...n)=>new Gn(n,this.opts).exec(this.client);lpos=(...n)=>new Xn(n,this.opts).exec(this.client);lpush=(n,...t)=>new Un([n,...t],this.opts).exec(this.client);lpushx=(n,...t)=>new Jn([n,...t],this.opts).exec(this.client);lrange=(...n)=>new Bn(n,this.opts).exec(this.client);lrem=(n,t,o)=>new Zn([n,t,o],this.opts).exec(this.client);lset=(n,t,o)=>new Hn([n,t,o],this.opts).exec(this.client);ltrim=(...n)=>new Fn(n,this.opts).exec(this.client);mget=(...n)=>new $n(n,this.opts).exec(this.client);mset=n=>new qn([n],this.opts).exec(this.client);msetnx=n=>new jn([n],this.opts).exec(this.client);persist=(...n)=>new Yn(n,this.opts).exec(this.client);pexpire=(...n)=>new Vn(n,this.opts).exec(this.client);pexpireat=(...n)=>new _n(n,this.opts).exec(this.client);pfadd=(...n)=>new Wn(n,this.opts).exec(this.client);pfcount=(...n)=>new Qn(n,this.opts).exec(this.client);pfmerge=(...n)=>new nt(n,this.opts).exec(this.client);ping=n=>new tt(n,this.opts).exec(this.client);psetex=(n,t,o)=>new et([n,t,o],this.opts).exec(this.client);pttl=(...n)=>new ot(n,this.opts).exec(this.client);publish=(...n)=>new st(n,this.opts).exec(this.client);randomkey=()=>new mt().exec(this.client);rename=(...n)=>new rt(n,this.opts).exec(this.client);renamenx=(...n)=>new at(n,this.opts).exec(this.client);rpop=(...n)=>new it(n,this.opts).exec(this.client);rpush=(n,...t)=>new pt([n,...t],this.opts).exec(this.client);rpushx=(n,...t)=>new dt([n,...t],this.opts).exec(this.client);sadd=(n,...t)=>new ct([n,...t],this.opts).exec(this.client);scan=(...n)=>new ut(n,this.opts).exec(this.client);scard=(...n)=>new ht(n,this.opts).exec(this.client);scriptExists=(...n)=>new lt(n,this.opts).exec(this.client);scriptFlush=(...n)=>new Ct(n,this.opts).exec(this.client);scriptLoad=(...n)=>new gt(n,this.opts).exec(this.client);sdiff=(...n)=>new xt(n,this.opts).exec(this.client);sdiffstore=(...n)=>new ft(n,this.opts).exec(this.client);set=(n,t,o)=>new yt([n,t,o],this.opts).exec(this.client);setbit=(...n)=>new bt(n,this.opts).exec(this.client);setex=(n,t,o)=>new Tt([n,t,o],this.opts).exec(this.client);setnx=(n,t)=>new Ot([n,t],this.opts).exec(this.client);setrange=(...n)=>new wt(n,this.opts).exec(this.client);sinter=(...n)=>new Dt(n,this.opts).exec(this.client);sinterstore=(...n)=>new At(n,this.opts).exec(this.client);sismember=(n,t)=>new kt([n,t],this.opts).exec(this.client);smismember=(n,t)=>new St([n,t],this.opts).exec(this.client);smembers=(...n)=>new Rt(n,this.opts).exec(this.client);smove=(n,t,o)=>new Et([n,t,o],this.opts).exec(this.client);spop=(...n)=>new Mt(n,this.opts).exec(this.client);srandmember=(...n)=>new vt(n,this.opts).exec(this.client);srem=(n,...t)=>new Pt([n,...t],this.opts).exec(this.client);sscan=(...n)=>new It(n,this.opts).exec(this.client);strlen=(...n)=>new Nt(n,this.opts).exec(this.client);sunion=(...n)=>new Lt(n,this.opts).exec(this.client);sunionstore=(...n)=>new zt(n,this.opts).exec(this.client);time=()=>new Gt().exec(this.client);touch=(...n)=>new Kt(n,this.opts).exec(this.client);ttl=(...n)=>new Xt(n,this.opts).exec(this.client);type=(...n)=>new Ut(n,this.opts).exec(this.client);unlink=(...n)=>new Jt(n,this.opts).exec(this.client);xadd=(...n)=>new Zt(n,this.opts).exec(this.client);xack=(...n)=>new Bt(n,this.opts).exec(this.client);xdel=(...n)=>new $t(n,this.opts).exec(this.client);xgroup=(...n)=>new qt(n,this.opts).exec(this.client);xread=(...n)=>new Wt(n,this.opts).exec(this.client);xreadgroup=(...n)=>new Qt(n,this.opts).exec(this.client);xinfo=(...n)=>new jt(n,this.opts).exec(this.client);xlen=(...n)=>new Yt(n,this.opts).exec(this.client);xpending=(...n)=>new Vt(n,this.opts).exec(this.client);xclaim=(...n)=>new Ft(n,this.opts).exec(this.client);xautoclaim=(...n)=>new Ht(n,this.opts).exec(this.client);xtrim=(...n)=>new te(n,this.opts).exec(this.client);xrange=(...n)=>new _t(n,this.opts).exec(this.client);xrevrange=(...n)=>new ne(n,this.opts).exec(this.client);zadd=(...n)=>\"score\"in n[1]?new l([n[0],n[1],...n.slice(2)],this.opts).exec(this.client):new l([n[0],n[1],...n.slice(2)],this.opts).exec(this.client);zcard=(...n)=>new ee(n,this.opts).exec(this.client);zcount=(...n)=>new oe(n,this.opts).exec(this.client);zdiffstore=(...n)=>new be(n,this.opts).exec(this.client);zincrby=(n,t,o)=>new se([n,t,o],this.opts).exec(this.client);zinterstore=(...n)=>new me(n,this.opts).exec(this.client);zlexcount=(...n)=>new re(n,this.opts).exec(this.client);zmscore=(...n)=>new Te(n,this.opts).exec(this.client);zpopmax=(...n)=>new ae(n,this.opts).exec(this.client);zpopmin=(...n)=>new ie(n,this.opts).exec(this.client);zrange=(...n)=>new pe(n,this.opts).exec(this.client);zrank=(n,t)=>new de([n,t],this.opts).exec(this.client);zrem=(n,...t)=>new ce([n,...t],this.opts).exec(this.client);zremrangebylex=(...n)=>new ue(n,this.opts).exec(this.client);zremrangebyrank=(...n)=>new he(n,this.opts).exec(this.client);zremrangebyscore=(...n)=>new le(n,this.opts).exec(this.client);zrevrank=(n,t)=>new Ce([n,t],this.opts).exec(this.client);zscan=(...n)=>new ge(n,this.opts).exec(this.client);zscore=(n,t)=>new xe([n,t],this.opts).exec(this.client);zunion=(...n)=>new fe(n,this.opts).exec(this.client);zunionstore=(...n)=>new ye(n,this.opts).exec(this.client)};var tg=\"v1.32.0\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9yZWRpcy9jaHVuay1ERlVBUFlCRy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkJBQTZCLGVBQWUsdUJBQXVCLHVCQUF1QixHQUFHLFVBQVUsT0FBTyxtQ0FBbUMsRUFBRSwwQkFBMEIsZUFBZSxtQ0FBbUMsd0JBQXdCLGVBQWUsaUhBQWlILEVBQUUsNkJBQTZCLGFBQWEsUUFBUSxRQUFRLFFBQVEsTUFBTSxlQUFlLGlCQUFpQiwrSUFBK0ksMEhBQTBILGNBQWMsK0NBQStDLDZJQUE2SSx5QkFBeUIsYUFBYSw4RUFBOEUsa0JBQWtCLGtCQUFrQixrREFBa0QsbU1BQW1NLGlCQUFpQixPQUFPLDRNQUE0TSxlQUFlLFlBQVksdUJBQXVCLFFBQVEsd0RBQXdELE1BQU0sU0FBUyxpQ0FBaUMsZ0NBQWdDLDZDQUE2QyxPQUFPLDZEQUE2RCxvQkFBb0IsTUFBTSw4REFBOEQsa0RBQWtELHFCQUFxQix3QkFBd0IsUUFBUSxpQkFBaUIsdUJBQXVCLEdBQUcsMEVBQTBFLGlCQUFpQixLQUFLLHFCQUFxQixJQUFJLGtDQUFrQyxLQUFLLGVBQWUsU0FBUyxJQUFJLDZDQUE2QyxZQUFZLElBQUkseUJBQXlCLDhCQUE4QixNQUFNLElBQUksU0FBUyxlQUFlLE1BQU0saUJBQWlCLHlCQUF5QixjQUFjLElBQUksTUFBTSxjQUFjLDBGQUEwRixNQUFNLGNBQWMsc0JBQXNCLE1BQU0sY0FBYyxTQUFTLGlCQUFpQixRQUFRLCtFQUErRSwwVEFBMFQsNkJBQTZCLHFDQUFxQyxFQUFFLGFBQWEsNkJBQTZCLG9CQUFvQix5QkFBeUIsTUFBTSxTQUFTLGtCQUFrQixlQUFlLHdDQUF3QywwQkFBMEIsaURBQWlELDJFQUEyRSxvQ0FBb0MsbURBQW1ELGtDQUFrQyxlQUFlLGdGQUFnRixvQ0FBb0MsTUFBTSx1QkFBdUIseURBQXlELGVBQWUsaUNBQWlDLElBQUksYUFBYSxNQUFNLFVBQVUsZ0JBQWdCLGdEQUFn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QUFxRCwyREFBMkQsdURBQXVELHVEQUF1RCxxREFBcUQsMERBQTBELDJEQUEyRCw0REFBNEQsdURBQXVELDJEQUEyRCxtREFBbUQsMERBQTBELDREQUE0RCxvREFBb0QscURBQXFELHFEQUFxRCwwREFBMEQsb0NBQW9DLG9EQUFvRCxrREFBa0QsbURBQW1ELHFEQUFxRCxtREFBbUQsbURBQW1ELG1EQUFtRCxxREFBcUQsb0RBQW9ELHlEQUF5RCxvREFBb0QsbURBQW1ELHVEQUF1RCxxREFBcUQseURBQXlELG9EQUFvRCxxREFBcUQsd0RBQXdELHNKQUFzSixvREFBb0QscURBQXFELHlEQUF5RCw2REFBNkQsMERBQTBELHdEQUF3RCxzREFBc0Qsc0RBQXNELHNEQUFzRCxxREFBcUQsdURBQXVELDREQUE0RCw2REFBNkQsOERBQThELCtEQUErRCwwREFBMEQsb0RBQW9ELHdEQUF3RCxxREFBcUQsMkRBQTJELGlCQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL3BpY2t1cF9saW5lX2dlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9yZWRpcy9jaHVuay1ERlVBUFlCRy5tanM/ZDYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTmU9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBMZT0ocyxuKT0+e2Zvcih2YXIgdCBpbiBuKU5lKHMsdCx7Z2V0Om5bdF0sZW51bWVyYWJsZTohMH0pfTt2YXIgemU9e307TGUoemUse1Vwc3Rhc2hFcnJvcjooKT0+dSxVcmxFcnJvcjooKT0+T2V9KTt2YXIgdT1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG4pe3N1cGVyKG4pLHRoaXMubmFtZT1cIlVwc3Rhc2hFcnJvclwifX0sT2U9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihuKXtzdXBlcihgVXBzdGFzaCBSZWRpcyBjbGllbnQgd2FzIHBhc3NlZCBhbiBpbnZhbGlkIFVSTC4gWW91IHNob3VsZCBwYXNzIHRoZSBVUkwgdG9nZXRoZXIgd2l0aCBodHRwcy4gUmVjZWl2ZWQ6IFwiJHtufVwiLiBgKSx0aGlzLm5hbWU9XCJVcmxFcnJvclwifX07dmFyIE1lPWNsYXNze2Jhc2VVcmw7aGVhZGVycztvcHRpb25zO3JldHJ5O2NvbnN0cnVjdG9yKG4pe2lmKHRoaXMub3B0aW9ucz17YmFja2VuZDpuLm9wdGlvbnM/LmJhY2tlbmQsYWdlbnQ6bi5hZ2VudCxyZXNwb25zZUVuY29kaW5nOm4ucmVzcG9uc2VFbmNvZGluZz8/XCJiYXNlNjRcIixjYWNoZTpuLmNhY2hlLHNpZ25hbDpuLnNpZ25hbCxrZWVwQWxpdmU6bi5rZWVwQWxpdmU/PyEwfSx0aGlzLmJhc2VVcmw9bi5iYXNlVXJsLnJlcGxhY2UoL1xcLyQvLFwiXCIpLCEvXmh0dHBzPzpcXC9cXC9bXlxccy8kLj8jXS5bXlxcc10qJC8udGVzdCh0aGlzLmJhc2VVcmwpKXRocm93IG5ldyBPZSh0aGlzLmJhc2VVcmwpO3RoaXMuaGVhZGVycz17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIiwuLi5uLmhlYWRlcnN9LHRoaXMub3B0aW9ucy5yZXNwb25zZUVuY29kaW5nPT09XCJiYXNlNjRcIiYmKHRoaXMuaGVhZGVyc1tcIlVwc3Rhc2gtRW5jb2RpbmdcIl09XCJiYXNlNjRcIiksdHlwZW9mIG4/LnJldHJ5PT1cImJvb2xlYW5cIiYmbj8ucmV0cnk9PT0hMT90aGlzLnJldHJ5PXthdHRlbXB0czoxLGJhY2tvZmY6KCk9PjB9OnRoaXMucmV0cnk9e2F0dGVtcHRzOm4/LnJldHJ5Py5yZXRyaWVzPz81LGJhY2tvZmY6bj8ucmV0cnk/LmJhY2tvZmY/PyhvPT5NYXRoLmV4cChvKSo1MCl9fW1lcmdlVGVsZW1ldHJ5KG4pe2Z1bmN0aW9uIHQobyxtLHIpe3JldHVybiByJiYob1ttXT9vW21dPVtvW21dLHJdLmpvaW4oXCIsXCIpOm9bbV09ciksb310aGlzLmhlYWRlcnM9dCh0aGlzLmhlYWRlcnMsXCJVcHN0YXNoLVRlbGVtZXRyeS1SdW50aW1lXCIsbi5ydW50aW1lKSx0aGlzLmhlYWRlcnM9dCh0aGlzLmhlYWRlcnMsXCJVcHN0YXNoLVRlbGVtZXRyeS1QbGF0Zm9ybVwiLG4ucGxhdGZvcm0pLHRoaXMuaGVhZGVycz10KHRoaXMuaGVhZGVycyxcIlVwc3Rhc2gtVGVsZW1ldHJ5LVNka1wiLG4uc2RrKX1hc3luYyByZXF1ZXN0KG4pe2xldCB0PXtjYWNoZTp0aGlzLm9wdGlvbnMuY2FjaGUsbWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6dGhpcy5oZWFkZXJzLGJvZHk6SlNPTi5zdHJpbmdpZnkobi5ib2R5KSxrZWVwYWxpdmU6dGhpcy5vcHRpb25zLmtlZXBBbGl2ZSxhZ2VudDp0aGlzLm9wdGlvbnM/LmFnZW50LHNpZ25hbDp0aGlzLm9wdGlvbnMuc2lnbmFsLGJhY2tlbmQ6dGhpcy5vcHRpb25zPy5iYWNrZW5kfSxvPW51bGwsbT1udWxsO2ZvcihsZXQgYT0wO2E8PXRoaXMucmV0cnkuYXR0ZW1wdHM7YSsrKXRyeXtvPWF3YWl0IGZldGNoKFt0aGlzLmJhc2VVcmwsLi4ubi5wYXRoPz9bXV0uam9pbihcIi9cIiksdCk7YnJlYWt9Y2F0Y2goaSl7aWYodGhpcy5vcHRpb25zLnNpZ25hbD8uYWJvcnRlZCl7bGV0IHA9bmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHtyZXN1bHQ6dGhpcy5vcHRpb25zLnNpZ25hbC5yZWFzb24/P1wiQWJvcnRlZFwifSldKSxkPXtzdGF0dXM6MjAwLHN0YXR1c1RleHQ6dGhpcy5vcHRpb25zLnNpZ25hbC5yZWFzb24/P1wiQWJvcnRlZFwifTtvPW5ldyBSZXNwb25zZShwLGQpO2JyZWFrfW09aSxhd2FpdCBuZXcgUHJvbWlzZShwPT5zZXRUaW1lb3V0KHAsdGhpcy5yZXRyeS5iYWNrb2ZmKGEpKSl9aWYoIW8pdGhyb3cgbT8/bmV3IEVycm9yKFwiRXhoYXVzdGVkIGFsbCByZXRyaWVzXCIpO2xldCByPWF3YWl0IG8uanNvbigpO2lmKCFvLm9rKXRocm93IG5ldyB1KGAke3IuZXJyb3J9LCBjb21tYW5kIHdhczogJHtKU09OLnN0cmluZ2lmeShuLmJvZHkpfWApO3JldHVybiB0aGlzLm9wdGlvbnM/LnJlc3BvbnNlRW5jb2Rpbmc9PT1cImJhc2U2NFwiP0FycmF5LmlzQXJyYXkocik/ci5tYXAoKHtyZXN1bHQ6aSxlcnJvcjpwfSk9Pih7cmVzdWx0OmtlKGkpLGVycm9yOnB9KSk6e3Jlc3VsdDprZShyLnJlc3VsdCksZXJyb3I6ci5lcnJvcn06cn19O2Z1bmN0aW9uIHZlKHMpe2xldCBuPVwiXCI7dHJ5e2xldCB0PWF0b2Iocyksbz10Lmxlbmd0aCxtPW5ldyBVaW50OEFycmF5KG8pO2ZvcihsZXQgcj0wO3I8bztyKyspbVtyXT10LmNoYXJDb2RlQXQocik7bj1uZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobSl9Y2F0Y2h7bj1zfXJldHVybiBufWZ1bmN0aW9uIGtlKHMpe2xldCBuO3N3aXRjaCh0eXBlb2Ygcyl7Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIHM7Y2FzZVwibnVtYmVyXCI6e249czticmVha31jYXNlXCJvYmplY3RcIjp7QXJyYXkuaXNBcnJheShzKT9uPXMubWFwKHQ9PnR5cGVvZiB0PT1cInN0cmluZ1wiP3ZlKHQpOkFycmF5LmlzQXJyYXkodCk/dC5tYXAoa2UpOnQpOm49bnVsbDticmVha31jYXNlXCJzdHJpbmdcIjp7bj1zPT09XCJPS1wiP1wiT0tcIjp2ZShzKTticmVha31kZWZhdWx0OmJyZWFrfXJldHVybiBufWZ1bmN0aW9uIFNlKHMsbil7bGV0IHQ9cztyZXR1cm4gdC5hdXRvUGlwZWxpbmVFeGVjdXRvcnx8KHQuYXV0b1BpcGVsaW5lRXhlY3V0b3I9bmV3IFJlKHQpKSxuZXcgUHJveHkodCx7Z2V0OihvLG0pPT5tPT09XCJwaXBlbGluZUNvdW50ZXJcIj9vLmF1dG9QaXBlbGluZUV4ZWN1dG9yLnBpcGVsaW5lQ291bnRlcjptPT09XCJqc29uXCI/U2UobywhMCk6bSBpbiBvJiYhKG0gaW4gby5hdXRvUGlwZWxpbmVFeGVjdXRvci5waXBlbGluZSk/b1ttXToobj90eXBlb2Ygby5hdXRvUGlwZWxpbmVFeGVjdXRvci5waXBlbGluZS5qc29uW21dPT1cImZ1bmN0aW9uXCI6dHlwZW9mIG8uYXV0b1BpcGVsaW5lRXhlY3V0b3IucGlwZWxpbmVbbV09PVwiZnVuY3Rpb25cIik/KC4uLmkpPT5vLmF1dG9QaXBlbGluZUV4ZWN1dG9yLndpdGhBdXRvUGlwZWxpbmUocD0+e24/cC5qc29uW21dKC4uLmkpOnBbbV0oLi4uaSl9KTpvLmF1dG9QaXBlbGluZUV4ZWN1dG9yLnBpcGVsaW5lW21dfSl9dmFyIFJlPWNsYXNze3BpcGVsaW5lUHJvbWlzZXM9bmV3IFdlYWtNYXA7YWN0aXZlUGlwZWxpbmU9bnVsbDtpbmRleEluQ3VycmVudFBpcGVsaW5lPTA7cmVkaXM7cGlwZWxpbmU7cGlwZWxpbmVDb3VudGVyPTA7Y29uc3RydWN0b3Iobil7dGhpcy5yZWRpcz1uLHRoaXMucGlwZWxpbmU9bi5waXBlbGluZSgpfWFzeW5jIHdpdGhBdXRvUGlwZWxpbmUobil7bGV0IHQ9dGhpcy5hY3RpdmVQaXBlbGluZXx8dGhpcy5yZWRpcy5waXBlbGluZSgpO3RoaXMuYWN0aXZlUGlwZWxpbmV8fCh0aGlzLmFjdGl2ZVBpcGVsaW5lPXQsdGhpcy5pbmRleEluQ3VycmVudFBpcGVsaW5lPTApO2xldCBvPXRoaXMuaW5kZXhJbkN1cnJlbnRQaXBlbGluZSsrO3JldHVybiBuKHQpLChhd2FpdCB0aGlzLmRlZmVyRXhlY3V0aW9uKCkudGhlbigoKT0+e2lmKCF0aGlzLnBpcGVsaW5lUHJvbWlzZXMuaGFzKHQpKXtsZXQgYT10LmV4ZWMoKTt0aGlzLnBpcGVsaW5lQ291bnRlcis9MSx0aGlzLnBpcGVsaW5lUHJvbWlzZXMuc2V0KHQsYSksdGhpcy5hY3RpdmVQaXBlbGluZT1udWxsfXJldHVybiB0aGlzLnBpcGVsaW5lUHJvbWlzZXMuZ2V0KHQpfSkpW29dfWFzeW5jIGRlZmVyRXhlY3V0aW9uKCl7cmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLGF3YWl0IFByb21pc2UucmVzb2x2ZSgpfX07ZnVuY3Rpb24gUGUocyl7bGV0IG49QXJyYXkuaXNBcnJheShzKT9zLm1hcCh0PT57dHJ5e3JldHVybiBQZSh0KX1jYXRjaHtyZXR1cm4gdH19KTpKU09OLnBhcnNlKHMpO3JldHVybiB0eXBlb2Ygbj09XCJudW1iZXJcIiYmbi50b1N0cmluZygpIT09cz9zOm59ZnVuY3Rpb24gRWUocyl7dHJ5e3JldHVybiBQZShzKX1jYXRjaHtyZXR1cm4gc319ZnVuY3Rpb24gaChzKXtyZXR1cm5bc1swXSwuLi5FZShzLnNsaWNlKDEpKV19dmFyIEdlPXM9Pntzd2l0Y2godHlwZW9mIHMpe2Nhc2VcInN0cmluZ1wiOmNhc2VcIm51bWJlclwiOmNhc2VcImJvb2xlYW5cIjpyZXR1cm4gcztkZWZhdWx0OnJldHVybiBKU09OLnN0cmluZ2lmeShzKX19LGU9Y2xhc3N7Y29tbWFuZDtzZXJpYWxpemU7ZGVzZXJpYWxpemU7Y29uc3RydWN0b3Iobix0KXtpZih0aGlzLnNlcmlhbGl6ZT1HZSx0aGlzLmRlc2VyaWFsaXplPXR5cGVvZiB0Py5hdXRvbWF0aWNEZXNlcmlhbGl6YXRpb24+XCJ1XCJ8fHQuYXV0b21hdGljRGVzZXJpYWxpemF0aW9uP3Q/LmRlc2VyaWFsaXplPz9FZTpvPT5vLHRoaXMuY29tbWFuZD1uLm1hcChvPT50aGlzLnNlcmlhbGl6ZShvKSksdD8ubGF0ZW5jeUxvZ2dpbmcpe2xldCBvPXRoaXMuZXhlYy5iaW5kKHRoaXMpO3RoaXMuZXhlYz1hc3luYyBtPT57bGV0IHI9cGVyZm9ybWFuY2Uubm93KCksYT1hd2FpdCBvKG0pLHA9KHBlcmZvcm1hbmNlLm5vdygpLXIpLnRvRml4ZWQoMik7cmV0dXJuIGNvbnNvbGUubG9nKGBMYXRlbmN5IGZvciBcXHgxQlszODsyOzE5OzE4NTszOW0ke3RoaXMuY29tbWFuZFswXS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCl9XFx4MUJbMG06IFxceDFCWzM4OzI7MDsyNTU7MjU1bSR7cH0gbXNcXHgxQlswbWApLGF9fX1hc3luYyBleGVjKG4pe2xldHtyZXN1bHQ6dCxlcnJvcjpvfT1hd2FpdCBuLnJlcXVlc3Qoe2JvZHk6dGhpcy5jb21tYW5kfSk7aWYobyl0aHJvdyBuZXcgdShvKTtpZih0eXBlb2YgdD5cInVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGRpZCBub3QgcmV0dXJuIGEgcmVzdWx0XCIpO3JldHVybiB0aGlzLmRlc2VyaWFsaXplKHQpfX07dmFyIGc9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiYXBwZW5kXCIsLi4ubl0sdCl9fTt2YXIgeD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvXSxtKXtsZXQgcj1bXCJiaXRjb3VudFwiLG5dO3R5cGVvZiB0PT1cIm51bWJlclwiJiZyLnB1c2godCksdHlwZW9mIG89PVwibnVtYmVyXCImJnIucHVzaChvKSxzdXBlcihyLG0pfX07dmFyIGY9Y2xhc3N7Y29uc3RydWN0b3Iobix0LG8sbT1yPT5yLmV4ZWModGhpcy5jbGllbnQpKXt0aGlzLmNsaWVudD10O3RoaXMub3B0cz1vO3RoaXMuZXhlY09wZXJhdGlvbj1tO3RoaXMuY29tbWFuZD1bXCJiaXRmaWVsZFwiLC4uLm5dfWNvbW1hbmQ7Y2hhaW4oLi4ubil7cmV0dXJuIHRoaXMuY29tbWFuZC5wdXNoKC4uLm4pLHRoaXN9Z2V0KC4uLm4pe3JldHVybiB0aGlzLmNoYWluKFwiZ2V0XCIsLi4ubil9c2V0KC4uLm4pe3JldHVybiB0aGlzLmNoYWluKFwic2V0XCIsLi4ubil9aW5jcmJ5KC4uLm4pe3JldHVybiB0aGlzLmNoYWluKFwiaW5jcmJ5XCIsLi4ubil9b3ZlcmZsb3cobil7cmV0dXJuIHRoaXMuY2hhaW4oXCJvdmVyZmxvd1wiLG4pfWV4ZWMoKXtsZXQgbj1uZXcgZSh0aGlzLmNvbW1hbmQsdGhpcy5vcHRzKTtyZXR1cm4gdGhpcy5leGVjT3BlcmF0aW9uKG4pfX07dmFyIHk9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiYml0b3BcIiwuLi5uXSx0KX19O3ZhciBiPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImJpdHBvc1wiLC4uLm5dLHQpfX07dmFyIFQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsb10sbSl7c3VwZXIoW1wiQ09QWVwiLG4sdCwuLi5vPy5yZXBsYWNlP1tcIlJFUExBQ0VcIl06W11dLHsuLi5tLGRlc2VyaWFsaXplKHIpe3JldHVybiByPjA/XCJDT1BJRURcIjpcIk5PVF9DT1BJRURcIn19KX19O3ZhciBPPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuKXtzdXBlcihbXCJkYnNpemVcIl0sbil9fTt2YXIgdz1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJkZWNyXCIsLi4ubl0sdCl9fTt2YXIgRD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJkZWNyYnlcIiwuLi5uXSx0KX19O3ZhciBBPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImRlbFwiLC4uLm5dLHQpfX07dmFyIGs9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiZWNob1wiLC4uLm5dLHQpfX07dmFyIFI9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsb10sbSl7c3VwZXIoW1wiZXZhbFwiLG4sdC5sZW5ndGgsLi4udCwuLi5vPz9bXV0sbSl9fTt2YXIgUz1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvXSxtKXtzdXBlcihbXCJldmFsc2hhXCIsbix0Lmxlbmd0aCwuLi50LC4uLm8/P1tdXSxtKX19O3ZhciBFPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImV4aXN0c1wiLC4uLm5dLHQpfX07dmFyIE09Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiZXhwaXJlXCIsLi4ubi5maWx0ZXIoQm9vbGVhbildLHQpfX07dmFyIHY9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiZXhwaXJlYXRcIiwuLi5uXSx0KX19O3ZhciBQPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe2xldCBvPVtcImZsdXNoYWxsXCJdO24mJm4ubGVuZ3RoPjAmJm5bMF0uYXN5bmMmJm8ucHVzaChcImFzeW5jXCIpLHN1cGVyKG8sdCl9fTt2YXIgST1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW25dLHQpe2xldCBvPVtcImZsdXNoZGJcIl07bj8uYXN5bmMmJm8ucHVzaChcImFzeW5jXCIpLHN1cGVyKG8sdCl9fTt2YXIgTj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCwuLi5vXSxtKXtsZXQgcj1bXCJnZW9hZGRcIixuXTtcIm54XCJpbiB0JiZ0Lm54P3IucHVzaChcIm54XCIpOlwieHhcImluIHQmJnQueHgmJnIucHVzaChcInh4XCIpLFwiY2hcImluIHQmJnQuY2gmJnIucHVzaChcImNoXCIpLFwibGF0aXR1ZGVcImluIHQmJnQubGF0aXR1ZGUmJnIucHVzaCh0LmxvbmdpdHVkZSx0LmxhdGl0dWRlLHQubWVtYmVyKSxyLnB1c2goLi4uby5mbGF0TWFwKCh7bGF0aXR1ZGU6YSxsb25naXR1ZGU6aSxtZW1iZXI6cH0pPT5baSxhLHBdKSksc3VwZXIocixtKX19O3ZhciBMPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG8sbT1cIk1cIl0scil7c3VwZXIoW1wiR0VPRElTVFwiLG4sdCxvLG1dLHIpfX07dmFyIHo9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0W29dPW4sbT1BcnJheS5pc0FycmF5KG5bMV0pP25bMV06bi5zbGljZSgxKTtzdXBlcihbXCJHRU9IQVNIXCIsbywuLi5tXSx0KX19O3ZhciBHPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe2xldFtvXT1uLG09QXJyYXkuaXNBcnJheShuWzFdKT9uWzFdOm4uc2xpY2UoMSk7c3VwZXIoW1wiR0VPUE9TXCIsbywuLi5tXSx7ZGVzZXJpYWxpemU6cj0+S2UociksLi4udH0pfX07ZnVuY3Rpb24gS2Uocyl7bGV0IG49W107Zm9yKGxldCB0IG9mIHMpIXQ/LlswXXx8IXQ/LlsxXXx8bi5wdXNoKHtsbmc6cGFyc2VGbG9hdCh0WzBdKSxsYXQ6cGFyc2VGbG9hdCh0WzFdKX0pO3JldHVybiBufXZhciBLPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG8sbSxyXSxhKXtsZXQgaT1bXCJHRU9TRUFSQ0hcIixuXTsodC50eXBlPT09XCJGUk9NTUVNQkVSXCJ8fHQudHlwZT09PVwiZnJvbW1lbWJlclwiKSYmaS5wdXNoKHQudHlwZSx0Lm1lbWJlciksKHQudHlwZT09PVwiRlJPTUxPTkxBVFwifHx0LnR5cGU9PT1cImZyb21sb25sYXRcIikmJmkucHVzaCh0LnR5cGUsdC5jb29yZGluYXRlLmxvbix0LmNvb3JkaW5hdGUubGF0KSwoby50eXBlPT09XCJCWVJBRElVU1wifHxvLnR5cGU9PT1cImJ5cmFkaXVzXCIpJiZpLnB1c2goby50eXBlLG8ucmFkaXVzLG8ucmFkaXVzVHlwZSksKG8udHlwZT09PVwiQllCT1hcInx8by50eXBlPT09XCJieWJveFwiKSYmaS5wdXNoKG8udHlwZSxvLnJlY3Qud2lkdGgsby5yZWN0LmhlaWdodCxvLnJlY3RUeXBlKSxpLnB1c2gobSkscj8uY291bnQmJmkucHVzaChcIkNPVU5UXCIsci5jb3VudC5saW1pdCwuLi5yLmNvdW50LmFueT9bXCJBTllcIl06W10pO2xldCBwPWQ9PiFyPy53aXRoQ29vcmQmJiFyPy53aXRoRGlzdCYmIXI/LndpdGhIYXNoP2QubWFwKGM9Pnt0cnl7cmV0dXJue21lbWJlcjpKU09OLnBhcnNlKGMpfX1jYXRjaHtyZXR1cm57bWVtYmVyOmN9fX0pOmQubWFwKGM9PntsZXQgRGU9MSxDPXt9O3RyeXtDLm1lbWJlcj1KU09OLnBhcnNlKGNbMF0pfWNhdGNoe0MubWVtYmVyPWNbMF19cmV0dXJuIHIud2l0aERpc3QmJihDLmRpc3Q9cGFyc2VGbG9hdChjW0RlKytdKSksci53aXRoSGFzaCYmKEMuaGFzaD1jW0RlKytdLnRvU3RyaW5nKCkpLHIud2l0aENvb3JkJiYoQy5jb29yZD17bG9uZzpwYXJzZUZsb2F0KGNbRGVdWzBdKSxsYXQ6cGFyc2VGbG9hdChjW0RlXVsxXSl9KSxDfSk7c3VwZXIoWy4uLmksLi4ucj8ud2l0aENvb3JkP1tcIldJVEhDT09SRFwiXTpbXSwuLi5yPy53aXRoRGlzdD9bXCJXSVRIRElTVFwiXTpbXSwuLi5yPy53aXRoSGFzaD9bXCJXSVRISEFTSFwiXTpbXV0se2Rlc2VyaWFsaXplOnAsLi4uYX0pfX07dmFyIFg9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsbyxtLHIsYV0saSl7bGV0IHA9W1wiR0VPU0VBUkNIU1RPUkVcIixuLHRdOyhvLnR5cGU9PT1cIkZST01NRU1CRVJcInx8by50eXBlPT09XCJmcm9tbWVtYmVyXCIpJiZwLnB1c2goby50eXBlLG8ubWVtYmVyKSwoby50eXBlPT09XCJGUk9NTE9OTEFUXCJ8fG8udHlwZT09PVwiZnJvbWxvbmxhdFwiKSYmcC5wdXNoKG8udHlwZSxvLmNvb3JkaW5hdGUubG9uLG8uY29vcmRpbmF0ZS5sYXQpLChtLnR5cGU9PT1cIkJZUkFESVVTXCJ8fG0udHlwZT09PVwiYnlyYWRpdXNcIikmJnAucHVzaChtLnR5cGUsbS5yYWRpdXMsbS5yYWRpdXNUeXBlKSwobS50eXBlPT09XCJCWUJPWFwifHxtLnR5cGU9PT1cImJ5Ym94XCIpJiZwLnB1c2gobS50eXBlLG0ucmVjdC53aWR0aCxtLnJlY3QuaGVpZ2h0LG0ucmVjdFR5cGUpLHAucHVzaChyKSxhPy5jb3VudCYmcC5wdXNoKFwiQ09VTlRcIixhLmNvdW50LmxpbWl0LC4uLmEuY291bnQuYW55P1tcIkFOWVwiXTpbXSksc3VwZXIoWy4uLnAsLi4uYT8uc3RvcmVEaXN0P1tcIlNUT1JFRElTVFwiXTpbXV0saSl9fTt2YXIgVT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJnZXRcIiwuLi5uXSx0KX19O3ZhciBKPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImdldGJpdFwiLC4uLm5dLHQpfX07dmFyIEI9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiZ2V0ZGVsXCIsLi4ubl0sdCl9fTt2YXIgWj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJnZXRyYW5nZVwiLC4uLm5dLHQpfX07dmFyIEg9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiZ2V0c2V0XCIsLi4ubl0sdCl9fTt2YXIgRj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJoZGVsXCIsLi4ubl0sdCl9fTt2YXIgJD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJoZXhpc3RzXCIsLi4ubl0sdCl9fTt2YXIgcT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJoZ2V0XCIsLi4ubl0sdCl9fTtmdW5jdGlvbiBYZShzKXtpZihzLmxlbmd0aD09PTApcmV0dXJuIG51bGw7bGV0IG49e307Zm9yKDtzLmxlbmd0aD49Mjspe2xldCB0PXMuc2hpZnQoKSxvPXMuc2hpZnQoKTt0cnl7IU51bWJlci5pc05hTihOdW1iZXIobykpJiYhTnVtYmVyLmlzU2FmZUludGVnZXIoTnVtYmVyKG8pKT9uW3RdPW86blt0XT1KU09OLnBhcnNlKG8pfWNhdGNoe25bdF09b319cmV0dXJuIG59dmFyIGo9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiaGdldGFsbFwiLC4uLm5dLHtkZXNlcmlhbGl6ZTpvPT5YZShvKSwuLi50fSl9fTt2YXIgWT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJoaW5jcmJ5XCIsLi4ubl0sdCl9fTt2YXIgVj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJoaW5jcmJ5ZmxvYXRcIiwuLi5uXSx0KX19O3ZhciBfPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbl0sdCl7c3VwZXIoW1wiaGtleXNcIixuXSx0KX19O3ZhciBXPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImhsZW5cIiwuLi5uXSx0KX19O2Z1bmN0aW9uIFVlKHMsbil7aWYobi5sZW5ndGg9PT0wfHxuLmV2ZXJ5KG89Pm89PT1udWxsKSlyZXR1cm4gbnVsbDtsZXQgdD17fTtmb3IobGV0IG89MDtvPHMubGVuZ3RoO28rKyl0cnl7dFtzW29dXT1KU09OLnBhcnNlKG5bb10pfWNhdGNoe3Rbc1tvXV09bltvXX1yZXR1cm4gdH12YXIgUT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sLi4udF0sbyl7c3VwZXIoW1wiaG1nZXRcIixuLC4uLnRdLHtkZXNlcmlhbGl6ZTptPT5VZSh0LG0pLC4uLm99KX19O3ZhciBubj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdF0sbyl7c3VwZXIoW1wiaG1zZXRcIixuLC4uLk9iamVjdC5lbnRyaWVzKHQpLmZsYXRNYXAoKFttLHJdKT0+W20scl0pXSxvKX19O2Z1bmN0aW9uIEplKHMpe2lmKHMubGVuZ3RoPT09MClyZXR1cm4gbnVsbDtsZXQgbj17fTtmb3IoO3MubGVuZ3RoPj0yOyl7bGV0IHQ9cy5zaGlmdCgpLG89cy5zaGlmdCgpO3RyeXtuW3RdPUpTT04ucGFyc2Uobyl9Y2F0Y2h7blt0XT1vfX1yZXR1cm4gbn12YXIgdG49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0IG89W1wiaHJhbmRmaWVsZFwiLG5bMF1dO3R5cGVvZiBuWzFdPT1cIm51bWJlclwiJiZvLnB1c2goblsxXSksblsyXSYmby5wdXNoKFwiV0lUSFZBTFVFU1wiKSxzdXBlcihvLHtkZXNlcmlhbGl6ZTpuWzJdP209PkplKG0pOnQ/LmRlc2VyaWFsaXplLC4uLnR9KX19O3ZhciBlbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvXSxtKXtsZXQgcj1bXCJoc2NhblwiLG4sdF07bz8ubWF0Y2gmJnIucHVzaChcIm1hdGNoXCIsby5tYXRjaCksdHlwZW9mIG8/LmNvdW50PT1cIm51bWJlclwiJiZyLnB1c2goXCJjb3VudFwiLG8uY291bnQpLHN1cGVyKHIse2Rlc2VyaWFsaXplOmgsLi4ubX0pfX07dmFyIG9uPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0XSxvKXtzdXBlcihbXCJoc2V0XCIsbiwuLi5PYmplY3QuZW50cmllcyh0KS5mbGF0TWFwKChbbSxyXSk9PlttLHJdKV0sbyl9fTt2YXIgc249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiaHNldG54XCIsLi4ubl0sdCl9fTt2YXIgbW49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiaHN0cmxlblwiLC4uLm5dLHQpfX07dmFyIHJuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImh2YWxzXCIsLi4ubl0sdCl9fTt2YXIgYW49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiaW5jclwiLC4uLm5dLHQpfX07dmFyIHBuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImluY3JieVwiLC4uLm5dLHQpfX07dmFyIGRuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImluY3JieWZsb2F0XCIsLi4ubl0sdCl9fTt2YXIgY249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5BUlJBUFBFTkRcIiwuLi5uXSx0KX19O3ZhciB1bj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLkFSUklOREVYXCIsLi4ubl0sdCl9fTt2YXIgaG49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5BUlJJTlNFUlRcIiwuLi5uXSx0KX19O3ZhciBsbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLkFSUkxFTlwiLG5bMF0sblsxXT8/XCIkXCJdLHQpfX07dmFyIENuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcIkpTT04uQVJSUE9QXCIsLi4ubl0sdCl9fTt2YXIgZ249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0IG89blsxXT8/XCIkXCIsbT1uWzJdPz8wLHI9blszXT8/MDtzdXBlcihbXCJKU09OLkFSUlRSSU1cIixuWzBdLG8sbSxyXSx0KX19O3ZhciB4bj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLkNMRUFSXCIsLi4ubl0sdCl9fTt2YXIgZm49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5ERUxcIiwuLi5uXSx0KX19O3ZhciB5bj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLkZPUkdFVFwiLC4uLm5dLHQpfX07dmFyIGJuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe2xldCBvPVtcIkpTT04uR0VUXCJdO3R5cGVvZiBuWzFdPT1cInN0cmluZ1wiP28ucHVzaCguLi5uKTooby5wdXNoKG5bMF0pLG5bMV0mJihuWzFdLmluZGVudCYmby5wdXNoKFwiSU5ERU5UXCIsblsxXS5pbmRlbnQpLG5bMV0ubmV3bGluZSYmby5wdXNoKFwiTkVXTElORVwiLG5bMV0ubmV3bGluZSksblsxXS5zcGFjZSYmby5wdXNoKFwiU1BBQ0VcIixuWzFdLnNwYWNlKSksby5wdXNoKC4uLm4uc2xpY2UoMikpKSxzdXBlcihvLHQpfX07dmFyIFRuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcIkpTT04uTUdFVFwiLC4uLm5bMF0sblsxXV0sdCl9fTt2YXIgT249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5OVU1JTkNSQllcIiwuLi5uXSx0KX19O3ZhciB3bj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLk5VTU1VTFRCWVwiLC4uLm5dLHQpfX07dmFyIERuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcIkpTT04uT0JKS0VZU1wiLC4uLm5dLHQpfX07dmFyIEFuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcIkpTT04uT0JKTEVOXCIsLi4ubl0sdCl9fTt2YXIga249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5SRVNQXCIsLi4ubl0sdCl9fTt2YXIgUm49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0IG89W1wiSlNPTi5TRVRcIixuWzBdLG5bMV0sblsyXV07blszXSYmKG5bM10ubng/by5wdXNoKFwiTlhcIik6blszXS54eCYmby5wdXNoKFwiWFhcIikpLHN1cGVyKG8sdCl9fTt2YXIgU249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5TVFJBUFBFTkRcIiwuLi5uXSx0KX19O3ZhciBFbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJKU09OLlNUUkxFTlwiLC4uLm5dLHQpfX07dmFyIE1uPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcIkpTT04uVE9HR0xFXCIsLi4ubl0sdCl9fTt2YXIgdm49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiSlNPTi5UWVBFXCIsLi4ubl0sdCl9fTt2YXIgUG49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wia2V5c1wiLC4uLm5dLHQpfX07dmFyIEluPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImxpbmRleFwiLC4uLm5dLHQpfX07dmFyIE5uPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImxpbnNlcnRcIiwuLi5uXSx0KX19O3ZhciBMbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJsbGVuXCIsLi4ubl0sdCl9fTt2YXIgem49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wibG1vdmVcIiwuLi5uXSx0KX19O3ZhciBHbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtsZXRbbyxtLHIsYV09bjtzdXBlcihbXCJMTVBPUFwiLG8sLi4ubSxyLC4uLmE/W1wiQ09VTlRcIixhXTpbXV0sdCl9fTt2YXIgS249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wibHBvcFwiLC4uLm5dLHQpfX07dmFyIFhuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe2xldCBvPVtcImxwb3NcIixuWzBdLG5bMV1dO3R5cGVvZiBuWzJdPy5yYW5rPT1cIm51bWJlclwiJiZvLnB1c2goXCJyYW5rXCIsblsyXS5yYW5rKSx0eXBlb2YgblsyXT8uY291bnQ9PVwibnVtYmVyXCImJm8ucHVzaChcImNvdW50XCIsblsyXS5jb3VudCksdHlwZW9mIG5bMl0/Lm1heExlbj09XCJudW1iZXJcIiYmby5wdXNoKFwibWF4TGVuXCIsblsyXS5tYXhMZW4pLHN1cGVyKG8sdCl9fTt2YXIgVW49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wibHB1c2hcIiwuLi5uXSx0KX19O3ZhciBKbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJscHVzaHhcIiwuLi5uXSx0KX19O3ZhciBCbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJscmFuZ2VcIiwuLi5uXSx0KX19O3ZhciBabj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJscmVtXCIsLi4ubl0sdCl9fTt2YXIgSG49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wibHNldFwiLC4uLm5dLHQpfX07dmFyIEZuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcImx0cmltXCIsLi4ubl0sdCl9fTt2YXIgJG49Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0IG89QXJyYXkuaXNBcnJheShuWzBdKT9uWzBdOm47c3VwZXIoW1wibWdldFwiLC4uLm9dLHQpfX07dmFyIHFuPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbl0sdCl7c3VwZXIoW1wibXNldFwiLC4uLk9iamVjdC5lbnRyaWVzKG4pLmZsYXRNYXAoKFtvLG1dKT0+W28sbV0pXSx0KX19O3ZhciBqbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW25dLHQpe3N1cGVyKFtcIm1zZXRueFwiLC4uLk9iamVjdC5lbnRyaWVzKG4pLmZsYXRNYXAobz0+byldLHQpfX07dmFyIFluPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInBlcnNpc3RcIiwuLi5uXSx0KX19O3ZhciBWbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJwZXhwaXJlXCIsLi4ubl0sdCl9fTt2YXIgX249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicGV4cGlyZWF0XCIsLi4ubl0sdCl9fTt2YXIgV249Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicGZhZGRcIiwuLi5uXSx0KX19O3ZhciBRbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJwZmNvdW50XCIsLi4ubl0sdCl9fTt2YXIgbnQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicGZtZXJnZVwiLC4uLm5dLHQpfX07dmFyIHR0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe2xldCBvPVtcInBpbmdcIl07dHlwZW9mIG48XCJ1XCImJnR5cGVvZiBuWzBdPFwidVwiJiZvLnB1c2goblswXSksc3VwZXIobyx0KX19O3ZhciBldD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJwc2V0ZXhcIiwuLi5uXSx0KX19O3ZhciBvdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJwdHRsXCIsLi4ubl0sdCl9fTt2YXIgc3Q9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicHVibGlzaFwiLC4uLm5dLHQpfX07dmFyIG10PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuKXtzdXBlcihbXCJyYW5kb21rZXlcIl0sbil9fTt2YXIgcnQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicmVuYW1lXCIsLi4ubl0sdCl9fTt2YXIgYXQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicmVuYW1lbnhcIiwuLi5uXSx0KX19O3ZhciBpdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJycG9wXCIsLi4ubl0sdCl9fTt2YXIgcHQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wicnB1c2hcIiwuLi5uXSx0KX19O3ZhciBkdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJycHVzaHhcIiwuLi5uXSx0KX19O3ZhciBjdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzYWRkXCIsLi4ubl0sdCl9fTt2YXIgdXQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHRdLG8pe2xldCBtPVtcInNjYW5cIixuXTt0Py5tYXRjaCYmbS5wdXNoKFwibWF0Y2hcIix0Lm1hdGNoKSx0eXBlb2YgdD8uY291bnQ9PVwibnVtYmVyXCImJm0ucHVzaChcImNvdW50XCIsdC5jb3VudCksdD8udHlwZSYmdC50eXBlLmxlbmd0aD4wJiZtLnB1c2goXCJ0eXBlXCIsdC50eXBlKSxzdXBlcihtLHtkZXNlcmlhbGl6ZTpoLC4uLm99KX19O3ZhciBodD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzY2FyZFwiLC4uLm5dLHQpfX07dmFyIGx0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInNjcmlwdFwiLFwiZXhpc3RzXCIsLi4ubl0se2Rlc2VyaWFsaXplOm89Pm8sLi4udH0pfX07dmFyIEN0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbl0sdCl7bGV0IG89W1wic2NyaXB0XCIsXCJmbHVzaFwiXTtuPy5zeW5jP28ucHVzaChcInN5bmNcIik6bj8uYXN5bmMmJm8ucHVzaChcImFzeW5jXCIpLHN1cGVyKG8sdCl9fTt2YXIgZ3Q9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic2NyaXB0XCIsXCJsb2FkXCIsLi4ubl0sdCl9fTt2YXIgeHQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic2RpZmZcIiwuLi5uXSx0KX19O3ZhciBmdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzZGlmZnN0b3JlXCIsLi4ubl0sdCl9fTt2YXIgeXQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsb10sbSl7bGV0IHI9W1wic2V0XCIsbix0XTtvJiYoXCJueFwiaW4gbyYmby5ueD9yLnB1c2goXCJueFwiKTpcInh4XCJpbiBvJiZvLnh4JiZyLnB1c2goXCJ4eFwiKSxcImdldFwiaW4gbyYmby5nZXQmJnIucHVzaChcImdldFwiKSxcImV4XCJpbiBvJiZ0eXBlb2Ygby5leD09XCJudW1iZXJcIj9yLnB1c2goXCJleFwiLG8uZXgpOlwicHhcImluIG8mJnR5cGVvZiBvLnB4PT1cIm51bWJlclwiP3IucHVzaChcInB4XCIsby5weCk6XCJleGF0XCJpbiBvJiZ0eXBlb2Ygby5leGF0PT1cIm51bWJlclwiP3IucHVzaChcImV4YXRcIixvLmV4YXQpOlwicHhhdFwiaW4gbyYmdHlwZW9mIG8ucHhhdD09XCJudW1iZXJcIj9yLnB1c2goXCJweGF0XCIsby5weGF0KTpcImtlZXBUdGxcImluIG8mJm8ua2VlcFR0bCYmci5wdXNoKFwia2VlcFR0bFwiKSksc3VwZXIocixtKX19O3ZhciBidD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzZXRiaXRcIiwuLi5uXSx0KX19O3ZhciBUdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzZXRleFwiLC4uLm5dLHQpfX07dmFyIE90PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInNldG54XCIsLi4ubl0sdCl9fTt2YXIgd3Q9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic2V0cmFuZ2VcIiwuLi5uXSx0KX19O3ZhciBEdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzaW50ZXJcIiwuLi5uXSx0KX19O3ZhciBBdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJzaW50ZXJzdG9yZVwiLC4uLm5dLHQpfX07dmFyIGt0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInNpc21lbWJlclwiLC4uLm5dLHQpfX07dmFyIFJ0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInNtZW1iZXJzXCIsLi4ubl0sdCl9fTt2YXIgU3Q9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic21pc21lbWJlclwiLG5bMF0sLi4ublsxXV0sdCl9fTt2YXIgRXQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic21vdmVcIiwuLi5uXSx0KX19O3ZhciBNdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdF0sbyl7bGV0IG09W1wic3BvcFwiLG5dO3R5cGVvZiB0PT1cIm51bWJlclwiJiZtLnB1c2godCksc3VwZXIobSxvKX19O3ZhciB2dD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdF0sbyl7bGV0IG09W1wic3JhbmRtZW1iZXJcIixuXTt0eXBlb2YgdD09XCJudW1iZXJcIiYmbS5wdXNoKHQpLHN1cGVyKG0sbyl9fTt2YXIgUHQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic3JlbVwiLC4uLm5dLHQpfX07dmFyIEl0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG9dLG0pe2xldCByPVtcInNzY2FuXCIsbix0XTtvPy5tYXRjaCYmci5wdXNoKFwibWF0Y2hcIixvLm1hdGNoKSx0eXBlb2Ygbz8uY291bnQ9PVwibnVtYmVyXCImJnIucHVzaChcImNvdW50XCIsby5jb3VudCksc3VwZXIocix7ZGVzZXJpYWxpemU6aCwuLi5tfSl9fTt2YXIgTnQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic3RybGVuXCIsLi4ubl0sdCl9fTt2YXIgTHQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic3VuaW9uXCIsLi4ubl0sdCl9fTt2YXIgenQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wic3VuaW9uc3RvcmVcIiwuLi5uXSx0KX19O3ZhciBHdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobil7c3VwZXIoW1widGltZVwiXSxuKX19O3ZhciBLdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ0b3VjaFwiLC4uLm5dLHQpfX07dmFyIFh0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInR0bFwiLC4uLm5dLHQpfX07dmFyIFV0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInR5cGVcIiwuLi5uXSx0KX19O3ZhciBKdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ1bmxpbmtcIiwuLi5uXSx0KX19O3ZhciBCdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvXSxtKXtsZXQgcj1BcnJheS5pc0FycmF5KG8pP1suLi5vXTpbb107c3VwZXIoW1wiWEFDS1wiLG4sdCwuLi5yXSxtKX19O3ZhciBadD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvLG1dLHIpe2xldCBhPVtcIlhBRERcIixuXTttJiYobS5ub21rU3RyZWFtJiZhLnB1c2goXCJOT01LU1RSRUFNXCIpLG0udHJpbSYmKGEucHVzaChtLnRyaW0udHlwZSxtLnRyaW0uY29tcGFyaXNvbixtLnRyaW0udGhyZXNob2xkKSx0eXBlb2YgbS50cmltLmxpbWl0PFwidVwiJiZhLnB1c2goXCJMSU1JVFwiLG0udHJpbS5saW1pdCkpKSxhLnB1c2godCk7Zm9yKGxldFtpLHBdb2YgT2JqZWN0LmVudHJpZXMobykpYS5wdXNoKGkscCk7c3VwZXIoYSxyKX19O3ZhciBIdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvLG0scixhXSxpKXtsZXQgcD1bXTthPy5jb3VudCYmcC5wdXNoKFwiQ09VTlRcIixhLmNvdW50KSxhPy5qdXN0SWQmJnAucHVzaChcIkpVU1RJRFwiKSxzdXBlcihbXCJYQVVUT0NMQUlNXCIsbix0LG8sbSxyLC4uLnBdLGkpfX07dmFyIEZ0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG8sbSxyLGFdLGkpe2xldCBwPUFycmF5LmlzQXJyYXkocik/Wy4uLnJdOltyXSxkPVtdO2E/LmlkbGVNUyYmZC5wdXNoKFwiSURMRVwiLGEuaWRsZU1TKSxhPy5pZGxlTVMmJmQucHVzaChcIlRJTUVcIixhLnRpbWVNUyksYT8ucmV0cnlDb3VudCYmZC5wdXNoKFwiUkVUUllDT1VOVFwiLGE/LnJldHJ5Q291bnQpLGE/LmZvcmNlJiZkLnB1c2goXCJGT1JDRVwiKSxhPy5qdXN0SWQmJmQucHVzaChcIkpVU1RJRFwiKSxhPy5sYXN0SWQmJmQucHVzaChcIkxBU1RJRFwiLGEubGFzdElkKSxzdXBlcihbXCJYQ0xBSU1cIixuLHQsbyxtLC4uLnAsLi4uZF0saSl9fTt2YXIgJHQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHRdLG8pe2xldCBtPUFycmF5LmlzQXJyYXkodCk/Wy4uLnRdOlt0XTtzdXBlcihbXCJYREVMXCIsbiwuLi5tXSxvKX19O3ZhciBxdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdF0sbyl7bGV0IG09W1wiWEdST1VQXCJdO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIkNSRUFURVwiOm0ucHVzaChcIkNSRUFURVwiLG4sdC5ncm91cCx0LmlkKSx0Lm9wdGlvbnMmJih0Lm9wdGlvbnMuTUtTVFJFQU0mJm0ucHVzaChcIk1LU1RSRUFNXCIpLHQub3B0aW9ucy5FTlRSSUVTUkVBRCE9PXZvaWQgMCYmbS5wdXNoKFwiRU5UUklFU1JFQURcIix0Lm9wdGlvbnMuRU5UUklFU1JFQUQudG9TdHJpbmcoKSkpO2JyZWFrO2Nhc2VcIkNSRUFURUNPTlNVTUVSXCI6bS5wdXNoKFwiQ1JFQVRFQ09OU1VNRVJcIixuLHQuZ3JvdXAsdC5jb25zdW1lcik7YnJlYWs7Y2FzZVwiREVMQ09OU1VNRVJcIjptLnB1c2goXCJERUxDT05TVU1FUlwiLG4sdC5ncm91cCx0LmNvbnN1bWVyKTticmVhaztjYXNlXCJERVNUUk9ZXCI6bS5wdXNoKFwiREVTVFJPWVwiLG4sdC5ncm91cCk7YnJlYWs7Y2FzZVwiU0VUSURcIjptLnB1c2goXCJTRVRJRFwiLG4sdC5ncm91cCx0LmlkKSx0Lm9wdGlvbnMmJnQub3B0aW9ucy5FTlRSSUVTUkVBRCE9PXZvaWQgMCYmbS5wdXNoKFwiRU5UUklFU1JFQURcIix0Lm9wdGlvbnMuRU5UUklFU1JFQUQudG9TdHJpbmcoKSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFhHUk9VUFwiKX1zdXBlcihtLG8pfX07dmFyIGp0PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0XSxvKXtsZXQgbT1bXTt0LnR5cGU9PT1cIkNPTlNVTUVSU1wiP20ucHVzaChcIkNPTlNVTUVSU1wiLG4sdC5ncm91cCk6bS5wdXNoKFwiR1JPVVBTXCIsbiksc3VwZXIoW1wiWElORk9cIiwuLi5tXSxvKX19O3ZhciBZdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJYTEVOXCIsLi4ubl0sdCl9fTt2YXIgVnQ9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsbyxtLHIsYV0saSl7bGV0IHA9dHlwZW9mIGE/LmNvbnN1bWVyPFwidVwiP0FycmF5LmlzQXJyYXkoYS5jb25zdW1lcik/Wy4uLmEuY29uc3VtZXJdOlthLmNvbnN1bWVyXTpbXTtzdXBlcihbXCJYUEVORElOR1wiLG4sdCwuLi5hPy5pZGxlVGltZT9bXCJJRExFXCIsYS5pZGxlVGltZV06W10sbyxtLHIsLi4ucF0saSl9fTtmdW5jdGlvbiBCZShzKXtsZXQgbj17fTtmb3IobGV0IHQgb2Ygcylmb3IoO3QubGVuZ3RoPj0yOyl7bGV0IG89dC5zaGlmdCgpLG09dC5zaGlmdCgpO2ZvcigobyBpbiBuKXx8KG5bb109e30pO20ubGVuZ3RoPj0yOyl7bGV0IHI9bS5zaGlmdCgpLGE9bS5zaGlmdCgpO3RyeXtuW29dW3JdPUpTT04ucGFyc2UoYSl9Y2F0Y2h7bltvXVtyXT1hfX19cmV0dXJuIG59dmFyIF90PWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG8sbV0scil7bGV0IGE9W1wiWFJBTkdFXCIsbix0LG9dO3R5cGVvZiBtPT1cIm51bWJlclwiJiZhLnB1c2goXCJDT1VOVFwiLG0pLHN1cGVyKGEse2Rlc2VyaWFsaXplOmk9PkJlKGkpLC4uLnJ9KX19O3ZhciBaZT1cIkVSUiBVbmJhbGFuY2VkIFhSRUFEIGxpc3Qgb2Ygc3RyZWFtczogZm9yIGVhY2ggc3RyZWFtIGtleSBhbiBJRCBvciAnJCcgbXVzdCBiZSBzcGVjaWZpZWRcIixXdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvXSxtKXtpZihBcnJheS5pc0FycmF5KG4pJiZBcnJheS5pc0FycmF5KHQpJiZuLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihaZSk7bGV0IHI9W107dHlwZW9mIG8/LmNvdW50PT1cIm51bWJlclwiJiZyLnB1c2goXCJDT1VOVFwiLG8uY291bnQpLHR5cGVvZiBvPy5ibG9ja01TPT1cIm51bWJlclwiJiZyLnB1c2goXCJCTE9DS1wiLG8uYmxvY2tNUyksci5wdXNoKFwiU1RSRUFNU1wiLC4uLkFycmF5LmlzQXJyYXkobik/Wy4uLm5dOltuXSwuLi5BcnJheS5pc0FycmF5KHQpP1suLi50XTpbdF0pLHN1cGVyKFtcIlhSRUFEXCIsLi4ucl0sbSl9fTt2YXIgSGU9XCJFUlIgVW5iYWxhbmNlZCBYUkVBREdST1VQIGxpc3Qgb2Ygc3RyZWFtczogZm9yIGVhY2ggc3RyZWFtIGtleSBhbiBJRCBvciAnJCcgbXVzdCBiZSBzcGVjaWZpZWRcIixRdD1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvLG0scl0sYSl7aWYoQXJyYXkuaXNBcnJheShvKSYmQXJyYXkuaXNBcnJheShtKSYmby5sZW5ndGghPT1tLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoSGUpO2xldCBpPVtdO3R5cGVvZiByPy5jb3VudD09XCJudW1iZXJcIiYmaS5wdXNoKFwiQ09VTlRcIixyLmNvdW50KSx0eXBlb2Ygcj8uYmxvY2tNUz09XCJudW1iZXJcIiYmaS5wdXNoKFwiQkxPQ0tcIixyLmJsb2NrTVMpLHR5cGVvZiByPy5OT0FDSz09XCJib29sZWFuXCImJnI/Lk5PQUNLJiZpLnB1c2goXCJOT0FDS1wiKSxpLnB1c2goXCJTVFJFQU1TXCIsLi4uQXJyYXkuaXNBcnJheShvKT9bLi4ub106W29dLC4uLkFycmF5LmlzQXJyYXkobSk/Wy4uLm1dOlttXSksc3VwZXIoW1wiWFJFQURHUk9VUFwiLFwiR1JPVVBcIixuLHQsLi4uaV0sYSl9fTt2YXIgbmU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsbyxtXSxyKXtsZXQgYT1bXCJYUkVWUkFOR0VcIixuLHQsb107dHlwZW9mIG09PVwibnVtYmVyXCImJmEucHVzaChcIkNPVU5UXCIsbSksc3VwZXIoYSx7ZGVzZXJpYWxpemU6aT0+RmUoaSksLi4ucn0pfX07ZnVuY3Rpb24gRmUocyl7bGV0IG49e307Zm9yKGxldCB0IG9mIHMpZm9yKDt0Lmxlbmd0aD49Mjspe2xldCBvPXQuc2hpZnQoKSxtPXQuc2hpZnQoKTtmb3IoKG8gaW4gbil8fChuW29dPXt9KTttLmxlbmd0aD49Mjspe2xldCByPW0uc2hpZnQoKSxhPW0uc2hpZnQoKTt0cnl7bltvXVtyXT1KU09OLnBhcnNlKGEpfWNhdGNoe25bb11bcl09YX19fXJldHVybiBufXZhciB0ZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdF0sbyl7bGV0e2xpbWl0Om0sc3RyYXRlZ3k6cix0aHJlc2hvbGQ6YSxleGFjdG5lc3M6aT1cIn5cIn09dDtzdXBlcihbXCJYVFJJTVwiLG4scixpLGEsLi4ubT9bXCJMSU1JVFwiLG1dOltdXSxvKX19O3ZhciBsPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LC4uLm9dLG0pe2xldCByPVtcInphZGRcIixuXTtcIm54XCJpbiB0JiZ0Lm54P3IucHVzaChcIm54XCIpOlwieHhcImluIHQmJnQueHgmJnIucHVzaChcInh4XCIpLFwiY2hcImluIHQmJnQuY2gmJnIucHVzaChcImNoXCIpLFwiaW5jclwiaW4gdCYmdC5pbmNyJiZyLnB1c2goXCJpbmNyXCIpLFwibHRcImluIHQmJnQubHQ/ci5wdXNoKFwibHRcIik6XCJndFwiaW4gdCYmdC5ndCYmci5wdXNoKFwiZ3RcIiksXCJzY29yZVwiaW4gdCYmXCJtZW1iZXJcImluIHQmJnIucHVzaCh0LnNjb3JlLHQubWVtYmVyKSxyLnB1c2goLi4uby5mbGF0TWFwKCh7c2NvcmU6YSxtZW1iZXI6aX0pPT5bYSxpXSkpLHN1cGVyKHIsbSl9fTt2YXIgZWU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiemNhcmRcIiwuLi5uXSx0KX19O3ZhciBvZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6Y291bnRcIiwuLi5uXSx0KX19O3ZhciBzZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6aW5jcmJ5XCIsLi4ubl0sdCl9fTt2YXIgbWU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsbyxtXSxyKXtsZXQgYT1bXCJ6aW50ZXJzdG9yZVwiLG4sdF07QXJyYXkuaXNBcnJheShvKT9hLnB1c2goLi4ubyk6YS5wdXNoKG8pLG0mJihcIndlaWdodHNcImluIG0mJm0ud2VpZ2h0cz9hLnB1c2goXCJ3ZWlnaHRzXCIsLi4ubS53ZWlnaHRzKTpcIndlaWdodFwiaW4gbSYmdHlwZW9mIG0ud2VpZ2h0PT1cIm51bWJlclwiJiZhLnB1c2goXCJ3ZWlnaHRzXCIsbS53ZWlnaHQpLFwiYWdncmVnYXRlXCJpbiBtJiZhLnB1c2goXCJhZ2dyZWdhdGVcIixtLmFnZ3JlZ2F0ZSkpLHN1cGVyKGEscil9fTt2YXIgcmU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wiemxleGNvdW50XCIsLi4ubl0sdCl9fTt2YXIgYWU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHRdLG8pe2xldCBtPVtcInpwb3BtYXhcIixuXTt0eXBlb2YgdD09XCJudW1iZXJcIiYmbS5wdXNoKHQpLHN1cGVyKG0sbyl9fTt2YXIgaWU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHRdLG8pe2xldCBtPVtcInpwb3BtaW5cIixuXTt0eXBlb2YgdD09XCJudW1iZXJcIiYmbS5wdXNoKHQpLHN1cGVyKG0sbyl9fTt2YXIgcGU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsbyxtXSxyKXtsZXQgYT1bXCJ6cmFuZ2VcIixuLHQsb107bT8uYnlTY29yZSYmYS5wdXNoKFwiYnlzY29yZVwiKSxtPy5ieUxleCYmYS5wdXNoKFwiYnlsZXhcIiksbT8ucmV2JiZhLnB1c2goXCJyZXZcIiksdHlwZW9mIG0/LmNvdW50PFwidVwiJiZ0eXBlb2YgbT8ub2Zmc2V0PFwidVwiJiZhLnB1c2goXCJsaW1pdFwiLG0ub2Zmc2V0LG0uY291bnQpLG0/LndpdGhTY29yZXMmJmEucHVzaChcIndpdGhzY29yZXNcIiksc3VwZXIoYSxyKX19O3ZhciBkZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6cmFua1wiLC4uLm5dLHQpfX07dmFyIGNlPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInpyZW1cIiwuLi5uXSx0KX19O3ZhciB1ZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6cmVtcmFuZ2VieWxleFwiLC4uLm5dLHQpfX07dmFyIGhlPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInpyZW1yYW5nZWJ5cmFua1wiLC4uLm5dLHQpfX07dmFyIGxlPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihuLHQpe3N1cGVyKFtcInpyZW1yYW5nZWJ5c2NvcmVcIiwuLi5uXSx0KX19O3ZhciBDZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6cmV2cmFua1wiLC4uLm5dLHQpfX07dmFyIGdlPWNsYXNzIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcihbbix0LG9dLG0pe2xldCByPVtcInpzY2FuXCIsbix0XTtvPy5tYXRjaCYmci5wdXNoKFwibWF0Y2hcIixvLm1hdGNoKSx0eXBlb2Ygbz8uY291bnQ9PVwibnVtYmVyXCImJnIucHVzaChcImNvdW50XCIsby5jb3VudCksc3VwZXIocix7ZGVzZXJpYWxpemU6aCwuLi5tfSl9fTt2YXIgeGU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7c3VwZXIoW1wienNjb3JlXCIsLi4ubl0sdCl9fTt2YXIgZmU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKFtuLHQsb10sbSl7bGV0IHI9W1wienVuaW9uXCIsbl07QXJyYXkuaXNBcnJheSh0KT9yLnB1c2goLi4udCk6ci5wdXNoKHQpLG8mJihcIndlaWdodHNcImluIG8mJm8ud2VpZ2h0cz9yLnB1c2goXCJ3ZWlnaHRzXCIsLi4uby53ZWlnaHRzKTpcIndlaWdodFwiaW4gbyYmdHlwZW9mIG8ud2VpZ2h0PT1cIm51bWJlclwiJiZyLnB1c2goXCJ3ZWlnaHRzXCIsby53ZWlnaHQpLFwiYWdncmVnYXRlXCJpbiBvJiZyLnB1c2goXCJhZ2dyZWdhdGVcIixvLmFnZ3JlZ2F0ZSksbz8ud2l0aFNjb3JlcyYmci5wdXNoKFwid2l0aHNjb3Jlc1wiKSksc3VwZXIocixtKX19O3ZhciB5ZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoW24sdCxvLG1dLHIpe2xldCBhPVtcInp1bmlvbnN0b3JlXCIsbix0XTtBcnJheS5pc0FycmF5KG8pP2EucHVzaCguLi5vKTphLnB1c2gobyksbSYmKFwid2VpZ2h0c1wiaW4gbSYmbS53ZWlnaHRzP2EucHVzaChcIndlaWdodHNcIiwuLi5tLndlaWdodHMpOlwid2VpZ2h0XCJpbiBtJiZ0eXBlb2YgbS53ZWlnaHQ9PVwibnVtYmVyXCImJmEucHVzaChcIndlaWdodHNcIixtLndlaWdodCksXCJhZ2dyZWdhdGVcImluIG0mJmEucHVzaChcImFnZ3JlZ2F0ZVwiLG0uYWdncmVnYXRlKSksc3VwZXIoYSxyKX19O3ZhciBiZT1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3Iobix0KXtzdXBlcihbXCJ6ZGlmZnN0b3JlXCIsLi4ubl0sdCl9fTt2YXIgVGU9Y2xhc3MgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKG4sdCl7bGV0W28sbV09bjtzdXBlcihbXCJ6bXNjb3JlXCIsbywuLi5tXSx0KX19O3ZhciB3ZT1jbGFzc3tjbGllbnQ7Y29tbWFuZHM7Y29tbWFuZE9wdGlvbnM7bXVsdGlFeGVjO2NvbnN0cnVjdG9yKG4pe2lmKHRoaXMuY2xpZW50PW4uY2xpZW50LHRoaXMuY29tbWFuZHM9W10sdGhpcy5jb21tYW5kT3B0aW9ucz1uLmNvbW1hbmRPcHRpb25zLHRoaXMubXVsdGlFeGVjPW4ubXVsdGlFeGVjPz8hMSx0aGlzLmNvbW1hbmRPcHRpb25zPy5sYXRlbmN5TG9nZ2luZyl7bGV0IHQ9dGhpcy5leGVjLmJpbmQodGhpcyk7dGhpcy5leGVjPWFzeW5jKCk9PntsZXQgbz1wZXJmb3JtYW5jZS5ub3coKSxtPWF3YWl0IHQoKSxhPShwZXJmb3JtYW5jZS5ub3coKS1vKS50b0ZpeGVkKDIpO3JldHVybiBjb25zb2xlLmxvZyhgTGF0ZW5jeSBmb3IgXFx4MUJbMzg7MjsxOTsxODU7MzltJHt0aGlzLm11bHRpRXhlYz9bXCJNVUxUSS1FWEVDXCJdOltcIlBJUEVMSU5FXCJdLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKX1cXHgxQlswbTogXFx4MUJbMzg7MjswOzI1NTsyNTVtJHthfSBtc1xceDFCWzBtYCksbX19fWV4ZWM9YXN5bmMoKT0+e2lmKHRoaXMuY29tbWFuZHMubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJQaXBlbGluZSBpcyBlbXB0eVwiKTtsZXQgbj10aGlzLm11bHRpRXhlYz9bXCJtdWx0aS1leGVjXCJdOltcInBpcGVsaW5lXCJdO3JldHVybihhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtwYXRoOm4sYm9keTpPYmplY3QudmFsdWVzKHRoaXMuY29tbWFuZHMpLm1hcChvPT5vLmNvbW1hbmQpfSkpLm1hcCgoe2Vycm9yOm8scmVzdWx0Om19LHIpPT57aWYobyl0aHJvdyBuZXcgdShgQ29tbWFuZCAke3IrMX0gWyAke3RoaXMuY29tbWFuZHNbcl0uY29tbWFuZFswXX0gXSBmYWlsZWQ6ICR7b31gKTtyZXR1cm4gdGhpcy5jb21tYW5kc1tyXS5kZXNlcmlhbGl6ZShtKX0pfTtsZW5ndGgoKXtyZXR1cm4gdGhpcy5jb21tYW5kcy5sZW5ndGh9Y2hhaW4obil7cmV0dXJuIHRoaXMuY29tbWFuZHMucHVzaChuKSx0aGlzfWFwcGVuZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGcobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7Yml0Y291bnQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyB4KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2JpdGZpZWxkPSguLi5uKT0+bmV3IGYobix0aGlzLmNsaWVudCx0aGlzLmNvbW1hbmRPcHRpb25zLHRoaXMuY2hhaW4uYmluZCh0aGlzKSk7Yml0b3A9KG4sdCxvLC4uLm0pPT50aGlzLmNoYWluKG5ldyB5KFtuLHQsbywuLi5tXSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7Yml0cG9zPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgYihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtjb3B5PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgVChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6ZGlmZnN0b3JlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgYmUobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7ZGJzaXplPSgpPT50aGlzLmNoYWluKG5ldyBPKHRoaXMuY29tbWFuZE9wdGlvbnMpKTtkZWNyPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgdyhuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtkZWNyYnk9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBEKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2RlbD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IEEobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7ZWNobz0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGsobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7ZXZhbD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFIobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7ZXZhbHNoYT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFMobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7ZXhpc3RzPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgRShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtleHBpcmU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBNKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2V4cGlyZWF0PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgdihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtmbHVzaGFsbD1uPT50aGlzLmNoYWluKG5ldyBQKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2ZsdXNoZGI9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBJKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2dlb2FkZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IE4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7Z2VvZGlzdD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IEwobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7Z2VvcG9zPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgRyhuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtnZW9oYXNoPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgeihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtnZW9zZWFyY2g9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBLKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2dlb3NlYXJjaHN0b3JlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgWChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtnZXQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBVKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2dldGJpdD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IEoobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7Z2V0ZGVsPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgQihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtnZXRyYW5nZT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFoobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7Z2V0c2V0PShuLHQpPT50aGlzLmNoYWluKG5ldyBIKFtuLHRdLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoZGVsPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgRihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoZXhpc3RzPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgJChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoZ2V0PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgcShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoZ2V0YWxsPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgaihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoaW5jcmJ5PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgWShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoaW5jcmJ5ZmxvYXQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBWKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2hrZXlzPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgXyhuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtobGVuPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgVyhuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtobWdldD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFEobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7aG1zZXQ9KG4sdCk9PnRoaXMuY2hhaW4obmV3IG5uKFtuLHRdLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtocmFuZGZpZWxkPShuLHQsbyk9PnRoaXMuY2hhaW4obmV3IHRuKFtuLHQsb10sdGhpcy5jb21tYW5kT3B0aW9ucykpO2hzY2FuPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgZW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7aHNldD0obix0KT0+dGhpcy5jaGFpbihuZXcgb24oW24sdF0sdGhpcy5jb21tYW5kT3B0aW9ucykpO2hzZXRueD0obix0LG8pPT50aGlzLmNoYWluKG5ldyBzbihbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtoc3RybGVuPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgbW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7aHZhbHM9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBybihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtpbmNyPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgYW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7aW5jcmJ5PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgcG4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7aW5jcmJ5ZmxvYXQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBkbihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtrZXlzPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgUG4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bGluZGV4PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgSW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bGluc2VydD0obix0LG8sbSk9PnRoaXMuY2hhaW4obmV3IE5uKFtuLHQsbyxtXSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7bGxlbj0oLi4ubik9PnRoaXMuY2hhaW4obmV3IExuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2xtb3ZlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgem4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bHBvcD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IEtuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2xtcG9wPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgR24obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bHBvcz0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFhuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO2xwdXNoPShuLC4uLnQpPT50aGlzLmNoYWluKG5ldyBVbihbbiwuLi50XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7bHB1c2h4PShuLC4uLnQpPT50aGlzLmNoYWluKG5ldyBKbihbbiwuLi50XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7bHJhbmdlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgQm4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bHJlbT0obix0LG8pPT50aGlzLmNoYWluKG5ldyBabihbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtsc2V0PShuLHQsbyk9PnRoaXMuY2hhaW4obmV3IEhuKFtuLHQsb10sdGhpcy5jb21tYW5kT3B0aW9ucykpO2x0cmltPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgRm4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7bWdldD0oLi4ubik9PnRoaXMuY2hhaW4obmV3ICRuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO21zZXQ9bj0+dGhpcy5jaGFpbihuZXcgcW4oW25dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTttc2V0bng9bj0+dGhpcy5jaGFpbihuZXcgam4oW25dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtwZXJzaXN0PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgWW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7cGV4cGlyZT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFZuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3BleHBpcmVhdD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IF9uKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3BmYWRkPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgV24obix0aGlzLmNvbW1hbmRPcHRpb25zKSk7cGZjb3VudD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFFuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3BmbWVyZ2U9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBudChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtwaW5nPW49PnRoaXMuY2hhaW4obmV3IHR0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3BzZXRleD0obix0LG8pPT50aGlzLmNoYWluKG5ldyBldChbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtwdHRsPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgb3Qobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7cHVibGlzaD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IHN0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3JhbmRvbWtleT0oKT0+dGhpcy5jaGFpbihuZXcgbXQodGhpcy5jb21tYW5kT3B0aW9ucykpO3JlbmFtZT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IHJ0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3JlbmFtZW54PSguLi5uKT0+dGhpcy5jaGFpbihuZXcgYXQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7cnBvcD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGl0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3JwdXNoPShuLC4uLnQpPT50aGlzLmNoYWluKG5ldyBwdChbbiwuLi50XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7cnB1c2h4PShuLC4uLnQpPT50aGlzLmNoYWluKG5ldyBkdChbbiwuLi50XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7c2FkZD0obiwuLi50KT0+dGhpcy5jaGFpbihuZXcgY3QoW24sLi4udF0sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NjYW49KC4uLm4pPT50aGlzLmNoYWluKG5ldyB1dChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzY2FyZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGh0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NjcmlwdEV4aXN0cz0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGx0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NjcmlwdEZsdXNoPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgQ3Qobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7c2NyaXB0TG9hZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGd0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NkaWZmPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgeHQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7c2RpZmZzdG9yZT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGZ0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NldD0obix0LG8pPT50aGlzLmNoYWluKG5ldyB5dChbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzZXRiaXQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBidChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzZXRleD0obix0LG8pPT50aGlzLmNoYWluKG5ldyBUdChbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzZXRueD0obix0KT0+dGhpcy5jaGFpbihuZXcgT3QoW24sdF0sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NldHJhbmdlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgd3Qobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7c2ludGVyPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgRHQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7c2ludGVyc3RvcmU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBBdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzaXNtZW1iZXI9KG4sdCk9PnRoaXMuY2hhaW4obmV3IGt0KFtuLHRdLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzbWVtYmVycz0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFJ0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3NtaXNtZW1iZXI9KG4sdCk9PnRoaXMuY2hhaW4obmV3IFN0KFtuLHRdLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzbW92ZT0obix0LG8pPT50aGlzLmNoYWluKG5ldyBFdChbbix0LG9dLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzcG9wPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgTXQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7c3JhbmRtZW1iZXI9KC4uLm4pPT50aGlzLmNoYWluKG5ldyB2dChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzcmVtPShuLC4uLnQpPT50aGlzLmNoYWluKG5ldyBQdChbbiwuLi50XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7c3NjYW49KC4uLm4pPT50aGlzLmNoYWluKG5ldyBJdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzdHJsZW49KC4uLm4pPT50aGlzLmNoYWluKG5ldyBOdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzdW5pb249KC4uLm4pPT50aGlzLmNoYWluKG5ldyBMdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtzdW5pb25zdG9yZT0oLi4ubik9PnRoaXMuY2hhaW4obmV3IHp0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3RpbWU9KCk9PnRoaXMuY2hhaW4obmV3IEd0KHRoaXMuY29tbWFuZE9wdGlvbnMpKTt0b3VjaD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IEt0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3R0bD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFh0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3R5cGU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBVdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt1bmxpbms9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBKdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6YWRkPSguLi5uKT0+XCJzY29yZVwiaW4gblsxXT90aGlzLmNoYWluKG5ldyBsKFtuWzBdLG5bMV0sLi4ubi5zbGljZSgyKV0sdGhpcy5jb21tYW5kT3B0aW9ucykpOnRoaXMuY2hhaW4obmV3IGwoW25bMF0sblsxXSwuLi5uLnNsaWNlKDIpXSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7eGFkZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IFp0KG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3hhY2s9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBCdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4ZGVsPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgJHQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7eGdyb3VwPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgcXQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7eHJlYWQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBXdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4cmVhZGdyb3VwPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgUXQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7eGluZm89KC4uLm4pPT50aGlzLmNoYWluKG5ldyBqdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4bGVuPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgWXQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7eHBlbmRpbmc9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBWdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4Y2xhaW09KC4uLm4pPT50aGlzLmNoYWluKG5ldyBGdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4YXV0b2NsYWltPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgSHQobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7eHRyaW09KC4uLm4pPT50aGlzLmNoYWluKG5ldyB0ZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4cmFuZ2U9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBfdChuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt4cmV2cmFuZ2U9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBuZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6Y2FyZD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGVlKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pjb3VudD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IG9lKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3ppbmNyYnk9KG4sdCxvKT0+dGhpcy5jaGFpbihuZXcgc2UoW24sdCxvXSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7emludGVyc3RvcmU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBtZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6bGV4Y291bnQ9KC4uLm4pPT50aGlzLmNoYWluKG5ldyByZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6bXNjb3JlPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgVGUobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7enBvcG1heD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGFlKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pwb3BtaW49KC4uLm4pPT50aGlzLmNoYWluKG5ldyBpZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6cmFuZ2U9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBwZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6cmFuaz0obix0KT0+dGhpcy5jaGFpbihuZXcgZGUoW24sdF0sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pyZW09KG4sLi4udCk9PnRoaXMuY2hhaW4obmV3IGNlKFtuLC4uLnRdLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6cmVtcmFuZ2VieWxleD0oLi4ubik9PnRoaXMuY2hhaW4obmV3IHVlKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pyZW1yYW5nZWJ5cmFuaz0oLi4ubik9PnRoaXMuY2hhaW4obmV3IGhlKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pyZW1yYW5nZWJ5c2NvcmU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyBsZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6cmV2cmFuaz0obix0KT0+dGhpcy5jaGFpbihuZXcgQ2UoW24sdF0sdGhpcy5jb21tYW5kT3B0aW9ucykpO3pzY2FuPSguLi5uKT0+dGhpcy5jaGFpbihuZXcgZ2Uobix0aGlzLmNvbW1hbmRPcHRpb25zKSk7enNjb3JlPShuLHQpPT50aGlzLmNoYWluKG5ldyB4ZShbbix0XSx0aGlzLmNvbW1hbmRPcHRpb25zKSk7enVuaW9uc3RvcmU9KC4uLm4pPT50aGlzLmNoYWluKG5ldyB5ZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTt6dW5pb249KC4uLm4pPT50aGlzLmNoYWluKG5ldyBmZShuLHRoaXMuY29tbWFuZE9wdGlvbnMpKTtnZXQganNvbigpe3JldHVybnthcnJhcHBlbmQ6KC4uLm4pPT50aGlzLmNoYWluKG5ldyBjbihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKSxhcnJpbmRleDooLi4ubik9PnRoaXMuY2hhaW4obmV3IHVuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGFycmluc2VydDooLi4ubik9PnRoaXMuY2hhaW4obmV3IGhuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGFycmxlbjooLi4ubik9PnRoaXMuY2hhaW4obmV3IGxuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGFycnBvcDooLi4ubik9PnRoaXMuY2hhaW4obmV3IENuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGFycnRyaW06KC4uLm4pPT50aGlzLmNoYWluKG5ldyBnbihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKSxjbGVhcjooLi4ubik9PnRoaXMuY2hhaW4obmV3IHhuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGRlbDooLi4ubik9PnRoaXMuY2hhaW4obmV3IGZuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGZvcmdldDooLi4ubik9PnRoaXMuY2hhaW4obmV3IHluKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLGdldDooLi4ubik9PnRoaXMuY2hhaW4obmV3IGJuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLG1nZXQ6KC4uLm4pPT50aGlzLmNoYWluKG5ldyBUbihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKSxudW1pbmNyYnk6KC4uLm4pPT50aGlzLmNoYWluKG5ldyBPbihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKSxudW1tdWx0Ynk6KC4uLm4pPT50aGlzLmNoYWluKG5ldyB3bihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKSxvYmprZXlzOiguLi5uKT0+dGhpcy5jaGFpbihuZXcgRG4obix0aGlzLmNvbW1hbmRPcHRpb25zKSksb2JqbGVuOiguLi5uKT0+dGhpcy5jaGFpbihuZXcgQW4obix0aGlzLmNvbW1hbmRPcHRpb25zKSkscmVzcDooLi4ubik9PnRoaXMuY2hhaW4obmV3IGtuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLHNldDooLi4ubik9PnRoaXMuY2hhaW4obmV3IFJuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLHN0cmFwcGVuZDooLi4ubik9PnRoaXMuY2hhaW4obmV3IFNuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLHN0cmxlbjooLi4ubik9PnRoaXMuY2hhaW4obmV3IEVuKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLHRvZ2dsZTooLi4ubik9PnRoaXMuY2hhaW4obmV3IE1uKG4sdGhpcy5jb21tYW5kT3B0aW9ucykpLHR5cGU6KC4uLm4pPT50aGlzLmNoYWluKG5ldyB2bihuLHRoaXMuY29tbWFuZE9wdGlvbnMpKX19fTtpbXBvcnQgJGUgZnJvbVwiY3J5cHRvLWpzL2VuYy1oZXguanNcIjtpbXBvcnQgcWUgZnJvbVwiY3J5cHRvLWpzL3NoYTEuanNcIjt2YXIgQWU9Y2xhc3N7c2NyaXB0O3NoYTE7cmVkaXM7Y29uc3RydWN0b3Iobix0KXt0aGlzLnJlZGlzPW4sdGhpcy5zaGExPXRoaXMuZGlnZXN0KHQpLHRoaXMuc2NyaXB0PXR9YXN5bmMgZXZhbChuLHQpe3JldHVybiBhd2FpdCB0aGlzLnJlZGlzLmV2YWwodGhpcy5zY3JpcHQsbix0KX1hc3luYyBldmFsc2hhKG4sdCl7cmV0dXJuIGF3YWl0IHRoaXMucmVkaXMuZXZhbHNoYSh0aGlzLnNoYTEsbix0KX1hc3luYyBleGVjKG4sdCl7cmV0dXJuIGF3YWl0IHRoaXMucmVkaXMuZXZhbHNoYSh0aGlzLnNoYTEsbix0KS5jYXRjaChhc3luYyBtPT57aWYobSBpbnN0YW5jZW9mIEVycm9yJiZtLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5vc2NyaXB0XCIpKXJldHVybiBhd2FpdCB0aGlzLnJlZGlzLmV2YWwodGhpcy5zY3JpcHQsbix0KTt0aHJvdyBtfSl9ZGlnZXN0KG4pe3JldHVybiAkZS5zdHJpbmdpZnkocWUobikpfX07dmFyIEllPWNsYXNze2NsaWVudDtvcHRzO2VuYWJsZVRlbGVtZXRyeTtlbmFibGVBdXRvUGlwZWxpbmluZztjb25zdHJ1Y3RvcihuLHQpe3RoaXMuY2xpZW50PW4sdGhpcy5vcHRzPXQsdGhpcy5lbmFibGVUZWxlbWV0cnk9dD8uZW5hYmxlVGVsZW1ldHJ5Pz8hMCx0aGlzLmVuYWJsZUF1dG9QaXBlbGluaW5nPXQ/LmVuYWJsZUF1dG9QaXBlbGluaW5nPz8hMX1nZXQganNvbigpe3JldHVybnthcnJhcHBlbmQ6KC4uLm4pPT5uZXcgY24obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLGFycmluZGV4OiguLi5uKT0+bmV3IHVuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxhcnJpbnNlcnQ6KC4uLm4pPT5uZXcgaG4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLGFycmxlbjooLi4ubik9Pm5ldyBsbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksYXJycG9wOiguLi5uKT0+bmV3IENuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxhcnJ0cmltOiguLi5uKT0+bmV3IGduKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxjbGVhcjooLi4ubik9Pm5ldyB4bihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksZGVsOiguLi5uKT0+bmV3IGZuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxmb3JnZXQ6KC4uLm4pPT5uZXcgeW4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLGdldDooLi4ubik9Pm5ldyBibihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksbWdldDooLi4ubik9Pm5ldyBUbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksbnVtaW5jcmJ5OiguLi5uKT0+bmV3IE9uKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxudW1tdWx0Ynk6KC4uLm4pPT5uZXcgd24obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLG9iamtleXM6KC4uLm4pPT5uZXcgRG4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLG9iamxlbjooLi4ubik9Pm5ldyBBbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCkscmVzcDooLi4ubik9Pm5ldyBrbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksc2V0OiguLi5uKT0+bmV3IFJuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSxzdHJhcHBlbmQ6KC4uLm4pPT5uZXcgU24obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpLHN0cmxlbjooLi4ubik9Pm5ldyBFbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCksdG9nZ2xlOiguLi5uKT0+bmV3IE1uKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KSx0eXBlOiguLi5uKT0+bmV3IHZuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KX19dXNlPW49PntsZXQgdD10aGlzLmNsaWVudC5yZXF1ZXN0LmJpbmQodGhpcy5jbGllbnQpO3RoaXMuY2xpZW50LnJlcXVlc3Q9bz0+bihvLHQpfTthZGRUZWxlbWV0cnk9bj0+e2lmKHRoaXMuZW5hYmxlVGVsZW1ldHJ5KXRyeXt0aGlzLmNsaWVudC5tZXJnZVRlbGVtZXRyeShuKX1jYXRjaHt9fTtjcmVhdGVTY3JpcHQobil7cmV0dXJuIG5ldyBBZSh0aGlzLG4pfXBpcGVsaW5lPSgpPT5uZXcgd2Uoe2NsaWVudDp0aGlzLmNsaWVudCxjb21tYW5kT3B0aW9uczp0aGlzLm9wdHMsbXVsdGlFeGVjOiExfSk7YXV0b1BpcGVsaW5lPSgpPT5TZSh0aGlzKTttdWx0aT0oKT0+bmV3IHdlKHtjbGllbnQ6dGhpcy5jbGllbnQsY29tbWFuZE9wdGlvbnM6dGhpcy5vcHRzLG11bHRpRXhlYzohMH0pO2JpdGZpZWxkPSguLi5uKT0+bmV3IGYobix0aGlzLmNsaWVudCx0aGlzLm9wdHMpO2FwcGVuZD0oLi4ubik9Pm5ldyBnKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtiaXRjb3VudD0oLi4ubik9Pm5ldyB4KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtiaXRvcD0obix0LG8sLi4ubSk9Pm5ldyB5KFtuLHQsbywuLi5tXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2JpdHBvcz0oLi4ubik9Pm5ldyBiKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtjb3B5PSguLi5uKT0+bmV3IFQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2Ric2l6ZT0oKT0+bmV3IE8odGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtkZWNyPSguLi5uKT0+bmV3IHcobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2RlY3JieT0oLi4ubik9Pm5ldyBEKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtkZWw9KC4uLm4pPT5uZXcgQShuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7ZWNobz0oLi4ubik9Pm5ldyBrKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtldmFsPSguLi5uKT0+bmV3IFIobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2V2YWxzaGE9KC4uLm4pPT5uZXcgUyhuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7ZXhpc3RzPSguLi5uKT0+bmV3IEUobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2V4cGlyZT0oLi4ubik9Pm5ldyBNKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtleHBpcmVhdD0oLi4ubik9Pm5ldyB2KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtmbHVzaGFsbD1uPT5uZXcgUChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Zmx1c2hkYj0oLi4ubik9Pm5ldyBJKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtnZW9hZGQ9KC4uLm4pPT5uZXcgTihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2VvcG9zPSguLi5uKT0+bmV3IEcobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2dlb2Rpc3Q9KC4uLm4pPT5uZXcgTChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2VvaGFzaD0oLi4ubik9Pm5ldyB6KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtnZW9zZWFyY2g9KC4uLm4pPT5uZXcgSyhuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2Vvc2VhcmNoc3RvcmU9KC4uLm4pPT5uZXcgWChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2V0PSguLi5uKT0+bmV3IFUobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2dldGJpdD0oLi4ubik9Pm5ldyBKKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtnZXRkZWw9KC4uLm4pPT5uZXcgQihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2V0cmFuZ2U9KC4uLm4pPT5uZXcgWihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7Z2V0c2V0PShuLHQpPT5uZXcgSChbbix0XSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2hkZWw9KC4uLm4pPT5uZXcgRihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aGV4aXN0cz0oLi4ubik9Pm5ldyAkKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtoZ2V0PSguLi5uKT0+bmV3IHEobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2hnZXRhbGw9KC4uLm4pPT5uZXcgaihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aGluY3JieT0oLi4ubik9Pm5ldyBZKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtoaW5jcmJ5ZmxvYXQ9KC4uLm4pPT5uZXcgVihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aGtleXM9KC4uLm4pPT5uZXcgXyhuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aGxlbj0oLi4ubik9Pm5ldyBXKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtobWdldD0oLi4ubik9Pm5ldyBRKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtobXNldD0obix0KT0+bmV3IG5uKFtuLHRdLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aHJhbmRmaWVsZD0obix0LG8pPT5uZXcgdG4oW24sdCxvXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2hzY2FuPSguLi5uKT0+bmV3IGVuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtoc2V0PShuLHQpPT5uZXcgb24oW24sdF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtoc2V0bng9KG4sdCxvKT0+bmV3IHNuKFtuLHQsb10sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtoc3RybGVuPSguLi5uKT0+bmV3IG1uKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtodmFscz0oLi4ubik9Pm5ldyBybihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aW5jcj0oLi4ubik9Pm5ldyBhbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7aW5jcmJ5PSguLi5uKT0+bmV3IHBuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtpbmNyYnlmbG9hdD0oLi4ubik9Pm5ldyBkbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7a2V5cz0oLi4ubik9Pm5ldyBQbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7bGluZGV4PSguLi5uKT0+bmV3IEluKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtsaW5zZXJ0PShuLHQsbyxtKT0+bmV3IE5uKFtuLHQsbyxtXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2xsZW49KC4uLm4pPT5uZXcgTG4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2xtb3ZlPSguLi5uKT0+bmV3IHpuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtscG9wPSguLi5uKT0+bmV3IEtuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtsbXBvcD0oLi4ubik9Pm5ldyBHbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7bHBvcz0oLi4ubik9Pm5ldyBYbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7bHB1c2g9KG4sLi4udCk9Pm5ldyBVbihbbiwuLi50XSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2xwdXNoeD0obiwuLi50KT0+bmV3IEpuKFtuLC4uLnRdLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7bHJhbmdlPSguLi5uKT0+bmV3IEJuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtscmVtPShuLHQsbyk9Pm5ldyBabihbbix0LG9dLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7bHNldD0obix0LG8pPT5uZXcgSG4oW24sdCxvXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO2x0cmltPSguLi5uKT0+bmV3IEZuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTttZ2V0PSguLi5uKT0+bmV3ICRuKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTttc2V0PW49Pm5ldyBxbihbbl0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTttc2V0bng9bj0+bmV3IGpuKFtuXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3BlcnNpc3Q9KC4uLm4pPT5uZXcgWW4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3BleHBpcmU9KC4uLm4pPT5uZXcgVm4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3BleHBpcmVhdD0oLi4ubik9Pm5ldyBfbihuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7cGZhZGQ9KC4uLm4pPT5uZXcgV24obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3BmY291bnQ9KC4uLm4pPT5uZXcgUW4obix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3BmbWVyZ2U9KC4uLm4pPT5uZXcgbnQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3Bpbmc9bj0+bmV3IHR0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtwc2V0ZXg9KG4sdCxvKT0+bmV3IGV0KFtuLHQsb10sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtwdHRsPSguLi5uKT0+bmV3IG90KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtwdWJsaXNoPSguLi5uKT0+bmV3IHN0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtyYW5kb21rZXk9KCk9Pm5ldyBtdCgpLmV4ZWModGhpcy5jbGllbnQpO3JlbmFtZT0oLi4ubik9Pm5ldyBydChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7cmVuYW1lbng9KC4uLm4pPT5uZXcgYXQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3Jwb3A9KC4uLm4pPT5uZXcgaXQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3JwdXNoPShuLC4uLnQpPT5uZXcgcHQoW24sLi4udF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtycHVzaHg9KG4sLi4udCk9Pm5ldyBkdChbbiwuLi50XSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3NhZGQ9KG4sLi4udCk9Pm5ldyBjdChbbiwuLi50XSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3NjYW49KC4uLm4pPT5uZXcgdXQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3NjYXJkPSguLi5uKT0+bmV3IGh0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzY3JpcHRFeGlzdHM9KC4uLm4pPT5uZXcgbHQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3NjcmlwdEZsdXNoPSguLi5uKT0+bmV3IEN0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzY3JpcHRMb2FkPSguLi5uKT0+bmV3IGd0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzZGlmZj0oLi4ubik9Pm5ldyB4dChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c2RpZmZzdG9yZT0oLi4ubik9Pm5ldyBmdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c2V0PShuLHQsbyk9Pm5ldyB5dChbbix0LG9dLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c2V0Yml0PSguLi5uKT0+bmV3IGJ0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzZXRleD0obix0LG8pPT5uZXcgVHQoW24sdCxvXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3NldG54PShuLHQpPT5uZXcgT3QoW24sdF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzZXRyYW5nZT0oLi4ubik9Pm5ldyB3dChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c2ludGVyPSguLi5uKT0+bmV3IER0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzaW50ZXJzdG9yZT0oLi4ubik9Pm5ldyBBdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c2lzbWVtYmVyPShuLHQpPT5uZXcga3QoW24sdF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzbWlzbWVtYmVyPShuLHQpPT5uZXcgU3QoW24sdF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzbWVtYmVycz0oLi4ubik9Pm5ldyBSdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c21vdmU9KG4sdCxvKT0+bmV3IEV0KFtuLHQsb10sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzcG9wPSguLi5uKT0+bmV3IE10KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzcmFuZG1lbWJlcj0oLi4ubik9Pm5ldyB2dChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c3JlbT0obiwuLi50KT0+bmV3IFB0KFtuLC4uLnRdLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c3NjYW49KC4uLm4pPT5uZXcgSXQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3N0cmxlbj0oLi4ubik9Pm5ldyBOdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7c3VuaW9uPSguLi5uKT0+bmV3IEx0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTtzdW5pb25zdG9yZT0oLi4ubik9Pm5ldyB6dChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7dGltZT0oKT0+bmV3IEd0KCkuZXhlYyh0aGlzLmNsaWVudCk7dG91Y2g9KC4uLm4pPT5uZXcgS3Qobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3R0bD0oLi4ubik9Pm5ldyBYdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7dHlwZT0oLi4ubik9Pm5ldyBVdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7dW5saW5rPSguLi5uKT0+bmV3IEp0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4YWRkPSguLi5uKT0+bmV3IFp0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4YWNrPSguLi5uKT0+bmV3IEJ0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4ZGVsPSguLi5uKT0+bmV3ICR0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4Z3JvdXA9KC4uLm4pPT5uZXcgcXQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3hyZWFkPSguLi5uKT0+bmV3IFd0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4cmVhZGdyb3VwPSguLi5uKT0+bmV3IFF0KG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt4aW5mbz0oLi4ubik9Pm5ldyBqdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7eGxlbj0oLi4ubik9Pm5ldyBZdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7eHBlbmRpbmc9KC4uLm4pPT5uZXcgVnQobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3hjbGFpbT0oLi4ubik9Pm5ldyBGdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7eGF1dG9jbGFpbT0oLi4ubik9Pm5ldyBIdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7eHRyaW09KC4uLm4pPT5uZXcgdGUobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3hyYW5nZT0oLi4ubik9Pm5ldyBfdChuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7eHJldnJhbmdlPSguLi5uKT0+bmV3IG5lKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6YWRkPSguLi5uKT0+XCJzY29yZVwiaW4gblsxXT9uZXcgbChbblswXSxuWzFdLC4uLm4uc2xpY2UoMildLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk6bmV3IGwoW25bMF0sblsxXSwuLi5uLnNsaWNlKDIpXSx0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3pjYXJkPSguLi5uKT0+bmV3IGVlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6Y291bnQ9KC4uLm4pPT5uZXcgb2Uobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3pkaWZmc3RvcmU9KC4uLm4pPT5uZXcgYmUobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3ppbmNyYnk9KG4sdCxvKT0+bmV3IHNlKFtuLHQsb10sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6aW50ZXJzdG9yZT0oLi4ubik9Pm5ldyBtZShuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7emxleGNvdW50PSguLi5uKT0+bmV3IHJlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6bXNjb3JlPSguLi5uKT0+bmV3IFRlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cG9wbWF4PSguLi5uKT0+bmV3IGFlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cG9wbWluPSguLi5uKT0+bmV3IGllKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cmFuZ2U9KC4uLm4pPT5uZXcgcGUobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3pyYW5rPShuLHQpPT5uZXcgZGUoW24sdF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cmVtPShuLC4uLnQpPT5uZXcgY2UoW24sLi4udF0sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cmVtcmFuZ2VieWxleD0oLi4ubik9Pm5ldyB1ZShuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7enJlbXJhbmdlYnlyYW5rPSguLi5uKT0+bmV3IGhlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cmVtcmFuZ2VieXNjb3JlPSguLi5uKT0+bmV3IGxlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6cmV2cmFuaz0obix0KT0+bmV3IENlKFtuLHRdLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7enNjYW49KC4uLm4pPT5uZXcgZ2Uobix0aGlzLm9wdHMpLmV4ZWModGhpcy5jbGllbnQpO3pzY29yZT0obix0KT0+bmV3IHhlKFtuLHRdLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCk7enVuaW9uPSguLi5uKT0+bmV3IGZlKG4sdGhpcy5vcHRzKS5leGVjKHRoaXMuY2xpZW50KTt6dW5pb25zdG9yZT0oLi4ubik9Pm5ldyB5ZShuLHRoaXMub3B0cykuZXhlYyh0aGlzLmNsaWVudCl9O3ZhciB0Zz1cInYxLjMyLjBcIjtleHBvcnR7emUgYXMgYSxNZSBhcyBiLEllIGFzIGMsdGcgYXMgZH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@upstash/redis/chunk-DFUAPYBG.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@upstash/redis/nodejs.mjs":
/*!************************************************!*\
  !*** ./node_modules/@upstash/redis/nodejs.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Redis: () => (/* binding */ a),\n/* harmony export */   errors: () => (/* reexport safe */ _chunk_DFUAPYBG_mjs__WEBPACK_IMPORTED_MODULE_0__.a)\n/* harmony export */ });\n/* harmony import */ var _chunk_DFUAPYBG_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-DFUAPYBG.mjs */ \"(action-browser)/./node_modules/@upstash/redis/chunk-DFUAPYBG.mjs\");\ntypeof atob>\"u\"&&(global.atob=o=>Buffer.from(o,\"base64\").toString(\"utf-8\"));var a=class o extends _chunk_DFUAPYBG_mjs__WEBPACK_IMPORTED_MODULE_0__.c{constructor(e){if(\"request\"in e){super(e);return}if(!e.url)throw new Error(\"[Upstash Redis] The 'url' property is missing or undefined in your Redis config.\");if(!e.token)throw new Error(\"[Upstash Redis] The 'token' property is missing or undefined in your Redis config.\");(e.url.startsWith(\" \")||e.url.endsWith(\" \")||/\\r|\\n/.test(e.url))&&console.warn(\"The redis url contains whitespace or newline, which can cause errors!\"),(e.token.startsWith(\" \")||e.token.endsWith(\" \")||/\\r|\\n/.test(e.token))&&console.warn(\"The redis token contains whitespace or newline, which can cause errors!\");let n=new _chunk_DFUAPYBG_mjs__WEBPACK_IMPORTED_MODULE_0__.b({baseUrl:e.url,retry:e.retry,headers:{authorization:`Bearer ${e.token}`},agent:e.agent,responseEncoding:e.responseEncoding,cache:e.cache||\"no-store\",signal:e.signal,keepAlive:e.keepAlive});if(super(n,{automaticDeserialization:e.automaticDeserialization,enableTelemetry:!process.env.UPSTASH_DISABLE_TELEMETRY,latencyLogging:e.latencyLogging,enableAutoPipelining:e.enableAutoPipelining}),this.addTelemetry({runtime:typeof EdgeRuntime==\"string\"?\"edge-light\":`node@${process.version}`,platform:process.env.VERCEL?\"vercel\":process.env.AWS_REGION?\"aws\":\"unknown\",sdk:`@upstash/redis@${_chunk_DFUAPYBG_mjs__WEBPACK_IMPORTED_MODULE_0__.d}`}),this.enableAutoPipelining)return this.autoPipeline()}static fromEnv(e){if(typeof process?.env>\"u\")throw new Error('Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from \"@upstash/redis/cloudflare\" instead');let n=process?.env.UPSTASH_REDIS_REST_URL;if(!n)throw new Error(\"Unable to find environment variable: `UPSTASH_REDIS_REST_URL`\");let t=process?.env.UPSTASH_REDIS_REST_TOKEN;if(!t)throw new Error(\"Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`\");return new o({...e,url:n,token:t})}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9yZWRpcy9ub2RlanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RCw0RUFBNEUsc0JBQXNCLGtEQUFDLENBQUMsZUFBZSxrQkFBa0IsU0FBUyxPQUFPLDhHQUE4RyxrSEFBa0gsMFRBQTBULFVBQVUsa0RBQUMsRUFBRSxxQ0FBcUMsd0JBQXdCLFFBQVEsRUFBRSxtSEFBbUgsRUFBRSxZQUFZLHVMQUF1TCxxQkFBcUIsMERBQTBELGdCQUFnQixvR0FBb0csa0RBQUMsQ0FBQyxFQUFFLHVEQUF1RCxrQkFBa0IsME1BQTBNLDBDQUEwQyx1RkFBdUYsNENBQTRDLHlGQUF5RixjQUFjLG1CQUFtQixJQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BpY2t1cF9saW5lX2dlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9AdXBzdGFzaC9yZWRpcy9ub2RlanMubWpzPzg3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e2EgYXMgbCxiIGFzIHMsYyBhcyBpLGQgYXMgcn1mcm9tXCIuL2NodW5rLURGVUFQWUJHLm1qc1wiO3R5cGVvZiBhdG9iPlwidVwiJiYoZ2xvYmFsLmF0b2I9bz0+QnVmZmVyLmZyb20obyxcImJhc2U2NFwiKS50b1N0cmluZyhcInV0Zi04XCIpKTt2YXIgYT1jbGFzcyBvIGV4dGVuZHMgaXtjb25zdHJ1Y3RvcihlKXtpZihcInJlcXVlc3RcImluIGUpe3N1cGVyKGUpO3JldHVybn1pZighZS51cmwpdGhyb3cgbmV3IEVycm9yKFwiW1Vwc3Rhc2ggUmVkaXNdIFRoZSAndXJsJyBwcm9wZXJ0eSBpcyBtaXNzaW5nIG9yIHVuZGVmaW5lZCBpbiB5b3VyIFJlZGlzIGNvbmZpZy5cIik7aWYoIWUudG9rZW4pdGhyb3cgbmV3IEVycm9yKFwiW1Vwc3Rhc2ggUmVkaXNdIFRoZSAndG9rZW4nIHByb3BlcnR5IGlzIG1pc3Npbmcgb3IgdW5kZWZpbmVkIGluIHlvdXIgUmVkaXMgY29uZmlnLlwiKTsoZS51cmwuc3RhcnRzV2l0aChcIiBcIil8fGUudXJsLmVuZHNXaXRoKFwiIFwiKXx8L1xccnxcXG4vLnRlc3QoZS51cmwpKSYmY29uc29sZS53YXJuKFwiVGhlIHJlZGlzIHVybCBjb250YWlucyB3aGl0ZXNwYWNlIG9yIG5ld2xpbmUsIHdoaWNoIGNhbiBjYXVzZSBlcnJvcnMhXCIpLChlLnRva2VuLnN0YXJ0c1dpdGgoXCIgXCIpfHxlLnRva2VuLmVuZHNXaXRoKFwiIFwiKXx8L1xccnxcXG4vLnRlc3QoZS50b2tlbikpJiZjb25zb2xlLndhcm4oXCJUaGUgcmVkaXMgdG9rZW4gY29udGFpbnMgd2hpdGVzcGFjZSBvciBuZXdsaW5lLCB3aGljaCBjYW4gY2F1c2UgZXJyb3JzIVwiKTtsZXQgbj1uZXcgcyh7YmFzZVVybDplLnVybCxyZXRyeTplLnJldHJ5LGhlYWRlcnM6e2F1dGhvcml6YXRpb246YEJlYXJlciAke2UudG9rZW59YH0sYWdlbnQ6ZS5hZ2VudCxyZXNwb25zZUVuY29kaW5nOmUucmVzcG9uc2VFbmNvZGluZyxjYWNoZTplLmNhY2hlfHxcIm5vLXN0b3JlXCIsc2lnbmFsOmUuc2lnbmFsLGtlZXBBbGl2ZTplLmtlZXBBbGl2ZX0pO2lmKHN1cGVyKG4se2F1dG9tYXRpY0Rlc2VyaWFsaXphdGlvbjplLmF1dG9tYXRpY0Rlc2VyaWFsaXphdGlvbixlbmFibGVUZWxlbWV0cnk6IXByb2Nlc3MuZW52LlVQU1RBU0hfRElTQUJMRV9URUxFTUVUUlksbGF0ZW5jeUxvZ2dpbmc6ZS5sYXRlbmN5TG9nZ2luZyxlbmFibGVBdXRvUGlwZWxpbmluZzplLmVuYWJsZUF1dG9QaXBlbGluaW5nfSksdGhpcy5hZGRUZWxlbWV0cnkoe3J1bnRpbWU6dHlwZW9mIEVkZ2VSdW50aW1lPT1cInN0cmluZ1wiP1wiZWRnZS1saWdodFwiOmBub2RlQCR7cHJvY2Vzcy52ZXJzaW9ufWAscGxhdGZvcm06cHJvY2Vzcy5lbnYuVkVSQ0VMP1widmVyY2VsXCI6cHJvY2Vzcy5lbnYuQVdTX1JFR0lPTj9cImF3c1wiOlwidW5rbm93blwiLHNkazpgQHVwc3Rhc2gvcmVkaXNAJHtyfWB9KSx0aGlzLmVuYWJsZUF1dG9QaXBlbGluaW5nKXJldHVybiB0aGlzLmF1dG9QaXBlbGluZSgpfXN0YXRpYyBmcm9tRW52KGUpe2lmKHR5cGVvZiBwcm9jZXNzPy5lbnY+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGVudmlyb25tZW50IHZhcmlhYmxlcywgYHByb2Nlc3MuZW52YCBpcyB1bmRlZmluZWQuIElmIHlvdSBhcmUgZGVwbG95aW5nIHRvIGNsb3VkZmxhcmUsIHBsZWFzZSBpbXBvcnQgZnJvbSBcIkB1cHN0YXNoL3JlZGlzL2Nsb3VkZmxhcmVcIiBpbnN0ZWFkJyk7bGV0IG49cHJvY2Vzcz8uZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkw7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgZW52aXJvbm1lbnQgdmFyaWFibGU6IGBVUFNUQVNIX1JFRElTX1JFU1RfVVJMYFwiKTtsZXQgdD1wcm9jZXNzPy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGVudmlyb25tZW50IHZhcmlhYmxlOiBgVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOYFwiKTtyZXR1cm4gbmV3IG8oey4uLmUsdXJsOm4sdG9rZW46dH0pfX07ZXhwb3J0e2EgYXMgUmVkaXMsbCBhcyBlcnJvcnN9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@upstash/redis/nodejs.mjs\n");

/***/ })

};
;